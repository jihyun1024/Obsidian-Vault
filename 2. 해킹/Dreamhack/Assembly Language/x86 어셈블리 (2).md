### 들어가며
---
이번 강의에서는 함수 선언 및 호출, 그리고 system call을 어떻게 어셈블리 레벨에서 다루는지 살펴 본다. 고급 언어에서 함수를 사용하는 것처럼, 어셈블리어에서도 특정 기능을 하나의 블록으로 묶어서 관리한다.

이번 강의를 들어가기 전에, 우선 함수를 정의하고 호출하기 위한 기본적인 개념들, 예를 들면 함수 호출 규약, 스택 프레임, `call`/`ret` 명령어의 동작 방식 등을 익혀두면 좋다. 

이번 강의에서는 스택에 사용되는 `push`/`pop`, C언어의 함수에 대응되는 프로시저(`call`/`leave`/`ret`), 그리고 운영체제 관점에서 매우 중요한 system call에 대해 공부한다. 

### 함수
---
함수는 프로그램이 처리해야 할 명령어들을 한 덩어리로 묶어 놓은 코드 블록으로, C나 Python 등의 고급 언어에서도 함수를 정의해 쓰는 것처럼, 어셈블리에서도 **라벨(Label)** 로 특정 구역을 표시하고 `call` 명령어 등을 활용해 함수를 사용할 수 있다. 

함수는 서브루틴(Subroutine), 프로시저(Procedure), 함수(Function)라는 용어로 혼용해서 사용하며, 함수를 호출한 함수(Caller)는 `call` 명령어로 함수를 호출해 사용하며, 호출된 함수(Callee)는 실행이 전부 끝나면 `ret` 명령어로 다시 이전 함수에서 실행 중이던 코드로 돌아간다. 

본 강의에서는 다음 내용을 다룬다. 

- 스택과 관련한 어셈블리어 명령어 학습
- 함수와 관련한 어셈블리어 명령어 학습
- 어셈블리어에서 함수가 선언 및 정의되는 과정 학습
- 함수가 호출되고 반환되는 과정을 어셈블리어 레벨에서 학습

#### 스택 관련 명령어
---
> [!example] 스택(Stack)이란?
> 
> 스택은 자료 구조의 한 종류로, **LIFO(Last In First Out)** 방식으로 동작한다. 이를 쉽게 이해하면 쌓여있는 접시를 떠올릴 수 있으며, 새로운 접시는 맨 위에 쌓이고, 꺼낼 때도 맨 위에 있는 접시부터 꺼내야 한다.  

Linux나 Windows 프로세스의 메모리에는 스택 영역이 존재하며, 함수 호출 및 복귀, 인자 전달, 함수의 지역변수 저장 등에 활용된다. 

x86 아키텍처의 스택은 높은 메모리 주소에서 낮은 메모리 주소로 쌓이는 특성이 있어, **데이터를 추가할 때마다 메모리 주소가 감소하며, 데이터를 제거하면 다시 증가한다.**

스택에서의 가장 중요한 요소는 **스택 포인터(Stack Pointer) 레지스터**인 `rsp`로, `rsp`는 스택의 가장 위(Top)를 가리키고 `push`명령어를 실행하면 데이터를 스택에 추가하여 `rsp`가 감소하며, `pop` 명령어를 실행하면 반대로 데이터가 스택에서 나오면서 `rsp`가 감소한다. 

`push val`의 경우, 값 `val`을 스택에 저장하며, 내부적으로 수행되는 연산은 다음과 같다. 

- `rsp -= 8`
- `[rsp] = val`

`pop reg`의 경우, 스택 최상단의 값을 꺼내 `reg` 레지스터에 대입하며, 
내부적으로 다음의 연산이 수행된다.

- `reg = [rsp]`
- `rsp += 8`

#### 함수 호출 및 반환 관련 명령어
---
함수를 사용하면 반복되는 연산을 함수 호출로 대체할 수 있어 전체 코드의 크기를 줄일 수 있으며, 기능별로 코드 조각에 이름을 붙일 수 있어 코드의 가독성을 크게 높일 수 있다. 

함수를 부르는 행위를 **호출(Call)** 이라고 부르며, 반대로 함수에서 돌아오는 행위를 **반환(Return)** 이라고 부른다. 

함수를 호출할 때는 함수를 실행하고 나서 원래의 실행 흐름으로 돌아와야 하기 때문에, `call` 다음의 **명령어 주소(Return Address, 반환 주소)** 를 스택에 저장하고 함수로 `rip`를 이동한다. 

x64 어셈블리어에는 함수의 호출과 반환을 위한 명령어로 `call`, `leave`, `ret` 명령어가 있다. 

**Call**
먼저, 함수를 호출할 때 사용하는 `call` 명령어로, `call addr` 명령어는 다음 연산을 수행한다. 

- `push return_address`: `return_address`는 함수가 끝난 뒤 돌아갈 코드의 주소 값
- `jmp addr`

아래 코드는 `call` 명령어의 예시를 보여 준다. `call 0x401000` 코드를 실행하고 나면 스택 포인터인 `rsp` 위치에 반환 주소인 `0x400005`가 저장되어 있고, `rip` 레지스터가 `0x401000`으로 바뀌어 있는 모습을 확인할 수 있다. 

이 예제 코드를 [[x86 어셈블리 (2)#스택 관련 명령어|push 명령어]]를 참고하면서 천천히 따라가 보면 이해가 잘 될 것이다. 

**예제**
```assembly
[Register]
rip = 0x400000
rsp = 0x7fffffffc400 

[Stack]
0x7fffffffc3f8 | 0x0
0x7fffffffc400 | 0x0 <- rsp

[Code]
0x400000 | call 0x401000  <- rip
0x400005 | mov esi, eax
...
0x401000 | push rbp
```

**결과**
```assembly
[Register]
rip = 0x401000
rsp = 0x7fffffffc3f8

[Stack]
0x7fffffffc3f8 | 0x400005  <- rsp
0x7fffffffc400 | 0x0

[Code]
0x400000 | call 0x401000
0x400005 | mov esi, eax
...
0x401000 | push rbp  <- rip
```


`leave`
다음은 함수가 반환되기 전, **스택 프레임(Stack Frame)** 을 정리하는`leave` 명령어이다. 

>[!example] 스택 프레임이란? 
>
>스택은 함수별로 자신의 지역변수 또는 연산과정에서 부차적으로 생겨나는 임시 값들을 저장하는 영역으로, 만약 이 스택을 여러 함수가 공동으로 사용하게 된다면, 서로 다른 두 함수가 같은 메모리 영역을 사용할 수 있다. 
>
>예를 들어 A라는 함수가 B라는 함수를 호출하는데, 이 둘이 같은 스택 영역을 사용한다면, B에서 A의 지역변수를 모두 오염시킬 수 있다. 이 경우, B가 반환된 뒤 A는 정상적으로 동작하지 않을 수 있다. 
>
>따라서, 함수별로 서로가 사용하는 스택의 영역을 명확하게 구분하기 위해서 **스택 프레임(Stack Frame)** 이라는 단위를 사용한다. 대부분의 Application Binary Interface(ABI)에서는 함수는 호출될 때 자신만의 스택 프레임을 만들고, 반환할 때 이를 정리해 메모리 누수를 방지한다.
> 
>아래 그림은 함수가 호출된 후 스택 프레임이 어떻게 생기고, 반환되는 시점에 어떻게 정리되는지 보여 준다. 
>![[531b95bbc3950a143a7b9cf7977a76a644a6afd005d0385c0233abf963f003f4.gif]]

`leave` 명령어는 단독으로 사용되며, 다음의 연산을 수행한다. 

- `mov rsp, rbp`
- `pop rbp`

아래 코드는 `leave` 명령어의 예시를 보여 주며, `rbp`가, 함수를 호출하기 전의 스택 프레임을 가리키는 것을 확인할 수 있다. 

이 예제 코드 또한 `pop` 명령어의 정의를 참고하며 천천히 공부해 보면 큰 도움이 될 것이다. 

**예제**
```assembly
[Register]
rsp = 0x7fffffffc400
rbp = 0x7fffffffc480

[Stack]
0x7fffffffc400 | 0x0 <- rsp
...
0x7fffffffc480 | 0x7fffffffc500 <- rbp
0x7fffffffc488 | 0x31337 

[Code]
leave
```

**결과**
```assembly
[Register]
rsp = 0x7fffffffc488
rbp = 0x7fffffffc500

[Stack]
0x7fffffffc400 | 0x0
...
0x7fffffffc480 | 0x7fffffffc500
0x7fffffffc488 | 0x31337 <- rsp
...
0x7fffffffc500 | 0x7fffffffc550 <- rbp
```


`ret`
다음은 함수에서 반환하여 원래 코드로 돌아오는 `ret` 명령어로, `pop rip`처럼 `rip` 레지스터의 값을 `return address`로 변경하는 역할을 한다. 

아래 코드는 `ret` 명령어의 예시를 보여 주며, `ret`이 실행되고 나면 `rip`가 반환 주소인 `0x400005`로 돌아가 있는 모습을 확인할 수 있다. 

역시 이 코드 또한 `pop`의 정의를 제대로 알고 있어야 잘 이해할 수 있다. 

**예제**
```assembly
[Register]
rip = 0x401008
rsp = 0x7fffffffc3f8

[Stack]
0x7fffffffc3f8 | 0x400005    <- rsp
0x7fffffffc400 | 0

[Code]
0x400000 | call 0x401000
0x400005 | mov esi, eax
...
0x401000 | mov rbp, rsp  
...
0x401007 | leave
0x401008 | ret  <- rip
```

**결과**
```assembly
[Register]
rip = 0x400005
rsp = 0x7fffffffc400

[Stack]
0x7fffffffc3f8 | 0x400005
0x7fffffffc400 | 0x0    <- rsp

[Code]
0x400000 | call 0x401000
0x400005 | mov esi, eax   <- rip
...
0x401000 | mov rbp, rsp  
...
0x401007 | leave
0x401008 | ret
```


#### 어셈블리어에서의 함수 선언
---
어셈블리어에서 함수를 만들 때는 크게 아래와 같은 단계를 거친다. 

1. **함수 시작 위치를 나타낼 라벨(Label)** 을 정의한다. 
2. 스택 프레임이 필요한 경우, **함수 프롤로그**를 통해 스택 프레임을 구성한다. 
3. 함수 내부에서 실제 동작을 구현한다. 
4. 함수 마지막에 **함수 에필로그**를 통해 스택 프레임을 해제하고, `ret` 명령어로 종료한다. 

아래 예시로, Linux 환경에서 32비트(x86)와 64비트(x64) 각각에 대해 두 정수를 받아 합을 반환하는 함수를 선언해 볼 것이다. 

**x86**
x86에서는 **cdecl** 함수 호출 규약을 통해 함수를 선언한다. 

```assembly
add:
	push ebp
	mov ebp, esp
	mov eax, [ebp + 8]
	add eax, [ebp + 12]
	leave
	ret
```

- 1번째 줄 (`add`라는 라벨 정의)
- 2 ~ 3번째 줄 (함수 프롤로그)
	- 함수 프롤로그를 수행한다. 
- 4 ~ 5번째 줄 (인자 전달)
	- **cdecl 호출 규약에서는 함수의 인자를 차례대로 전달**하기 때문에 `[ebp + 8]`과 `[ebp + 12]`에서 각각 첫 번째 인자와 두 번째 인자를 가져온다. 
	- 그 후 `eax` 레지스터에서 두 인자를 차례대로 더해 두 인자를 더한 값이 반환되도록 한다.
- 6 ~ 7번째 줄 (함수 에필로그)
	- `leave`, `ret` 명령어를 통해서 스택 프레임을 정리한다. 

**x64**
x64에서는 **SYSV** 함수 호출 규약을 통해 함수를 선언한다. 

```assembly
add:
	push rbp
	mov rbp, rsp
	mov rax, rdi
	add rax, rsi
	pop rbp
	ret
```

* 2 ~ 3번째 줄 (함수 프롤로그)
	* 함수 프롤로그를 수행한다. 
* 4 ~ 5번째 줄 (인자 전달)
	* **SYSV 호출 규약에서는 함수 인자를 레지스터로 전달**하기 때문에 `rdi`, `rsi` 레지스터를 통해 전달된 인자를 가져온다. 
	* 그 후 `rax` 레지스터에서 두 인자를 차례대로 더해 두 인자를 더한 값이 반환되도록 한다.
* 6 ~ 7번째 줄 (함수 에필로그)
	* `pop`, `ret` 명령어를 통해서 스택 프레임을 정리한다. 

x64에서 인자는 주로 레지스터로 할당받기 때문에, cdecl처럼 스택에 인자를 따로 두지 않아도 된다. 하지만, 복잡한 지역 변수가 많이 필요한 함수라면 레지스터가 부족할 수 있어 스택에 공간을 더 할당할 수도 있고, 그 경우에도 프롤로그와 에필로그의 구조는 여전히 유효하다. 


#### 함수 호출 과정
---
함수를 선언한 이후에는 실제로 해당 함수를 호출하면서 그 결과를 사용해 봐야 한다. 이 또한 32비트(x86)와 64비트(x64) 환경에서의 호출 방식이 서로 다르므로 나누어서 살펴본다. 

**x86**
32비트 환경에서 cdecl 호출 규약을 사용하는 경우, 함수에 전달할 인자를 **스택**에 `push`한 뒤 `call` 명령어로 함수를 호출하며, 함수의 동작이 끝난 경우 **호출자(Caller)** 측에서 스택 정리를 해 줘야 한다. 

```assembly
section .text
global _start

add:
	push ebp
	mov ebp, esp
	mov eax, [ebp + 8]
	add eax, [ebp + 12]
	leave
	ret
	
_start:
	push dword 20
	push dword 10
	call add
	add esp, 8
	mov ebx, eax
	mov eax, 1
	int 0x80
```

**x64**
64비트 리눅스 환경에서는 **System V AMD64 ABI** 함수 호출 규약을 주로 사용한다. 이 규약에서는 대부분의 정수 인자가 **레지스터**를 통해 전달된다. 

2개의 인자를 가진 경우, 첫 번째 인자는 `rdi`, 두 번째 인자는 `rsi` 레지스터에 들어가게 된다. 

```assembly
section .text
global _start

add:
	push rbp
	mov rbp, rsp
	mov rax, rdi
	add rax, rsi
	pop rbp
	ret
	
_start:
	mov rdi, 10
	mov rsi, 20
	call add
	mov rdi, rax
	mov rax, 60
	syscall
```

함수를 부르기 전, `mov rdi, 10`, `mov rsi, 20`으로 두 개의 인자를 각각 설정한 뒤 `call add`를 사용해 함수를 호출한다. 

함수 내부에서는 `rdi`와 `rsi`를 더한 결과가 `rax`에 담기며, `ret`으로 복귀하면 `_start`로 돌아와 `rax`에 있던 값을 사용할 수 있다. 

`call` 명령어는 현재 명령어 직후의 주소 = **복귀 주소**를 스택에 저장한 뒤, 지정된 라벨로 점프하는 명령어이다. 함수 내부에서 `ret`이 실행되면 스택에 저장해 두었던 복귀 주소를 꺼내서 원래의 위치로 돌아오는 구조이다.

이렇게 함수를 호출할 때마다 콜 스택이 만들어지고, 함수가 반환되면 그 스택도 해제되어 이전의 상태로 복원된다. 

어셈블리어에서도 이렇게 `call`과 `ret`, 그리고 스택과 레지스터를 통해 함수를 구성하고 사용하면, 프로그램을 기능 단위로 깔끔하게 구성할 수 있다. 


### 시스템 콜
---
Windows, Linux, Mac 등의 현대 운영체제는 컴퓨터 자원을 효율적으로 사용하기 위해, 그리고 사용자에게 편리한 경험을 제공하기 위해 내부적으로 매우 복잡한 동작을 수행한다. 운영체제는 연결된 모든 HW, SW에 접근할 수 있으며, 이들을 제어할 수도 있다. 

현대 운영체제는 크게 **사용자 모드(User Mode)** 와 **커널 모드(Kernel Mode)** 로 나뉘어 동작한다. 운영체제가 이러한 방식으로 동작하는 이유는, [[운영체제_2주차_화요일]] 강의에서 학습했던 것처럼, 개별 프로세스가 자원에 직접 접근하게 된다면 프로세스들과의 충돌 등 많은 위험성을 내포하기 때문이다. 

다음 그림은 **리눅스 계층**을 나타낸다. 
![[Pasted image 20251215183655.png]]

**커널 모드**
**커널 모드(Kernel Mode)** 는 운영체제가 전체 시스템을 제어하기 위해 시스템 소프트웨어에 부여하는 권한이다. 커널 모드에서는 모든 메모리 영역에 접근할 수 있고, HW에 직접 접근할 수 있다. 

파일시스템, 입/출력, 네트워크 통신, 메모리 관리 등 모든 저수준 작업은 사용자 모르게 커널 모드에서 진행되기 때문에, 해커가 커널 모드까지 진입하게 되면 시스템은 거의 무방비 상태가 된다. 

**사용자 모드**
**사용자 모드 (User Mode)** 는 운영체제가 사용자에게 부여하는 권한으로, 접근할 수 있는 메모리 영역과 권한이 매우 한정되어 있고, HW에 직접적으로 접근할 수 없다. 

브라우저를 사용해 Dreamhack을 보거나, YouTube를 시청하는 것, 게임을 하고 프로그래밍을 하는 것 등등은 모두 사용자 모드에서 이루어진다. Linux에서 루트 권한으로 사용자를 추가하고, 패키지를 내려 받는 행위 또한 마찬가지이다. 사용자 모드에서는 해킹이 발생해도 해커는 사용자 모드의 권한까지밖에 획득하지 못하기 때문에 해커로부터 커널의 막강한 권한을 보호할 수 있다. 

**시스템 콜**
**시스템 콜(System Call, syscall)** 은 사용자 모드에서 커널 모드의 시스템 소프트웨어에게 어떤 동작을 요청하기 위해 사용한다. SW 대부분은 커널의 도움이 필요하다. 예를 들어, 사용자가 `cat flag`라는 Linux 명령어를 실행하면, *flag*라는 파일을 읽어서 사용자의 터미널 화면에 출력해 줘야 한다. 그런데 *flag*는 파일 시스템 내부에 존재하기 때문에 이를 읽으려면 파일 시스템에 접근하 수 있어야 한다. 이는 커널 모드에서만 가능한 작업이기 때문에 커널이 도움을 줘야 한다. 여기서, 도옴이 필요하다는 요청을 **시스템 콜**이라고 한다. 

사용자 모드의 SW가 필요한 도움을 요청하면, 커널이 요청한 동작을 수행해서 사용자에게 그 결과를 반환한다. 

사용자는 시스템 콜을 통해서 파일 입출력, 프로세스 관리, 메모리 관리 등 핵심 기능에 접근할 수 있다. 예를 들어, C 언어의 파일 입출력 함수인 `read()`와 `write()`는 내부적으로 `read`, `write` 시스템 콜을 사용한다. 

#### 시스템 콜 사용
---
x86 아키텍처와 x64 아키텍처에서 시스템 콜을 사용하는 방법이 조금씩 다르다. 

**x86**
x86에서는 `int 0x80` 명령어를 사용해 시스템 콜을 호출할 수 있다. 이때 `eax` 레지스터에 호출하고자 하는 시스템 콜의 번호를 넣는다. 시스템 콜 번호란 운영체제에서 제공하는 각 기능에 대해서 고유하게 할당된 값으로, 예를 들어 파일을 읽기 위한 `open` 시스템 콜은 5번이 지정되어 있어, `eax`에 이 번호를 저장하면 커널이 `open` 작업을 수행한다는 것을 알 수 있다. 그리고 나머지 인자들은 `ebx`, `ecx`, `edx`, `esi`, `edi`, `ebp` 등 순서대로 전달된다. 그 후, 시스템 콜의 반환값은 `eax` 레지스터에 저장된다. 

`open` 시스템 콜을 호출한다고 가정해 보자. 이 때 `open` 시스템 콜을 호출하기 위한 번호는 5이기 때문에 `eax` 레지스터에 5를 저장하고, `ebx`에는 파일 이름의 주소, `ecx`에는 열기 모드(예를 들어 O_RDONLY), `edx`에는 추가 옵션(필요한 경우)이 저장된다. 

아래 코드는 시스템 콜을 사용해 "dreamhack.txt" 파일을 여는 예시이다. 

```assembly
section .data
	filename db "dreamhack.txt", 0
	buffer   times 100 db 0
	
section .text
	global _start
	
_start:
	mov eax, 5
	mov ebx, filename
	mov ecx, 0
	int 0x80
```

**x64**
x64에서는 `syscall` 명령어를 사용해 시스템 콜을 전달할 수 있다. `rax` 레지스터에 호출하고자 하는 시스템 콜의 번호를 넣고, 나머지 인자들은 `rdi`, `rsi`, `rdx`, `r10`, `r8`, `r9`, 스택 순서로 전달한다. 그 후 시스템 콜의 반환값은 `rax` 레지스터에 저장된다. 

위 x86 예시에서 수행하는 동작을 x64로 옮기면 아래 코드와 같다. 

```assembly
section .data
	filename db "dreamhack.txt" 0
	buffer   times 100 db 0
	
section .text
	global _start
	
_start:
	mov rax, 2
	lea rdi, [filename]
	mov rsi, 0
	xor rdx, rdx
	syscall
```

다른 예제로 `syscall` 명령어를 실행하기 직전의 예시 레지스터와 메모리 상태를 나타낸 것과, 실행한 후 결과를 해석해 보면 다음과 같다.

**예제**
```assembly
[Register]
rax = 0x01
rdi = 0x01
rsi = 0x401000
rdx = 0x0b

[Memory]
0x401000 | "Hello Wo"
0x401008 | "rld"

[Code]
syscall
```

**결과**
```
Hello World
```

**해석**
아래의 **x64 시스템 콜 테이블**을 보면, `rax = 0x01`일 때, 커널에 `write` 시스템 콜을 요청한다. 이때 인자를 담는 레지스터인 `rdi`, `rsi`, `rdx`가 각각 `0x01`, `0x401000`, `0x0b`이므로 커널은 `write(0x01, 0x401000, 0x0b)`를 수행한다. 

`write` 시스템 콜의 인자는 각각 순서대로 출력 스트림, 출력 버퍼, 출력 길이를 나타낸다. 여기서 `0x01`은 stdout이며, 이는 일반적으로 표준 출력을 의미한다. `0x401000`은 `Hello World`라는 문자열이 저장된 메모리의 주소 값이고, 출력 길이는 `0x0b`로 지정되어 있으므로, 터미널 화면에 `"Hello World"`를 출력할 것이다. 

#### x64 시스템 콜 테이블
아래는 시스템 콜 테이블의 일부로, 총 개수가 300개에 달하고, Google에 `system call table list`와 같은 검색어로 검색하면 쉽게 찾을 수 있으므로 굳이 외울 필요는 없다. 앞으로 시스템 콜을 계속 접하다 보면 자연스럽게 몇 가지 중요한 시스템 콜은 익숙해질 것이다. 

| syscall  | rax    | arg0 (rdi)           | arg1 (rsi)               | arg2 (rdx)                |
| -------- | ------ | -------------------- | ------------------------ | ------------------------- |
| read     | `0x00` | unsigned int fd      | char *buf                | size_t count              |
| write    | `0x01` | unsigned int fd      | const char *buf          | size_t count              |
| open     | `0x02` | const char *filename | int flags                | umode_t mode              |
| close    | `0x03` | unsigned int fd      |                          |                           |
| mprotect | `0x0a` | unsigned long start  | size_t len               | unsigned long prot        |
| connect  | `0x2a` | int sockfd           | struct sockaddr *addr    | int addrlen               |
| execve   | `0x3b` | const char *filename | const char \*const *argv | const char \*const \*envp |

### 강의 요약
---
1. 스택
	* `push val`: `rsp`를 8만큼 빼고, 스택 최상단에 `val`을 넣는다. 
	* `pop reg`: 스택 최상단의 값을 `reg` 레지스터에 넣고, `rsp`를 8만큼 더한다. 
2. 함수
	- `call addr`: `addr`의 프로시저를 호출한다. 
	- `leave`: 스택 프레임을 정리한다.
	- `ret`: 호출자의 스택 프레임으로 되돌아간다. 
3. 시스템 콜
	- `syscall`: 커널에게 필요한 동작을 요청한다. 