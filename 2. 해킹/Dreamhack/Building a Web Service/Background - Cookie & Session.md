## 들어가며
---
### 서론
---
현대의 웹 서비스는 대부분 로그인을 통해 마이페이지, 유료 서비스 등 개인만의 서비스를 제공한다. 웹 서버는 수많은 클라이언트와 HTTP 프로토콜을 사용해 통신한다. 이는 곧 게스트 계정으로 로그인 했다면 손님이 이용할 수 있는 서비스를 제공하고, 관리자 계정으로 로그인 했다면 데이터베이스 관리, 고객 정보 관리 등의 관리자만이 접근할 수 있는 페이지를 제공해야 한다. 

그렇다면 웹 서버는 수많은 클라이언트를 어떻게 구별해 서로 다른 결과를 반환할까? HTTP 프로토콜로 웹 서버와 통신할 때는 웹 서버에 명령을 내리기 위해 GET, POST 등의 메소드와 자원의 위치를 가리키는 URL 등이 포함되어 있다.

이외에도 **헤더(Header)** 를 통해 웹 서버에게 요청을 보내고, 웹 서버는 헤더를 읽어 클라이언트에게 결과 값을 반환한다. 이때, 헤더에는 클라이언트의 정보와 클라이언트의 요청을 구체화하는 데이터 등이 포함되는데, 이 때 클라이언트의 인증 정보 또한 포함될 수 있다. 

이번 강의에서는 클라이언트의 인증 정보를 포함하고 있는 **Cookie**와 **Session**에 대해 알아본다. 


## 쿠키
---
### 쿠키
---
HTTP 프로토콜의 **Connectionless**, **Stateless** 특징과 클라이언트의 IP 주소 / User-Agent는 매번 변경될 수 있다는 특징이 합쳐져, 웹 서버는 특정 클라이언트만 따로 기억할 수 없다. 

>[!example] HTTP 프로토콜의 특징
>- **Connectionless**: <u>하나의 요청에 하나의 응답을 한 후 연결을 종료하는 것</u>을 의미한다. 즉, 특정 요청에 대한 연결은 이후의 연결과 이어지지 않고, 새로운 요청이 있을 때마다 그때그때 새로운 연결을 맺는다. 
>- **Stateless**: <u>통신이 끝난 뒤, 상태 정보를 저장하지 않는 것</u>을 의미한다. 즉, 이전 연결에서 사용한 데이터를 동일 사용자와의 다른 연결에서 사용하지 않는다.

Connectionless, Stateless 특징을 가지는 HTTP 프로토콜에서 연결 상태를 유지하기 위해서 **쿠키(Cookie)** 라는 개념이 탄생했다. <u>쿠키는 key와 value로 이뤄진 일종의 단위</u>로, 서버가 클라이언트에게 쿠키를 발급하면, 클라이언트는 서버에 요청을 보낼 때마다 쿠키를 같이 전송한다. 그러면, 서버는 클라이언트의 요청에 포함된 쿠키를 보고 해당 클라이언트가 누구인지 구분할 수 있다. 


### 용도
---
일반적으로 쿠키는 클라이언트의 정보 기록과 상태 정보를 표현하는 목적으로 사용한다. 

#### 정보 기록
웹 서비스 사용 시 종종 등장하는 팝업 창에 쿠키와 관련한 것을 본 기억이 있을 것이다(예: "다시 보지 않기", "$n$일간 표시하지 않기" 등). 웹 서버는 각각의 클라이언트의 팝업 옵션을 기억하기 위해 쿠키에 해당 정보를 기록하고, 쿠키를 통해서 팝업 창 표시 여부를 판단한다. 

과거에는 클라이언트의 정보를 저장하기 위해 쿠키가 종종 사용되었으나, 클라이언트가 서버와 통신할 때마다 쿠키를 전송해야 해서 리소스 낭비가 발생할 수 있어 최근에는 이러한 단점을 보완한 Modern Storage APIs를 통해 데이터를 저장하는 방식을 권장하고 있다. 

#### 상태 정보
많은 웹 사이트에서는 회원 가입과 로그인을 통해 개개인에게 맞춤형 서비스를 제공한다. 이때 웹 서버에서는 수많은 클라이언트의 로그인 상태와 사용자를 구별해야 하는데, 이 때 클라이언트를 식별할 수 있는 특정 값을 쿠키에 저장해서 사용한다. 


### 쿠키 유무에 따른 통신
---
#### 쿠키가 없는 통신
다음은 앞서 설명한 HTTP 통신의 특징을 간소화해서 표현한 그림이다. 서버는 요청을 보낸 클라이언트가 누구인지 알 수 없기 때문에 현재 어떤 클라이언트와 통신하고 있는지 알 수 없다. 

![[Pasted image 20260102214237.png]]

#### 쿠키가 있는 통신
다음은 쿠키를 사용한 HTTP 통신을 표현한 그림이다. 클라이언트는 서버에 요청을 보낼 때마다 쿠키를 포함해서 Request를 전송하고, 서버는 해당 쿠키를 통해 클라이언트를 구분한다. 

![[Pasted image 20260102214415.png]]


### 쿠키 변조
---
![[Pasted image 20260102214704.png]]
위의 인벤 사이트를 생각해 보자. 쿠키는 클라이언트의 브라우저에 저장되어 Request에 포함되는 정보이다. 만약 해당 인벤 유저가 해당 정보를 더 이상 공개하고 싶지 않아 비공개로 돌려서 자신만 보고 싶을 때, 쿠키에는 비공개/공개 유무 관련 정보가 저장될 것이다. 

이 때, 디시의 어떤 유저가 해당 정보가 너무 궁금해서 쿠키 정보를 해당 인벤 유저의 것으로 변조해 서버에 보내면, 서버가 별다른 검증 없이 쿠키를 통해 사용자의 인증 정보를 식별할 경우, 디시 유저는 해당 인벤 유저의 수치스러운 정보를 맘대로 보고 박제할 수 있게 된다. 

![[Pasted image 20260102215125.png]]


## 세션
---
### 세션
---
앞서 언급한 인벤 유저 문제에서, 해당 문제가 발생한 근본적인 원인은 ~~잘못된 프사가 아닌~~ 클라이언트가 쿠키를 가지고 있다는 점에서 시작한다. 이 사실을 알게 된 인벤 운영자는 쿠키에 인증 상태를 저장하지만, 클라이언트 자체적으로는 인증 정보를 변조할 수 없게 하기 위해 **세션(Session)** 을 사용한다. 

세션은 인증 정보를 서버에 저장하고, 해당 데이터에 접근할 수 있는 **키(유추할 수 없는 랜덤한 문자열)** 를 만들어 클라이언트에 전달하는 방식으로 작동한다. 이 키를 일반적으로 **Session ID**라 하며, 브라우저는 해당 키를 쿠키에 저장하고 이후에 HTTP 요청을 보낼 때 사용하며, 서버는 요청에 포함된 Session ID에 해당하는 데이터를 가져와 인증 상태를 확인한다. 

![[Pasted image 20260102215820.png]]

이렇게 함으로, 디시 유저는 쿠키에 적인 Session ID는 조작할 수 있지만, 실제 인증 정보는 조작할 수 없게 되어 인벤 사이트에 있는 비공개 정보를 열람할 수 없게 된다.

![[Pasted image 20260102220002.png]]


## 쿠키 및 세션 실습 (Cookie & Session Lab)
---
브라우저를 활용한 실습에 들어가기 전에, 앞서 배운 개념을 Dreamhack의 Lab 환경을 이용해 복습해 보고 적용해 보자. 아래 하이퍼링크를 눌러 Lab 실습 환경을 열면 된다. 

[Lab으로 가기](https://learn.dreamhack.io/labs/97ce093a-40de-420c-88f4-fef19616bf04)

### 쿠키 적용법
---
앞서서 Cookie와 Session의 개념에 대해 배웠고, 바로 위에서는 Lab 환경에서 실습을 진행해 보았다. 이제 쿠키의 특징과 함께 쿠키를 실제로 웹 페이지에서 적용할 수 있는 방법에 대해 알아본다. 

쿠키는 클라이언트에 저장되기 때문에 클라이언트는 저장된 쿠키를 조회, 수정, 추가할 수 있다. 클라이언트가 서버에 Request를 보낼 때, 저장된 쿠키를 Request header에 넣어 전송하기 때문에, 사용자가 요청을 보낼 때 Cookie header를 변조할 수 있다. Cookie를 설정할 때는 만료 시간을 지정할 수 있고, 만료 시간 이후에는 클라이언트에서 쿠키가 삭제된다. 이때 쿠키의 만료는 클라이언트의 브라우저에서 담당한다. 

쿠키는 서버와 클라이언트 양 쪽 모두 설정할 수 있으며, 설정하는 방법은 아래와 같다. 클라이언트에서 쿠키를 다루는 방법은 사진을 통해 더 자세히 설명하도록 한다. 

#### 쿠키 설정

**서버**
HTTP 응답 중 Header에 쿠키 설정 헤더(Set-Cookie)를 추가하면 클라이언트의 브라우저가 쿠키를 설정한다. 

```
HTTP/1.1 200 OK
Server: Apache/2.4.29 (Ubuntu)
Set-Cookie: name=test;
Set-Cookie: age=30; Expires=Fri, 30 Sep 2022 14:54:50 GMT;
...
```

**클라이언트**
Javascript를 사용해 쿠키를 설정한다. 

```
document.cookie = "name=test;"
document.cookie = "age=30; Expires=Fri, 30 Sep 2022 14:54:50 GMT;"
```

#### 쿠키 열람

**Chrome Console 활용**
Chrome 페이지에서 우클릭했을 때 표시되는 `검사` 버튼을 누른 후 `Console` 탭을 눌러 `document.cookie`를 입력하면 쿠키 정보를 확인할 수 있다. 

**쿠키 옵션(HttpOnly)에 따라 Javascript에서 쿠키 확인이 불가능할 수도 있다**.

![[Pasted image 20260102225312.png]]

**Chrome Application 활용**
Chrome 페이지에서 우클릭했을 때 표시되는 `검사` 버튼을 누른 후 `Application` 탭의 좌측 목록에 있는 `Cookies`를 펼치면 Origin 목록을 확인할 수 있다. Origin을 누르면 설정된 쿠키 정보를 확인 및 수정할 수 있다. 

![[Pasted image 20260102225642.png]]


### 연습: Dreamhack Session
---
Dreamhack 로그인 기능을 통해 세션을 알려주겠다. 순서대로 따라가기만 하면 된다. 

![[Pasted image 20260102225902.png|300]]

1. [Dreamhack 로그인 페이지](https://dreamhack.io/users/login)에서 우클릭 후 검사를 실행하고 Network 탭을 누른다. `Preserve log`를 체크하고 로그인을 하면 로그인 성공 시 응답을 볼 수 있다. 응답을 살펴보면, 서버에서 `set-cookie` 헤더를 통해 브라우저의 쿠키에 세션 정보를 저장한다. 
	![[Pasted image 20260102230903.png]]
2.  Chrome 검사에서 `Application`을 누르고 `Cookies` 목록 안의 https://dreamhack.io/ 를 누르면 서버의 `set-cookie` 헤더를 통해 설정된 쿠키를 확인할 수 있다. 
	![[Pasted image 20260102230915.png]]
3. `sessionid` 헤더의 값을 메모장에 복사한 후, 사진과 같이 `sessionid` 헤더의 값을 우클릭 한 후 `Delete`를 클릭하면, 브라우저의 쿠키에 저장된 세션 값이 삭제된다. 세션 값을 삭제하고 브라우저를 새로고침하면 로그인이 해제되어 있는 것을 확인할 수 있다. 
	![[Pasted image 20260102230845.png]]
4. 쿠키의 빈 칸을 더블클릭해 `sessionid` 헤더를 추가하고, 이전에 복사해 놨던 세션 값을 거기에 입력하면 브라우저의 쿠키에 세션 값이 저장된다. 이렇게 하고 Dreamhack 페이지를 새로고침하면 다시 로그인이 되는 것을 확인할 수 있다. 
	![[Pasted image 20260102230928.png]]

쿠키에는 사용자의 세션 정보가 저장되어 있고, 서버는 이를 통해 사용자를 식별하고 인증을 처리한다. 공격자가 해당 쿠키를 훔칠 수 있다면, 세션에 해당하는 사용자의 인증 상태 또한 훔칠 수 있는데, 이를 **세션 하이재킹(Session Hijacking)** 이라고 한다. 
