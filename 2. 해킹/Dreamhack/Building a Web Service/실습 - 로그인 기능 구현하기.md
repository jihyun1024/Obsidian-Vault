## 들어가며
---
웹 사이트에서 로그인이나 회원가입을 하는 과정을 잘 이해하면 웹이 작동하는 원리에 대해서도 한층 더 깊이 이해할 수 있다. 

사용자가 웹 페이지 상에서 아이디와 비밀번호를 입력하면 웹 서버에 전달된다. 서버는 **전달받은 아이디와 비밀번호를 검증**해서 <u>올바르다면 로그인 성공 페이지를, 올바르지 않다면 로그인 실패 페이지를</u> 사용자에게 반환한다. 여기서 ID와 PW를 검증하는 과정의 원리를 잘 생각해 보자. 

바로 **데이터베이스**로, <u>웹 서버는 전달받은 아이디와 패스워드에 해당하는 계정이 존재하는지 데이터베이스를 찾아본다</u>. 그러면, 데이터베이스는 해당 계정 정보가 있으면 있다고 답하고, 없다면 없다고 답한다. 그 뒤, 웹 서버는 전달받은 답을 듣고 브라우저에게 로그인 성공 페이지 또는 로그인 실패 페이지를 반환하는 것이 검증의 실제 원리이다. 

![[Pasted image 20260113032318.png]]

여기서 끝이 아니라, 사용자가 웹 사이트의 다른 페이지로 이동해도 로그인 상태가 유지되도록 만들어 줘야 하는데, 이 역할을 하는 것이 바로 **세션(Session)** 으로, 이번 강의에서는 앞서 설명한 로그인 과정을 직접 구현해 보며 그 원리를 깊이 이해하도록 한다. 

- 아이디와 비밀번호 입력 처리
- 로그인 상태 유지 기술(세션) 적용
- 데이터베이스 적용

직접 손으로 한 단계씩 구현하며 로그인 시스템의 동작 원리를 익히고, 이를 넘어 웹의 작동 원리에 대해서도 한층 깊이 이해할 수 있을 것이다. 


## 기본적인 로그인 기능 만들어보기
---
로그인이란 사용자가 제공한 정보를 바탕으로 이 사용자가 정말로 서버에 등록된 사용자가 맞는지 검증하는 과정으로, 로그인 기능을 구현할 때 고려해야 할 점들은 다음과 같다. 

 - 로그인 페이지에는 **아이디와 비밀번호를 입력할 수 있는 칸이 존재**해야 한다.
 - **로그인 버튼**이 필요하다. 
 - 사용자가 로그인을 시도하면 서버는 사용자가 전달한 ID와 PW를 검증해서 확인해야 한다.
	 - 등록된 사용자가 맞다면, 로그인 성공 페이지를 반환한다. 
	 - 등록된 사용자가 아니라면, 로그인 실패 페이지를 반환한다.


### 웹 서비스 구상하기
---
웹 서비스를 구상하기에 앞서, 우리가 앞으로 만들 웹 서비스에 어떤 엔드포인트(예: `GET /login`, `GET /`)를 넣을지 생각해 보고, 각 엔드포인트가 수행할 기능과 논리적인 흐름을 생각해 보는 과정이 필요하다. 또한, 각 엔드포인트가 반환할 HTML 문서와 그 역할에 대해서도 생각해야 한다. 

**엔드포인트 구상**
먼저, 다음 4개의 엔드포인트를 지원하도록 만들 것이다. 

- `GET /login` - 로그인을 시도할 수 있는 웹 페이지를 반환
- `POST /login` - 로그인 시도를 처리함
- `GET /login_success` - 로그인 성공 시 해당 페이지로 이동
- `GET /login_failure` - 로그인 실패 시 해당 페이지로 이동

다음은 각 엔드포인트가 어떤 기능과 논리 흐름을 수행할지 생각해 보도록 하자. 

**`GET /login` 엔드포인트**
사용자가 웹사이트의 `GET /login` 엔드포인트에 접근하면 아이디와 비밀번호로 로그인을 시도할 수 있는 웹 페이지를 반환하며, 해당 파일의 이름은 *login.html*로 한다. 

**`POST /login` 엔드포인트**
사용자가 `GET /login`에서 아이디와 비밀번호를 입력하고 로그인 버튼을 누르면 해당 데이터를 POST 메서드로 전달받아 처리하는 역할을 맡는다. 

이때 `<form>` 태그를 통해 아이디와 비밀번호를 POST 데이터로 전달 받아 올바른 계정 정보인지 검증하며, 만약 계정 정보가 올바르다면 `GET /login_success`로, 올바르지 않다면 `GET /login_failure`로 **리다이렉션**시킨다. 

또한, 해당 엔드포인트는 로그인 과정을 처리하고 리다이렉트만 시킬 뿐 따로 직접 반환하는 HTML 문서는 없도록 만들 것이다. 

>[!example] 리다이렉션이란?
>웹에서 **리다이렉션(Redirection)** 이란, 서버가 사용자에게 다른 URL로 이동하도록 명령하는 작업을 말한다. 브라우저가 서버로부터 "이 URL로 이동해"라는 명령을 받으면 브라우저는 명령받은 URL로 자동으로 이동한다. 
>
>앞에서 설명한  만약 계정 정보가 올바르다면 `GET /login_success`로, 올바르지 않다면 `GET /login_failure`로 리다이렉션"을 해석해 보면 다음과 같다. 
>
>- `POST /login`에서 아이디와 비밀번호를 검증한 결과 올바른 계정 정보이면, **사용자의 브라우저를 `GET /login_success` 로 이동시키도록 명령**한다는 뜻이다.
>- `POST /login`에서 아이디와 비밀번호를 검증한 결과 올바르지 않은 계정 정보이면, **사용자의 브라우저를 `GET /login_failure`로 이동시키도록 명령**한다는 뜻이다.

**`GET /login_success` 엔드포인트**
로그인에 성공할 때 이동하는 엔드포인트로, `Login Successful`이라는 문구를 출력하는 웹 페이지를 반환하며, 해당 웹 페이지 문서의 이름은 *login_success.html*로 한다. 

**`GET /login_failure` 엔드포인트**
로그인에 실패할 때 이동하는 엔드포인트로, `Login_Failed`라는 문구를 출력하는 웹 페이지를 반환하며, 해당 웹 페이지 문서의 이름은 *login_failure*로 한다. 

**HTML 문서 구상**
앞서 엔드포인트를 구상해 보면서 다음의 HTML 문서들이 필요하다는 것을 알 수 있다. 

- *login.html*
- *login_success.html*
- *login_failure.html*

각 HTML 문서에서 필요한 점들도 같이 구체화 해 보자. 

***login.html***
아이디와 비밀번호로 로그인할 수 있는 웹 페이지로, 아이디와 비밀번호를 입력할 수 있는 입력 폼과 로그인 버튼이 필요하다. 로그인 버튼을 누르면 아이디와 비밀번호를 `POST /login`으로 전달해야 한다. 

***login_success.html, login_failure.html***
로그인 성공/실패 시 보여지는 웹 페이지로, `Login Successful`과 `Login Failed`란 문구를 각각 출력해야 한다. 


### HTML 문서 제작하기
---
먼저 로그인 웹 페이지에 해당하는 HTML 문서 세 개를 만들며, 만들면서 고려해야 하는 점들을 생각해 보고, 그에 따라 구현해 보면 된다. 각각은 다음과 같이 작성할 수 있다. 

***login.html***
```html
<!DOCTYPE html>
<html>
	<head>
		<title>Flask Simple Login</title>
	</head>
	<body>
		<h2>Login</h2>
		<form action="/login" method="POST">
			Username:<br>
			<input type="text" id="username" name="usename">
			<br><br>
			Password:<br>
			<input type="password" id="password" name="password">
			<br><br>
			<button>Login</button>
		</form>
	</body>
</html>
```

***login_success.html***
```html
<!DOCTYPE html>
<html>
	<head>
		<title>Flask Simple Login</title>
	</head>
	<body>
		<h2>Login Successful</h2>
	</body>
</html>
```

***login_failure.html***
```html
<!DOCTYPE html>
<html>
	<head>
		<title>Flask Simple Login</title>
	</head>
	<body>
		<h2>Login Failed</h2>
	</body>
</html>
```


### Flask 서버 코드 작성하기
---
뼈대가 되는 HTML 코드를 만들었으니, 이제 위에서 언급했던 4개의 엔드포인트를 Flask를 써서 구현해보도록 하자. 

해당 Flask 서버 코드인 *app.py*는 다음과 같다. 

```python
from flask import Flask, render_template, redirect, request, url_for

app = Flask(__name__)


accounts = {
	'admin': 'qwe123',
	'guest': 'guest',
	'test': 'test',
}


@app.route('/login', methods=['GET'])
def get_login():
	return render_template('login.html')


@app.route('/login', methods=['POST'])
def post_login():
	username = request.form.get('username')
	password = request.form.get('password')
	if username in accounts and accounts[username] == password:
		return redirect(url_for('get_login_success'))
	else:
		return redirect(url_for('get_login_failure'))


@app.route('/login_success')
def get_login_success():
	return render_template('login_success.html')


@app.route('/login_failure')
def get_login_failure():
	return render_template('login_failure.html')


if __name__ == '__main__':
	app.run(host='0.0.0.0', port=31337)
```

이때, `return redirect(url_for('get_login_success'))`는 `함수명`에 해당하는 URL 경로를 반환하는 `url_for('함수명')` 함수와 `경로명`으로의 리다이렉트를 명령하는 `redirect('경로명')` 함수가 합쳐진 구문이다. 

이에 따라 차근차근 해석해 보면,

- `url_for('get_login_success')`는 `get_login_success()`
  에 해당하는 경로인 `/login_success`를 반환한다. 
- 따라서, `return redirect(url_for('get_login_success'))`
  는 `/login_success`로 리다이렉트하라는 명령을 사용자에게 내리는 의미로 해석할 수 있다.


## 세션이 적용된 로그인 기능 만들어보기
---
앞에서 구현했던 웹 서버의 가장 큰 문제는 **로그인 상태가 유지되지 않는다**는 점으로, 로그인에 성공하면 `/login_success` 경로로 리다이렉트되는데, 이 상태에서 다른 페이지로 이동할 경우, 사용자의 인증 상태를 웹 서버가 기억하지 않는다. 

이 문제를 해결하기 위해 세션(Session)을 사용할 수 있다. 이 강의는 세션의 개념을 어느 정도 알고 있다고 가정하는 상태에서 진행하기 때문에, 이 문서를 보다가 세션이 기억나지 않는다면 [[Background - Cookie & Session]] 문서에 들어가서 복습하고 오자.

세션을 사용하면 서버가 사용자의 로그인 정보를 관리하고, <u>사용자가 다른 페이지로 이동하거나 새로고침을 해도 서버가 해당 사용자의 인증 정보를 기억하고 있어</u> 인증 상태를 유지할 수 있다.


### 세션을 적용한 Flask 웹 서버 코드
---
바로 위에서 작성한 *app.py*에 몇 가지를 덧붙여서 세션을 적용해보도록 한다. 세션을 사용해 어떤 것을 구현할지는 자유롭지만, 여기서는 사용자가 로그인에 성공하면 세션 데이터에 `'username'`이라는 키에 사용자의 아이디를 넣도록 수정할 것이다. 그러면 나중에 세션 데이터에 `'username'`이라는 키카 존재하는지 여부를 체크해 로그인이 되어 있는지를 알 수 있다. 

수정된 *app.py* 코드는 다음과 같다. 

```python
from flask import Flask, render_template, redirect, request, session, url_for
import os

app = Flask(__name__)
app.secret_key = os.urandom(32)


accounts = {
	'admin': 'qwe123',
	'guest': 'guest',
	'test': 'test',
}


@app.route('/login', methods=['GET'])
def get_login():
	if 'username' in session:
		return redirect(url_for('get_login_success'))
	return render_template('login.html')


@app.route('/login', methods=['POST'])
def post_login():
	if 'username' in session:
		return redirect(url_for('get_login_success'))
		
	username = request.form.get('username')
	password = request.form.get('password')
	if username in accounts and accounts[username] == password:
		session['username'] = username
		return redirect(url_for('get_login_success'))
	else:
		return redirect(url_for('get_login_failure'))


@app.route('/login_success')
def get_login_success():
	if 'username' not in session:
		return redirect(url_for('get_login'))
	return render_template('login_success.html')


@app.route('/login_failure')
def get_login_failure():
	if 'username' in session:
		return redirect(url_for('get_login_success'))
	return render_template('login_failure.html')


if __name__ == '__main__':
	app.run(host='0.0.0.0', port=31337)
```

변경된 사항들을 하나씩 알아보자. 

**모듈 import 부분**
변경 사항을 확인하면 `session`이라는 인스턴스를 추가로 불러오게 했다. `session` 인스턴스를 불러오면 Flask의 세션 기능을 사용할 수 있으며, `os` 인스턴스는 `os.urandom()` 이라는 랜덤한 문자열을 생성하는 함수를 사용하기 위해 불러온 것이다.

```python
from flask import Flask, redirect, render_template, request, session, url_for
import os
 ...
```

**`app.secret_key` 설정**
`app` 객체의 `secret_key`를 무작위의 32 바이트 값으로 설정하는 코드로, 세션은 내부적으로 세션 내에 저장된 데이터의 무결성을 보장하기 위해 암호학적 비밀키가 필요한데, 그 비밀키가 바로 `app.secret_key`이다. `app.secret_key`가 쓰이는 원리를 자세히 설명하지는 않을 것이지만, `app.secret_key`를 설정하지 않으면 <u>세션과 관련된 기능이 제대로 작동하지 않거나 보안 문제가 발생할 수 있다는 점은 반드시 이해하고 넘어가야 한다.</u>

```python
 ...
app = Flask(__name__)
app.secret_key = os.urandom(32)
 ...
```

**`POST /login` 엔드포인트 코드**
```python
 ...
@app.route('/login', methods=['POST'])
def post_login():
    if 'username' in session:
	    return redirect(url_for('get_login_success'))

    username = request.form.get('username')
    password = request.form.get('password')
    if username in accounts and accounts[username] == password:
	    session['username'] = username
        return redirect(url_for('get_login_success'))
    else:
        return redirect(url_for('get_login_failure'))
 ...
```

이 코드는 `username`과 `password`를 전달받아 로그인을 처리하는 `POST /login` 엔드포인트에 해당하는 코드이다. 

이 코드에서 10번 줄을 자세히 살펴보면, 사용자가 전달한 `username`과 `password`가 올바르면 `session['username']`에 `username`을 대입한다. 

웹 서버의 `session`은 단순히 하나의 변수처럼 보이지만, Flask는 내부적으로 세션 ID를 사용해 각 사용자의 데이터를 분리해서 관리하도록 되어 있다. 웹 서버는 사용자로부터 받은 세션 ID를 통해 해당 사용자의 세션 데이터를 찾아내서 <u>여러 사용자가 동시에 웹 서버를 사용하더라도 session 이라는 변수에 담긴 데이터는 사용자별로 관리된다.</u> 

4번 줄의 코드는 뒤의 코드에서도 추가되는 내용으로, 해당 엔드포인트에 접근했을 때 이미 `'username'`이라는 키가 사용자의 세션 데이터인 `session`에 존재한다면, 이미 로그인에 성공한 것으로 간주하고 `get_login_success()`에 해당하는 경로로 리다이렉트시킨다.


## DB가 적용된 로그인 기능 만들어보기
---
앞서 Flask로 구현한 로그인 기능에도 문제점이 있는데, 지금은 웹 사이트가 가지고 있는 계정 정보가 `admin`, `guest`, `test` 이렇게 세 개밖에 되지 않아 [Python의 딕셔너리](https://docs.python.org/3/tutorial/datastructures.html#dictionaries) 기능만 가지고도 해결이 가능했는데, 저장해야 할 데이터의 양이 많아지고 데이터의 구조가 복잡해지면 딕셔너리로는 관리가 어렵다. 

이런 상황에서는 **데이터베이스(DataBase, DB)** 를 사용하는 게 더 적합하며, 이유는 다음과 같다.

**데이터의 휘발성**
딕셔너리는 Python 프로세스의 메모리에 저장되므로, 새롭게 저장된 데이터는 프로그램이 종료되면 전부 삭제되어 나중에 조회할 수 없다. 이는 계정 정보처럼 영구적으로 저장해야 하는 데이터에는 적합한 방식이 아니다. 

**데이터 처리의 복잡성**
데이터가 많아지거나 구조가 복잡해지면 딕셔너리로는 정렬, 검색, 필터링 등의 작업을 수행하기 매우 복잡해진다.

**이식성 부족**
딕셔너리의 내용을 텍스트 파일로 만들어서 그 파일에 적절하게 데이터를 기록하고 읽어들이는 방식으로 계정 정보를 기록하는 방법을 떠올릴 수 있으나, 이 방식은 데이터가 많아질수록 원하는 내용을 효율적으로 찾거나 저장하기 어렵고, 나중에 계정 정보를 다른 시스템에서 사용해야 할 때 파일에 데이터가 저장된 방식을 이해하고 이에 맞춰야 하므로 이식성이 떨어진다.


### SQLite
---
이번 시간에는 데이터베이스 중 하나인 SQLite를 *app.py* 파일에 적용해 보고 회원가입 기능도 구현해보는 실습을 진행한다. 

데이터베이스를 적용한다는 것이 어렵게 느껴질 수 있지만, 단순히 SQLite 프로그램을 설치하고, *app.py*에서 계정 정보에 접근하는 부분을 딕셔너리 대신 데이터베이스에서 가져오도록 변경하는 작업일 뿐이다. 

**DB Browser for SQLite 설치하기**
[공식 홈페이지의 다운로드 페이지](https://sqlitebrowser.org/dl/)에 접속해서 프로그램을 다운로드하며, 홈페이지에 접속하면 아래 화면과 같은 페이지가 나오는데 사용 중인 운영체제에 맞게 프로그램을 다운로드하면 된다.

![[Pasted image 20260113060805.png]]
강의에서 기준으로 하는 Ubuntu 22.04 Linux 64-bit 환경에서는 다음 명령어를 터미널에서 실행해서 설치할 수도 있다. 

```shell
$ sudo apt-get update -y
$ sudo apt-get install sqlitebrowser -y
```

**Python의 SQLite 모듈**
일반적으로 데이터베이스를 Python에서 사용하려면 데이터베이스를 쉽게 사용하도록 도와주는 모듈을 설치해야 한다. 하지만 SQLite의 경우, Python에 기본으로 `sqlite3` 모듈이 존재하기 때문에 별도로 설치할 필요 없이 바로 `import`해서 사용하면 된다.


### DB를 적용한 Flask 웹 서버 코드
---
수정된 *app.py* 코드는 다음과 같다. 

```python
from flask import Flask, redirect, render_template, request, session, url_for
import os
import sqlite3

app = Flask(__name__)
app.secret_key = os.urandom(32)


def init_db():
    conn = sqlite3.connect('accounts.db')
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS accounts (
            id          INTEGER PRIMARY KEY AUTOINCREMENT,
            username    TEXT UNIQUE NOT NULL,
            password    TEXT NOT NULL
        )
    ''')
    conn.commit()
    conn.close()


def check_account(username, password):
    conn = sqlite3.connect('accounts.db')
    cursor = conn.cursor()
    cursor.execute('SELECT * FROM accounts WHERE username = ? AND password = ?',
                   (username, password))
    user = cursor.fetchone()
    conn.close()
    return user


@app.route('/login', methods=['GET'])
def get_login():
    if 'username' in session:
        return redirect(url_for('get_login_success'))
    return render_template('login.html')


@app.route('/login', methods=['POST'])
def post_login():
    if 'username' in session:
        return redirect(url_for('get_login_success'))

    username = request.form.get('username')
    password = request.form.get('password')
    if check_account(username, password):
        session['username'] = username
        return redirect(url_for('get_login_success'))
    else:
        return redirect(url_for('get_login_failure'))


@app.route('/login_success')
def get_login_success():
    if 'username' not in session:
        return redirect(url_for('get_login'))
    return render_template('login_success.html')


@app.route('/login_failure')
def get_login_failure():
    if 'username' in session:
        return redirect(url_for('get_login_success'))
    return render_template('login_failure.html')


if __name__ == '__main__':
    init_db()
    app.run(host='0.0.0.0', port=31337)
```

**`init_db()` 추가 - 데이터베이스 초기화 함수**
코드를 설명할 것이지만, 데이터베이스를 처음 접하거나 익숙하지 않다면 다소 어려울 수 있으니, "대략적으로 이런 기능을 하는구나"정도만 파악하고 넘어가도 된다.

```python
...
def init_db():
    conn = sqlite3.connect('accounts.db')
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS accounts (
            id          INTEGER PRIMARY KEY AUTOINCREMENT,
            username    TEXT UNIQUE NOT NULL,
            password    TEXT NOT NULL
        )
    ''')
    conn.commit()
    conn.close()
```

- 3번 줄: 현재 디렉터리에서 *accounts.db*라는 데이터베이스 파일을 찾아 해당 데이터베이스에 접속한다. 만약 데이터베이스 파일이 없다면 생성한다. 해당 변수는 데이터베이스와의 연결을 관리하는 객체를 반환하며, 이를 `conn` 변수에 대입해 사용한다. 
- 4번 줄: **커서(Cursor)** 라는 객체를 만들며, 커서는 데이터베이스에서 SQL query를 실행하고 결과를 처리하기 위한 인터페이스이다. 
- 5 ~ 11번 줄: `cursor.execute(query)`는 SQL query를 실행하는 메서드로, query를 실행해서 데이터베이스에 `accounts` 라는 테이블을 만들며, 테이블에 저장되는 하나의 데이터는 `id, username, password`를 담는다. 또한, `IF NOT EXISTS`가 포함되어 있기 때문에 이미 데이터베이스에 `accounts`라는 테이블이 있다면 만들지 않는다. ([[Background - 데이터베이스]] 참고)
- 12번 줄: 데이터베이스의 변경 사항을 저장한다. 
- 13번 줄: 데이터베이스와의 연결을 종료한다.

**`check_account()` 추가 - 계정 정보 검증 함수**
인자로 전달받은 `username`과 `password`가 데이터베이스에 담긴 계정 정보와 일치하는지 검증하는 함수이다. 

```python
...
def check_account(username, password):
    conn = sqlite3.connect('accounts.db')
    cursor = conn.cursor()
    cursor.execute('SELECT * FROM accounts WHERE username = ? AND password = ?',
                   (username, password))
    user = cursor.fetchone()
    conn.close()
    return user
...
```

- 5 ~ 7번 줄: `accounts` 테이블에서 계정 정보를 하나 가져와 `user` 변수에 대입하며, 계정 정보를 가져올 때 `username`이 인자로 전달받은 `username`이면서 `password`도 인자로 전달받은 `password`와 동일한 계정 정보만 가져온다. 동일한 계정 정보가 없는 경우, `user` 변수에 Python의 `None` 값이 들어간다. 
- `conn.commit()`은 호출하지 않는다. 
	- `check_account()`에서는 단순히 `SELECT` 명령어로 데이터를 조회하기만 하고 데이터 자체는 수정하지 않았기 때문에 `conn.commit()`은 호출할 필요가 없다. 

여기까지 테스트해 보고 싶다면 [DB가 적용된 로그인 기능 만들어보기 - 테스트하기](https://learn.dreamhack.io/737#19)에서 확인해 보면 된다. 


## 회원가입 및 로그아웃 기능 추가하기
---
이번에는 진짜 마지막으로, 앞서 만든 웹사이트에 회원가입 페이지와 로그아웃을 할 수 있는 페이지도 추가해보도록 한다.

실습을 진행하면서 느꼈겠지만, 외부 프로그램(DB Browser for SQLite)을 사용해서 일일히 사용자의 정보를 DB에 넣는 작업은 매우 번거롭기 때문에, 이를 코드 레벨에서 실행할 수 있도록 다른 웹 사이트들처럼 회원가입 기능과 로그아웃 기능을 추가할 것이다.


### 회원가입 및 로그아웃 기능 구상하기
---
앞으로 만들 회원가입, 로그아웃 기능을 어떤 엔드포인트에 넣을지, 어떻게 논리 흐름을 구체화할지 생각하는 시간을 가져보며, 엔드포인트가 반환할 HTML 문서에 대해서도 계획해 본다. 

**엔드포인트 구상**
다음 3개의 엔드포인트를 지원하도록 만들 것이다. 

- `GET /register` - 회원가입을 시도할 수 있는 웹 페이지를 반환함
- `POST /register` - 회원가입 시도를 실제 처리함
- `GET /logout` - 접근 시 로그아웃을 수행함

다음은 각각의 엔드포인트가 어떤 기능과 과정을 수행할지 생각해 보자. 

**`GET /register` 엔드포인트**
사용자가 웹 사이트의 `GET /register` 엔드포인트에 접근하면 <u>아이디와 비밀번호로 회원가입을 시도할 수 있는 웹 페이지</u>를 반환한다. 해당 웹 페이지 문서의 이름은 *register.html*로 한다. 

**`POST /register` 엔드포인트**
`POST /register` 엔드포인트는 사용자가 `GET /register` 엔드포인트에서 아이디와 비밀번호를 입력하고 회원가입 버튼을 누르면, 해당 데이터를 POST 메서드로 전달받아 처리한다. 

`<form>` 태그를 통해 아이디와 비밀번호를 POST 데이터로 전달받아 *accounts.db* 데이터베이스의 `accounts` 테이블에 계정 정보를 추가하며, <u>회원가입에 성공하면 회원가입 성공 페이지인 *register_success.html*를, 실패하면 실패 페이지인 *register_failure.html*를 반환한다.</u>

**`GET /logout` 엔드포인트**
`GET /logout` 엔드포인트는 사용자가 접근하면 로그아웃되며, 여기서 로그아웃이란 말의 의미는 사용자의 세션 데이터를 지운다는 의미이다. 또한, 로그아웃 이후에는 사용자가 다시 로그인할 수 있도록 `GET /login` 엔드포인트로 리다이렉트시킨다.

**HTML 문서 구상**
앞서 엔드포인트를 구상해보면서 다음의 HTML 문서들이 필요하다는 것을 알 수 있었다. 

- *register.html*
- *register_success.html*
- *register_failure.html*

각 문서에서 필요한 점들도 다시 한 번 구체화해보자.

***register.html***
아이디와 비밀번호로 회원가입할 수 있는 웹 페이지로, 아이디와 비밀번호를 입력할 수 있는 입력 폼이 존재해야 하고, 회원가입 버튼도 필요하다. 이때, 회원가입 버튼을 누르면 아이디와 비밀번호를 `POST /register` 엔드포인트로 전달해야 한다.

***register_success.html***
회원가입 성공 시 보여지는 웹 페이지로, `Register Successful`이라는 문구를 출력해야 한다. 

***register_failure.html***
회원가입 실패 시 보여지는 웹 페이지로, `Register Failed`라는 문구를 출력해야 한다.


### HTML 문서 제작하기
---
먼저 회원가입 웹 페이지를 제작해보도록 한다. 로그아웃은 별도의 웹 페이지가 필요하지 않으며, 이번에 만들 웹 페이지는 총 3개이다. 

- *register.html*
- *register_success.html*
- *register_failure.html*

각각의 웹 페이지를 만들어보자. 

***register.html***
```html
<!DOCTYPE html>
<html>
	<head>
		<title>Flask Simple Register</title>
	</head>
	<body>
		<h2>Register</h2>
		<form action="/register" method="post">
			Username:<br>
			<input type="text" id="username" name="username">
			<br><br>
			Password:<br>
			<input type="password" id="password" name="password">
			<br><br>
			<button>Register</button>
		</form>
	</body>
</html>
```

***register_success.html***
```html
<!DOCTYPE html>
<html>
	<head>
		<title>Flask Simple Register</title>
	</head>
	<body>
		<h2>Registration Successful</h2>
	</body>
</html>
```

***register_failure.html***
```html
<html>
	<head>
		<title>Flask Simple Register</title>
	</head>
	<body>
		<h2>Registration Failed</h2>
	</body>
</html>
```



### *app.py* 최종 코드
---
```python
from flask import Flask, render_template, redirect, request, session, url_for
import os
import sqlite3

app = Flask(__name__)
app.secret_key = os.urandom(32)\


def init_db():
	conn = sqlite3.connect('accounts.db')
	cursor = conn.cursor()
	cursor.execute('''
		CREATE TABLE IF NOT EXISTS accounts (
			id        INTEGER PRIMARY KEY AUTOINCREMENT,
			username  TEXT UNIQUE NOT NULL,
			password  TEXT NOT NULL
		)
	''')
	conn.commit()
	conn.close()


def add_account(username, password):
	conn = sqlite3.connect('accounts.db')
	cursor = conn.cursor()
	try:
		cursor.execute('INSERT INTO accounts (username, password) VALUES (?, ?)', (username, password))
		conn.commit()
		conn.close()
	except sqlite3.IntegrityError:
		conn.close()
		return False


def check_account(username, password):
	conn = sqlite3.connect('accounts.db')
	cursor = conn.cursor()
	cursor.execute('SELECT * FROM accounts WHERE username = ? AND password = ?', (username, password))
	user = cursor.fetchone()
	conn.close()
	return user


@app.route('/register', methods=['GET'])
def get_register():
	return render_template('register.html')


@app.route('/register', methods=['POST'])
def post_register():
	username = request.form.get('username')
	password = request.form.get('password')
	if add_account(username, password):
		return render_template('register_success.html')
	else:
		return render_template('register_failure.html')


@app.route('/login', methods=['GET'])
def get_login():
	if 'username' in session:
		return redirect(url_for('get_login_success'))
	return render_template('login.html')


@app.route('/login', methods=['POST'])
def post_login():
	if 'username' in session:
		return redirect(url_for('get_login_success'))
	
	username = request.form.get('username')
	password = request.form.get('password')
	if check_account(username, password):
		session['username'] = username
		return redirect(url_for('get_login_success'))
	else:
		return redirect(url_for('get_login_failure'))


@app.route('/login_success')
def get_login_success():
	if 'username' not in session:
		return redirect(url_for('get_login'))
	return render_template('login_success.html')


@app.route('/login_failure')
def get_login_failure():
	if 'usernamae' in session:
		return redirect(url_for('get_login_success'))
	return render_template('login_failure.html')


@app.route('/logout', methods=['GET'])
def get_logout():
	session.clear()
	return redirect(url_for('get_login'))


if __name__ == '__main__':
	init_db()
	app.run(host='0.0.0.0', port=31337)
```

### Flask 웹 서버 디렉터리 구성하기
---
이제, 최종적으로 파일들을 디렉터리 상에서 다음의 트리 구조가 되도록 구성하면, 세션이 적용된 로그인 기능을 제공하는 웹 서버 제작이 끝난다. 

```
.
├── app.py
└── templates
    ├── login_failure.html
    ├── login.html
    ├── login_success.html
    ├── register_failure.html
    ├── register.html
    └── register_success.html
```

물론, 모든 파일들은 최종본으로 적용해야 문제 없이 잘 돌아간다. 만약 디렉터리를 구성하는 데 어려움을 겪고 있거나, 웹 서버가 잘 동작하지 않는 경우, [이 링크](https://dreamhack-lecture.s3.ap-northeast-2.amazonaws.com/uploads/web-service/flask-app-login-final.zip)를 통해서 파일을 다운로드해 실습하면 되며, 해당 *.zip* 파일은 디렉터리 구성이 끝나 정상적으로 작동하는 웹 서버 파일이다. 


### 웹 서비스 테스트하기
---
이제 웹 서비스를 테스트해보자. 

1. 브라우저의 URL 바에 `http://127.0.0.1:31337/register`를 입력하면 아래 사진과 같이 회원가입 페이지가 나온다. 
	![[Pasted image 20260113194215.png]]
2. `Username`에 `admin`을, `Password`에 `qwe123`을 입력한 뒤 `Login` 버튼을 누르면 다음과 같이 성공적으로 회원가입이 된 것을 확인할 수 있다. 
	![[Pasted image 20260113194207.png]]
3. 이제 다음 사진처럼 로그인 페이지를 반환하는 `http://127.0.0.1:31337/login` 으로 이동해 보자. 
	![[Pasted image 20260113194157.png]]
4. 앞서 설정한 `admin` 계정으로 로그인하면, 다음 사진처럼 로그인에 성공한다. 
	![[Pasted image 20260113194148.png]]
5. 마지막으로 로그아웃을 하기 위해 `http://127.0.0.1:31337/logout`으로 이동해보면 다음 사진처럼 로그아웃이 수행된 후 로그인 페이지로 돌아가는 모습을 확인할 수 있다. 
	![[Pasted image 20260113194138.png]]

## 마치며
---
이번 강의에서는 사용자로부터 아이디와 비밀번호를 입력받아 로그인을 처리하는 기능을 구현해보았다. 그 과정에서 세션을 사용해 로그인 상태를 유지하는 방법을 배우고, 데이터베이스를 사용해 데이터를 저장하고 조회하는 방법도 배웠다. 이 과정에서 단순히 로그인 시스템의 핵심 원리만 이해하는 것이 아닌, 웹 서버가 어떻게 구현되고 동작하는지도 알게 되었다. 

이번 강의에서는 단순히 웹 서버를 구축할 때 어떻게 구축하고 이해할 수 있는지에만 초점을 두었기 때문에, 보안에 대해서는 깊게 다루지 않았다. 실제로는 비밀번호 해시화, SQL Injection 방지, HTTPS 적용 등과 같이 보안을 위한 요소들을 반드시 고려해야 한다. 

이번 강의를 전부 복습한 이후에는 더 안전하고 견고한 웹 서버를 만드는 방법에도 관심을 두고 학습을 이어나가는 것도 추천한다. 
