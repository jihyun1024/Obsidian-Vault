---
tags:
  - 암호학
  - 3학년_2학기
---
## 학습 주제
1. ECC의 핵심: domain parameters
2. Bitcoin에 사용되는 EC: secp256k1
3. ECDH(EC Diffie Hellman Key Exchange Protocol)
4. ECDSA(Elliptic Curve Digital Signature Algorithm)

---
## 연관 수업
[[양자보안_4주차_월요일]]
[[양자보안_4주차_수요일]]
[[양자보안_5주차_월요일]]
[[양자보안_5주차_수요일]]
[[양자보안_6주차_월요일]]

--- 
## 수업과 관련한 질문 3가지
1. 교재 53, 54 page에서 cofactor에 해당하는 h가 반드시 1이나 2이어야 하는지
2. 56 page에서 Algorithm Design과 Implementation Design이 어떻게 다른 것인지
3. 격자 기반, 코드 기반, 해시 기반 PQC 중에서 가장 안전하다 평가되는 것이 있는지

---
## 강의 요약
이번 강의에서는 domain parameter, ECDH, ECDSA 등등 ECC의 세부 사항에 대해 자세하게 알아볼 예정이다. 
### ECC의 핵심: domain parameters
[[양자보안_4주차_수요일]] 강의에서 마지막에 언급했던 **domain parameter**에 대해 알아보자. 

Domain parameter는 사전에 설정되는 정보로, 누구나 알 수 있다. 
![[Pasted image 20251014001225.png]]
이 사진에서 $F_{2^m}$은 바둑판 = 유한체의 크기를 결정하는 것으로, binary field이며 reduction polynomial처럼 클수록 안전하지만, 그에 비례해서 연산량이 늘어난다. 

$a, b$는 Binary field에서의 타원곡선 식인 $y^2 + xy = x^3+ ax^2 + b$를 결정하는 데 사용한다. 
$x, y$는 기저점 $P$의 x, y 좌표로, 계산할 때마다 항상 256bit씩 총 512bit를 들고 다녀야 하기 때문에 공개키 암호가 느려지는 이유 중 하나이다. 
$n$은 기저점 $P$의 소수인 order(위수)로, binary field의 크기인 $2^m$과 비슷한 크기로 커야 안전하다.

이 그림 하단에서 가장 먼저 설정되는 것은 $m$의 크기로, 보안 강도를 먼저 설정하고 나서 reduction polynomial을 설정하고, $a, b$를 설정한다. 
B-163과 B-233의 차이는 보안 강도 차이로, 163과 233이 숫자 상으로는 70 차이나지만, 실제로는 $2^{163}$과 $2^{233}$의 차이이기 때문에 매우 크게 차이가 난다. 

또한 reduction polynomial이 $m$차 다항식일 경우, $F_{2^m}$에서는 $m-1$차 다항식만 존재한다. B-233에서의 reduction polynomial을 보면 항이 상수항 포함해서 총 3개인데, 이 경우 작동하기에 시간을 덜 잡아먹어 매우 효율적인 다항식이라 할 수 있다. 

### Bitcoin에 사용되는 EC: secp256k1
이 내용은 [[양자보안_5주차_수요일#ECC in Bitcoin? secp256k1|10월 1일 강의]]에 잘 나와 있으니 이를 참고하자.  

### ECDH(EC Diffie Hellman key Exchange Protocol)
**ECDH**가 어떻게 작동하는지 알아보자. 
그 전에, 어떤 타원곡선(예: secp256k1)을 사용하는지 당사자와 제 3자 모두 알고 있다 가정한다. ![[Pasted image 20251014005609.png]]

ECDH는 다음과 같은 순서대로 작동한다. 
1. 개인키 $d_A, d_B$ 선택
	1. 이 경우, 각각의 개인키는 상대방조차도 알지 못한다.
	2. $d_A, d_B$는 $order-1$ 범위까지의 수 중에서 원하는 것으로 선택한다. 
2. 공개키 계산
	1. Alice와 Bob은 각각의 개인키와 기저점 $G$를 가지고 공개키 $d_A \times G$, $d_B \times G$를 연산한다.
	2. 이후 공개키**만** 서로 전송한다. 
3. Shared key 계산
	1. 각 상대방에게서 받은 공개키와 자신이 가지고 있는 개인키를 서로 곱한다. 
	2. 이 과정에서 결과적으로 상대의 값을 몰라도 서로 같은 값을 나눠 가지게 된다. 

### ECDSA(Elliptic Curve Digital Signature Algorithm)
**ECDSA**가 어떻게 작동하는지 알아보자. 
ECDSA의 목적은 메시지가 중간에 누군가에 의해 변조되지 않았는지(**무결성**), 진짜 그 사람이 메시지를 전송한 게 맞는지(**출처 인증**) 이 두 가지를 검증하기 위해 실행한다. 

먼저 Key Generation 단계부터 알아보자. ![[Pasted image 20251014010328.png|450]]
이 단계는 개인키와 공개키를 각각 만드는 단계로, 서명을 생성하는 사람이 수행한다. 

이 단계에서 중요한 parameter는 기저점 $P$와 order $n$으로, 먼저 개인키 $d$를 1부터 $n-1$의 범위에서 **랜덤하게** 설정한다. (이는 타원곡선 암호에서 난수발생기가 꼭 필요한 이유가 된다.) 이후 이를 바탕으로 $P$와 $d$를 타원곡선 스칼라 곱으로 연산해 공개키 $Q = dP$를 계산하여 공개키 $Q$와 개인키 $d$를 가지게 된다. 

그 다음 Signature Generation 단계는 서명을 생성하는 단계이다. ![[Pasted image 20251014010337.png]]
이 단계는 타원곡선 파라미터와 개인키, 서명 대상 메시지를 가지고 서명을 생성한다. 

먼저, 1부터 $n-1$의 범위에서 서명할 때만 쓰고 사용하지 않을 난수인 $k$를 뽑아낸다. 이후 $kP$를 스칼라 곱 연산해 그 점의 x 좌표인 $x_1$을 정수 $\bar{x_1}$으로 변환하고, 그걸 다시 order $n$에 대한 모듈러 연산으로 $r$을 계산한다. 
이 때, $r$이 0이라는 의미는 점 $kP$의 x 좌표가 0, 즉 무한원점과 마찬가지라는 의미이므로 다시 난수 $k'$를 뽑아 $r'$을 계산한다. 그 다음 메시지를 해시함수에 넣는데, 그 이유는 메시지 원본을 직접 사용하면 너무 커서 그 대신 메시지 $m$과 거의 동일한 해시값 $e$를 사용하기 위함이다. 
가장 중요한 연산인 $s$를 $s = k^{-1}(e + dr)$로 계산하며, $s$에는 난수값 $k$, 서명 대상 메시지의 해시값 $e$, 개인키 $d$가 전부 들어 있어 **원본 메시지에 비해 매우 작은 크기로도 여러 정보를 포함한다.** 

마지막으로 Signature Verification 단계는 서명 작성자가 보낸 서명을 검증한다. ![[Pasted image 20251014010344.png]]
이 단계는 개인키가 없기 때문에 서명을 검증하는 누구나 할 수 있다. 

먼저, $r, s$, 즉 서명값이 1과 $n-1$ 사이에 있는지 판단해 만약 없다면 서명을 Reject하며, 있을 경우, ECDSA에서는 해시 함수 알고리즘을 공개하기 때문에 해당 해시 함수로 메시지의 해시값 $e$를 계산한다. 
이후 3, 4, 5단계에 이어 6단계에 이르기까지 다양한 연산들을 하는데, 이 연산들이 서명 생성 단계와는 매우 다름에도 서명 검증이 제대로 되는 이유는 다음처럼 증명할 수 있다. 

$$u_1 = ew = e{s^{-1}} = e(k^{-1}(e + dr))^{-1}$$
$$u_2 = rw = rs^{-1} = r(k^{-1}(e + dr))^{-1}$$
이 두 수식으로부터 $X = u_1P+u_2Q$를 계산한 결과는 다음과 같다. 
$$X = u_1P + u_2Q = ek(e + dr)^{-1}P + rk(e+dr)^{-1}dp$$
$$ \ \ \ \ \ \ \ \ \ \ \ \\ \ \ \\ \  = k(e + dr)^{-1}(eP + drP) = kP(e + dr)(e+dr)^{-1} = kP$$
이때, 서명이 검증되는 경우는 이 식의 결과물의 좌표의 x 좌표를 정수로 변환한 것이 $r$과 같을 경우인데, $r$은 $kP$의 x 좌표를 정수로 변환한 것이 되어 둘이 동일하기 때문에 서명이 검증된다. 

이 경우, 비교 대상 값은 이미 받은 $r$값이 되며, 이 값이 $v$, 즉 알고리즘에서서 $X$의 x 좌표값을 검증자가 연산한 것과 일치하는지 판단한다. 

---
## 중요한 단어
1. Domain Parameters
2. secp256k1
3. ECDH
4. ECDSA

