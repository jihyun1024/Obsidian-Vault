---
tags:
  - Programming
  - 3학년_2학기
title: Synchronization Examples
---
## 학습 주제
1. Classic Problems of Synchronization
2. Bounded-Buffer Problem
3. Readers-Writers Problem

---
## 연관 수업
[[운영체제_7주차]]
[[운영체제_9주차_화요일]]
[[운영체제_9주차_목요일]]

---
## 강의 요약
이번 강의에선 [[운영체제_9주차_화요일|저번 강의]]에서 다룬 내용을 이용해 Synchronization에 대한 예시를 살펴볼 것이다. 저번 강의에서 직접 이어지는 내용이니, 저번 강의를 잘 이해하고 오자. 
### Classic Problems of Synchronization
동시성을 제어하는 문제인 Concurrency-Control Problem에는 다음 세 가지가 존재한다.

- Bounded-Buffer Problem: 공유 자원에 대하여 둘 다 수정하는 경우
- Readers-Writers Problem: 공유 자원에 대하여 한 쪽만 수정하는 경우
	- 수정 도중에 Read하면 문제가 될 수 있음
- Dining-Philosophers Problem: 공유 자원에 대하여 꼬리물기가 발생하는 경우

이 중 이번 시간에는 Bounded-Buffer Problem과 Readers-Writers Problem에 대해 다룰 것이다. 

### Bounded-Buffer Problem
**Bounded-Buffer Problem**은 공유 메모리인 Buffer에 대해 증가와 감소가 동시에 일어나는 상황에 대한 문제로, Producer-Consumer Problem이라 하기도 한다. 

Producer는 계속 값을 집어넣으며, Consumer는 계속 값을 빼 가는 상황이며, Producer와 Consumer는 각각 여러 명이 될 수도 있다. 

이 때, 제한해야 하는 자원은 Buffer로, Buffer에 대해 Mutex lock을 걸면 된다. 또한, 신호의 동기화가 필요한데, 꽉 찼는데도 계속 Producer가 넣거나, 비어 있는데도 Consumer가 계속 빼려고 할 경우, 메모리 관련 문제가 발생할 수 있다. 

아래 코드는 각각 Producer와 Consumer에 대한 Pseudocode이다. 
![[Pasted image 20251105011701.png]]
![[Pasted image 20251105011519.png]]

* Producer
	* `wait(empty)`: `empty`가 0보다 큰 경우 = 빈 칸이 있을 경우, `empty--` 실행
	* `wait(mutex)`: `mutex`가 1인 경우 = 아무도 Critical Section에 없을 경우, `mutex = 0`
	* `signal(mutex)`: `mutex`를 다시 1로 설정 = Critical Section에서 나왔음
	* `signal(full)`: `full`을 1 증가 = 내용물이 있는 칸 수가 1 증가했음
* Consumer
	* `wait(full)`: `full`이 0보다 큰 경우 = 내용물이 있을 경우, `full--` 실행
	* `wait(mutex)`: `mutex = 0`
	* `signal(mutex)`: `mutex = 1`
	* `signal(empty)`: `empty`를 1 증가 = 빈 칸 수가 1 증가했음

이를 `pthread`로 구현한 결과는 다음과 같다. (`in, out`은 Circular array 때문에 사용했다)
![[Pasted image 20251105012133.png]]
![[Pasted image 20251105012144.png]]
![[Pasted image 20251105012243.png]]
이 때, Producer가 먼저 실행될지, Consumer가 먼저 실행될지는 `rand()` 함수를 사용해서 랜덤하게 결정된다. 

### Readers-Writers Problem
**Readers-Writers Problem**은 말 그대로 다수의 Reader(데이터를 읽기만 하는 사람)와 Writer(데이터를 쓸 수 있는 사람)로 이루어진 상황에서의 문제로, Reader와 Writer가 동시에 데이터에 접근해 Reader는 데이터를 읽고, Writer는 데이터를 쓰고자 하는 상황에서 두 가지의 상황이 가능하다.

1. The First Readers-Writers Problem
	- Writer는 모든 Reader의 실행을 기다린 이후에 실행됨
	- Semaphore: Mutex, Reader의 수에 대한 Mutex
	- 공유 변수: Reader의 수
	- Writer가 무한히 대기할 수 있다. (Starvation)
2. The Second Readers-Writers Problem
	- Writer가 실행을 신청한 순간, 더 이상 Reader를 받지 않음
	- Reader가 무한히 대기할 수 있다. (Starvation)

이 중 첫 번째 Readers-Writers Problem에 대한 Pseudocode는 다음과 같다. 
![[Pasted image 20251105013316.png]]
![[Pasted image 20251105013324.png]]
첫 번째 Semaphore는 DB에 대한 Mutex로, reader와 writer 전부 공유하는 Semaphore이다. 반면, 두 번째 Semaphore는 reader의 수를 증감할 때 필요한 Mutex로, reader만 사용한다. 

따라서, `read_count`는 말 그대로 reader의 수를 나타낸다는 것을 쉽게 알 수 있으며, 두 번째 사진에서 왼쪽은 writer에 대한 Pseudocode를, 오른쪽은 reader에 대한 Pseudocode를 의미한다는 것을 추측해 볼 수 있다. 

reader에 대한 Pseudocode에서 `read_count++`은 자신이 reader이며, reader가 한 명 더 추가되었다는 것을 알린다. 이후, 첫 번째 `if`문에서 `read_count == 1`인지 검사하는데, 이는 내가 처음 들어간 reader인 경우 `rw_index`, 즉 DB에 대한 Mutex를 대기한다. 

이는 밑에서도 비슷하게 작용해서 두 번째 `if`문에서 `read_count == 0`인지 검사하는 이유는 reader가 나밖에 없을 때, reader들이 다 읽었다는 것을 `signal(rw_mutex)`를 통해 공지한다. 

>*Readers-Writers Problem에서 첫 번째 reader만 `rw_mutex`를 사용하는 이유는 reader들이 동시에 읽을 수 있도록 하면서도 writer와의 충돌을 방지하기 위함이다. 이를 Copilot에게 물어본 결과는 다음과 같다. 참고하자.* 

- **첫 번째 reader가 들어올 때**:
    - `read_count`가 0 → 즉, 아무도 읽고 있지 않음.
    - writer가 들어오지 못하게 `rw_mutex`를 잠금.
- **그 이후 reader들**:
    - 이미 `rw_mutex`가 잠겨 있으므로 writer는 접근 불가.
    - reader들은 `rw_mutex`를 건드릴 필요 없이 그냥 읽기만 하면 됨.
- **마지막 reader가 나갈 때**:
    - `read_count`가 0이 되면 → 더 이상 읽는 사람이 없음.
    - `rw_mutex`를 풀어서 writer가 들어올 수 있게 함.
    - 즉, writer가 작업 중일 때는 어떤 reader도 들어올 수 없음

따라서, `rw_mutex`는 **reader와 writer 간의 Mutual Exclusion을 위한 lock이라 할 수 있다.**

한편, Readers-Writers Problem을 실제 C 코드로 구현한 결과는 다음과 같다. 
![[Pasted image 20251105014845.png]]
![[Pasted image 20251105014856.png]]

---
## 중요한 단어
1. Bounded-Buffer Problem
2. Readers-Writers Problem
