---
tags:
  - Programming
  - 3학년_2학기
---
## 학습 주제
1. User Threads and Kernel Threads
2. Multithreading Models
3. Pthreads
4. Threads in Java

---
## 연관 수업
[[운영체제_4주차_화요일]]

---
## 강의 요약
### User Threads and Kernel Threads
저번 시간에 Thread에 대해서 대강 살펴 보았다. Thread는 크게 두 종류로 나누어진다. 

- **User Thread**
	- Kernel의 지원 없이 사용자가 정의하고 관리하는 Thread
		- 라이브러리나 사용자의 코드에 의해 관리
		- 예시: pthread 라이브러리를 사용하는 C 프로그램에서 생성되는 Thread
	- 장점
		- Fast switching: kernel mode에서 system call을 사용하지 않기 때문에, Thread 간의 Context switching이 매우 빠르다. 
		- Kernel Independent: Kernel에 독립적으로 구현하기 때문에, 라이브러리만 있다면 어떤 OS에서도 사용 가능하다. 
		- Low Overhead: Kernel의 자원을 사용하지 않기 때문에 Thread의 생성과 관리에 사용되는 자원의 요구량이 매우 낮다. 
	- 단점
		- No True Parallelism: Kernel은 User Thread를 단 하나의 프로세스로만 인식하기 때문에 User Thread가 얼마나 많든 CPU의 단 하나의 코어만 사용할 수 있다. 
		- Blocking Problem: 위와 연관되는 개념으로, 만약 하나의 User Thread가 I/O 작업 때문에 멈춘다면, Kernel은 전체 Process가 멈춘 것으로 인식한다. 

- **Kernel Thread**
	- OS, 즉 Kernel이 지원하고 관리하는 Thread
		- CPU 작업에서의 실제 단위
	- 장점
		- True Parallelism: Kernel이 각각의 Kernel Thread를 관리하기 때문에 각각을 다른 CPU 코어에 넣어 실행하여 병렬화를 구현할 수 있다. 
		- Stablity: 만약 하나의 Kernel Thread가 멈추어도 동일 프로세스 내의 다른 Thread는 이에 독립적이기 때문에 전체 프로세스가 멈추는 것을 막을 수 있다. 
		- Efficient Resource Usage: Kernel에 의해 관리되기 때문에 I/O 등의 작업에 사용되는 자원을 효율적으로 배정받을 수 있다. 
	- 단점
		- Slower Switching: Thread 생성, 관리, 제거, switching 등이 전부 system call을 필요로 하기 때문에 User Thread보다 더 큰 Overhead와 더 느린 속도를 가진다.
		- Resource Consumption: Kernel Thread는 TCB(Thread Control Block)에서 Kernel의 관리를 필요로 하기 때문에 더 많은 메모리 자원을 필요로 한다. 

### Multithreading Models
User Thread와 Kernel Thread는 하나만 사용하지 않고 서로 연관되어 있으며, 이 둘을 연결하는 Multithreading Model로는 세 개의 모델이 존재한다. 
#### Many-to-One Model
여러 User Thread가 하나의 Kernel Thread에 mapping되는 모델이다. 

이 모델의 특징은 Thread 관리가 사용자 수준에서 이루어지며, 구현이 간단하고, Context Switching이 빠르지만, 동시에 하나의 User Thread가 멈추면 Kernel은 전체 프로세스가 멈춘 것으로 인식하기 때문에 다른 User Thread 또한 모두 멈추게 된다. 

또한, 오직 하나의 Thread만 Kernel 단에서 실행될 수 있기 때문에 Parallelism의 구현이 어렵다. 
![[Pasted image 20251001025441.png|300x180]]
#### One-to-One Model
User Thread 각각이 1대 1로 Kernel Thread에 mapping되는 모델이다. 이 모델은 주로 Windows나 Linux에서 사용된다. 

이 모델의 특징은 User Thread의 수 = Kernel Thread의 수가 되기 때문에 Thread가 하나씩 추가될수록 시스템에 부담이 가지만, Many-to-One 모델보다 더 좋은 Concurrency를 구현할 수 있다는 장점이 있다. 
![[Pasted image 20251001025800.png|300x180]]
#### Many-to-Many Model
User Thread 여러 개가 Kernel Thread 여러 개에 mapping되는 모델이다. 이 모델은 주로 Go 언어에서 볼 수 있다. 

이 모델의 특징은 Kernel과 User 양 단에서 Thread 관리가 가능하며, 유연한 Scheduling과 Blocking 문제가 간단하게 해결 가능하다는 장점이 있다.(하나의 Kernel Thread가 막혀도 다른 Kernel Thread를 쓰면 되기 때문이다) 
단, 구현이 복잡하다는 단점이 있다. 
![[Pasted image 20251001030147.png|300x180]]

한편, User Thread가 구현된 라이브러리로 Pthread와 Windows thread, Java thread가 있으며, 여기서는 Pthread와 Java thread를 학습할 것이다. 
### Pthreads
Pthreads는 POSIX 표준을 따르는 스레드 프로그래밍 API로, C/C++에서 Multithreading을 구현할 때 사용하는 라이브러리이다. 주로 Unix 계열 운영체제인 Linux, macOS 등에서 사용되며 병렬 처리나 동시성 프로그래밍에서 매우 유용하게 사용된다. 

헤더 파일은 `<pthread.h>`로 구현되어 있다. 

**Pthreads - Thread 생성**
```cpp
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

// 이렇게 구현되어 있음
int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// thread: 생성된 스레드 식별자
// attr: 스레드 특정 설정 (기본 NULL)
// start_routine: 스레드 함수 (스레드로 분기해서 실행할 함수)
// arg: 스레드 함수 인자

// 예시
pthread_t sample_thread;
void *thread_function(void *ptr);

ret = pthread_create(&sample_thread, NULL, thread_function, (void *)message1);
// 반환값: 스레드가 잘 생성되었다면 0, 아니라면 0이 아닌 값
// -> Process에서 pid와 유사한 개념
```

**Pthreads - Thread 종료**
```cpp
// 이렇게 구현되어 있음, exit 함수와 유사, 
// retval: NULL 또는 0을 매개변수로 입력하여 종료
void pthread_exit(void *retval);

// 예시
pthread_exit(NULL);
```

**Pthreads - Thread 합류(Join)**
```cpp
// 이렇게 구현되어 있음
int pthread_join(pthread_t thread, void **thread_return);
// thread: 기다릴 스레드의 식별자
// thread_return: 스레드의 반환값을 가져올 포인터

// 예시 - pthread 식별자를 가진 스레드의 종료를 기다리고, status 포인터로 종료값 가져옴
pthread_join(p_thread, (void *)&status);
printf("thread join: %d\n", status); // 종료값 출력
```

**Pthreads 예시**
```cpp
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

void *thread_function(void *ptr) // 생성될 스레드에서 실행할 함수
{
	char *message;
	message = (char *) ptr; // 함수의 매개변수를 message 변수에 대입
	printf("%s\n", message); // message를 화면에 출력
	pthread_exit((void *)100); // 스레드를 종료 후 상태값을 100으로 설정
}

int main() {
	pthread_t thread1, thread2; // 스레드 포인터 변수 생성
	const char *message1 = "Thread 1";
	const char *message2 = "Thread 2";
	int ret, status;
	
	ret = pthread_create(&thread1, NULL, thread_function, (void *)message1);
	printf("%d\n", ret);
	if (ret == 0) { // 스레드1 생성 성공
		printf("pthread_create returns %d\n", ret);
	} else { // 스레드1 생성 실패
		printf("pthread_create returns error: %d\n", ret);
		exit(1);
	}
	ret = pthread_create(&thread2, NULL, thread_function, (void *)message2);
	if (ret == 0) { // 스레드2 생성 성공
		printf("pthread_create returns %d\n", ret);
	} else { // 스레드2 생성 실패
		printf("pthread_create returns error: %d\n", ret);
	}
	
	pthread_join(thread1, (void **)&status); // 스레드1이 끝날 때까지 대기
	printf("thread1 returns: %d\n", status);
	pthread_join(thread2, (void **)&status); // 스레드2가 끝날 때까지 대기
	printf("thread2 returns: %d\n", status);
	
	return 0;
}
```
참고로, 이 코드의 실행 결과는 다음과 같으며, 이는 Thread를 먼저 만들었다고 해서 먼저 실행되는 것은 아니라는 것을 보여 준다. 
![[Pasted image 20251001034510.png]]

위 코드들처럼 코딩해서 Data Parallelism과 Task Parallelism을 구현할 수 있으며, 시험공부할 때 이 문서를 보고 있다면 이 밑에 교재 229쪽과 230쪽을 참고해서 한 번 짜 보자. 

### Threads in Java
Java의 Thread는 Java에서 Multithreading을 구현하기 위한 핵심 클래스로, Java는 OS에 독립적으로 Thread를 다룰 수 있도록 `java.lang.Thread` 클래스를 제공한다. 

Java에서 Thread를 만드는 방법은 크게 세 가지로 구분된다. 
- Inheritance(상속): Thread 클래스를 상속받아 구현하며, `public void run()` 메소드를 오버라이드한다. 
- Runnable 인터페이스 구현
- Lambda 표현식을 사용

**Thread 클래스 상속**
```java
class MyThread1 extends Thread { // extends: Thread 클래스를 상속
	public void run() { // 스레드가 실행할 코드
		try {
			while (true) {
				System.out.println("Hello, Thread!");
				Thread.sleep(500); // 스레드를 이 시간동안 일시 정지
			}
		}
		catch (InterruptedException ie) {
			System.out.println("I'm interrupted");
		}
	}
}

public class ThreadExample1 {
	public static final void main(String[] args) {
		MyThread1 thread = new MyThread1();
		thread.start(); // 새로운 스레드를 시작하고, run()을 호출
		System.out.println("Hello, My Child!");
	}
}
```

**Runnable Interface 구현**
```java
class MyThread2 implements Runnable { // implements: Runnable을 구현
	public void run() { // 스레드가 실행할 코드
		try {
			while (true) {
				System.out.println("Hello, Runnable!");
				Thread.sleep(500);
			}
		}
		catch (InterruptedException ie) {
			System.out.println("I'm interrupted");
		}
	}
}

public class ThreadExample2 {
	public static final void main(String[] args) {
		Thread thread = new Thread(new MyThread2());
		thread.start(); // 새로운 스레드를 시작하고, run()을 호출
		System.out.println("Hello, My Runnable Child!");
	}
}
```

**Lambda expression 사용**
```java
public class ThreadExample3 {
	public static final void main(String[] args) {
		Runnable task = () -> { // () -> {실행할 코드} 형식으로 구현
			try {
				while (true) {
					System.out.println("Hello, Lambda Runnable!");
					Thread.sleep(500);
				}
			}
			catch (InterruptedException ie) {
				System.out.println("I'm interrupted");
			}
		};
		Thread thread = new Thread(task);
		thread.start();
		System.out.println("Hello, My Lambda Child!");
	}
}

// Join 사용
public class ThreadExample4 {
	public static final void main(String[] args) {
		Runnable task = () -> { // () -> {실행할 코드} 형식으로 구현
			for (int i = 0; i < 5; i++) {
				System.out.println("Hello, Lambda Runnable!");
			}
		};
		Thread thread = new Thread(task);
		thread.start();
		try {
			thread.join();
		}
		catch (InterruptedException ie) {
			System.out.println("Parent thread is interrupted");
		}
		System.out.println("Hello, My Joined Child!");	
	}
}

// Interrupt 사용
public class ThreadExample5 {
	public static final void main(String[] args) throws InterruptedException {
		Runnable task = () ->  {
			try {
				while (true) {
					System.out.println("Hello, Lambda Runnable!");
					Thread.sleep(100);
				}
			}
			catch (InterruptedException ie) {
				System.out.println("I'm interrupted");
			}
		};
		Thread thread = new Thread(task);
		thread.start();
		Thread.sleep(500);
		Thread.interrupt();
		System.out.println("Hello, My Interrupted Child");
	}
}
```

앞에서도 말했지만, 위 코드들처럼 코딩해서 Data Parallelism을 구현할 수 있으며, 시험공부할 때 이 문서를 보고 있다면 이 밑에 교재 239쪽을 참고해서 한 번 짜 보자. 

---
## 중요한 단어
1. User Threads
2. Kernel Threads
3. Multithreading Models
4. Pthreads
5. Java Thread