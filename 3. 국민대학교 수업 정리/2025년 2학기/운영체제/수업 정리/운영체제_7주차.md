---
tags:
  - Programming
  - 3학년_2학기
---
## 학습 주제
1. Background of Synchronization
2. Race Condition
3. The Critical Section Problem (CSP)
4. Peterson's Algorithm
5. Hardware Solutions to the Critical Section Problem

---
## 연관 수업
[[운영체제_2주차_화요일]]
[[운영체제_2주차_목요일]]

---
## 강의 요약
### Background of Synchronization
이번 수업에서는 OS에서 동기화(**Synchronization**)에 대한 부분을 집중적으로 다루고 있다. 대부분의 운영체제는 Cooperating, 즉 여러 개의 프로세스가 실행되기 때문에, 필연적으로 각각의 프로세스는 *논리 주소를 공유*하거나 *데이터 자체를 공유* 하는 등 서로 영향을 주고 받는다. 

그러나, 그 과정에서 공유 데이터에 대한 Concurrent access = 동시적인 접근은 데이터에 대한 일관성을 해칠 수 있다. 따라서, 이런 상황을 피하기 위해 Cooperating process들 간 적절한 동기화 알고리즘이 필요하다. 

### Race Condition
같은 변수에 접근해도 접근 순서에 따라 값이 달라질 수 있다. 이는 여러 개의 프로세스가 동일한 데이터에 접근함에 따라 일어난다. 다음의 코드를 생각해 보자. 
```cpp
#define BUFFER_SIZE 1000

int count = 0;

/* Produce an item in next_produced */
while (true) {
	while (count == BUFFER_SIZE) 
		; // do nothing
		
	buffer[in] = next_produced;
	in = (in + 1) % BUFFER_SIZE;
	count++;
}

/* consume an item in next_consumed */
while (true) {
	while (count == 0) 
		; // do nothing
		
	next_consumed = buffer[out];
	out = (out + 1) % BUFFER_SIZE;
	count--;
}
```
이 상황에서 현재 `count` 변수의 값이 5라고 하자. producer와 consumer는 동시에 각각 `count++`과 `count--`를 수행한다. 

그렇다면, 실행 이후 `count`의 값은 한번씩 더하고 뺐기 때문에 5가 되어야 하지만, 실제로는 4, 5, 6 또는 엉뚱한 값이 나올 수 있다. 그 이유는 기계어 레벨까지 내려가 봐야 한다. 

`count++` 연산과 `count--` 연산은 각각 아래 사진과 같이 레지스터를 통해 구현된다. ![[Pasted image 20251015070353.png]]

이 때의 동작은 다음과 같다. 
![[Pasted image 20251015070705.png]]
여기서 `count`에 레지스터의 값을 반환하기 **이전에** Context Switch가 일어나 잘못된 `count`값이 레지스터로부터 반환받는 문제가 발생한다. 

이런 것들을 **Race Condition, 또는 경쟁 상태**라 해서 같은 데이터를 접근하고 수정하려는 상황을 의미한다. 이 경우, 위처럼 명령어를 수행하는 순서에 따라 같은 변수라도 값이 계속 변할 수 있다.
따라서, 이를 방지하기 위해 딱 하나의 프로세스만 데이터에 접근할 수 있도록 해야 한다. 이를 **Process Synchronization**이라 한다. 

### The Critical Section Problem (CSP)
**Critical Section Problem, 경계 구역 문제**란 프로세스로 이루어진 시스템에서 발생하는 문제로, **다른 프로세스와 공유되고 있는, 데이터에 접근할 수 있는 영역인 Critical Section**에 접근할 때 아무 제약 없이 들어가지 말고 약간의 제약을 두어야 위와 같은 문제가 없다. 

따라서, 시스템에서 하나의 프로세스가 Critical Section에 있을 때, 다른 프로세스의 해당 영역에 대한 접근을 제한해 동시에 두 프로세스가 그 위에서 돌아가지 말아야 한다. 

따라서, 코드를 여러 부분으로 나눌 것이다. 각 부분은 순서대로 이어져 있다. 
- entry section
	- 프로세스가 Critical Section에 들어가기 전에 수행하는 코드
	- 여기서 다른 프로세스가 Critical Section에 있는지 판단
- critical section
	- 공유된 데이터에 접근하는 영역
	- 한 번에 하나의 프로세스만 들어가는 영역
	- 예: 파일 쓰기
- exit section
	- 프로세스가 Critical Section을 나올 때 수행
- remainder section
	- Critical Section 외의 작업을 수행하는 부분
	- 예: 일반적인 계산, 출력 등 공유된 데이터와 관련 없는 부분

이를 위해 3가지의 요구 사항이 필요하다. 
- **Mutual Exclusion, 상호 배제**
	- 하나의 프로세스가 Critical Section에 있다면 나머지는 못 들어옴
	- Critical Section Problem을 푸는 데 *가장 중요한 요구 사항*
- Progress
	- Deadlock 방지를 위한 것
	- 현재 어떤 프로세스도 Critical Section에서 실행 중이 아니고 어떤 프로세스가 거기 들어가길 원할 경우, 그 프로세스가 Critical Section에 들어갈 수 있도록 해야 함
- Bounded Waiting
	- Starvation 방지를 위한 것
	- Critical Section에 들어오고 싶은 프로세스가 우선순위가 낮은 경우, 무한히 기다리게 하지 않아야 함 (이미 들어가 있는 프로세스가 있어도 적용됨)

### Peterson's Algorithm
CSP를 해결하기 위한 알고리즘 중 하나로 **Peterson's Algorithm**이 가장 유명하며, 이는 Mutual Exclusion을 구현하는 알고리즘이다. (물론 나머지 조건들도 만족한다.)

Peterson's Algorithm은 교재에서는 다음과 같이 이루어져 있다.
```cpp
#include <stdio.h>
#include <pthread.h>

#define true 1
#define false 0

int sum = 0;
int turn;
int flag[2];

// producer는 turn의 값과 flag의 인덱스로 0을 사용
void *producer(void *param) {
	int k;
	for (k = 0; k < 10000; k++) {
		/* entry section */
		flag[0] = true;
		turn = 1; // turn을 상대방에게 넘김
		while (flag[1] && turn == 1) // 상대방이 들어가고 싶고, 내가 양보할 경우
			; // do nothing
		
		/* critical section */
		sum++;
		
		/* exit section */
		flag[0] = false; // critical section에서 나왔음을 알림
		
		/* remainder section */
	}
	pthread_exit(0);
}

// consumer는 turn의 값과 flag의 인덱스로 1을 사용
void *consumer(void *param) {
	int k;
	for (k = 0; k < 10000; k++) {
		/* entry section */
		flag[1] = true;
		turn = 0; // turn을 상대방에게 넘김
		while (flag[0] && turn == 0) // 상대방이 들어가고 싶고, 내가 양보할 경우
			; // do nothing
		
		/* critical section */
		sum--;
		
		/* exit section */
		flag[1] = false; // critical section에서 나왔음을 알림
		
		/* remainder section */
	}
	pthread_exit(0);
}

int main() {
	pthread_t tid1, tid2;
	pthread_create(&tid1, NULL, producer, NULL);
	pthread_create(&tid2, NULL, consumer, NULL);
	pthread_join(tid1, NULL);
	pthread_join(tid2, NULL);
	printf("sum = %d\n", sum);
}
```

`flag`란, 단어의 뜻대로 깃발을 뜻하는데, 이는 자신이 Critical Section에 들어가 있을 때 `flag` 배열의 원소를 `true`로 설정해 자신이 Critical Section에서 실행 중임을 알린다. 

따라서, `consumer`에서의 코드를 보면 entry section에 해당하는 for문 바로 밑 부분에서는 `flag[1]`을 `true`로 설정해 자신이 실행 중임을 알리며, `turn` 또한 0으로 설정한다. 
이는 `producer`에서도 0과 1이 반대로 설정되어 실행되기 때문에, `consumer` 부분 코드에서 `while`문에서 조건이 하나라도 `false`가 되면, 즉 `producer`가 Critical Section을 더 이상 쓰지 않으면 그제서야 밑으로 내려가 `sum--;` 연산을 수행한다. 

이후, Critical Section에서 나와야 하기 때문에 다시 `flag[1]`을 `false`로 돌려놓는다. 

이 알고리즘은 CSP를 완화할 수 있지만, 오류 자체를 완벽히 차단할 수는 없는데, 그 이유는 `flag`를 확인하는 등의 과정에서도 Context Switch가 일어날 수 있기 때문이다. 

### Hardware Solutions to the Critical Section Problem
CSP를 해결하는 방법 중에는 Peterson's Algorithm처럼 SW적인 방법도 있지만, HW적인 방법 또한 존재한다. 대표적으로 **Atomicity, 즉 원자적 연산**을 통해 해결하는 방법이 존재한다. 

Atomic이란 말의 의미는 단어 뜻 그대로 원자적이라는 의미이며, 따라서 Atomic operation은 중간에 누군가 끼어들 수 없이 중단하지 않고 한 번에 완전히 실행되는 최소 단위의 연산이다. 

현대의 CPU는 여러 가지 Atomic 명령어를 제공한다. 
- `test_and_set()`
```cpp
// test_and_set은 atomic한 명령어
boolean test_and_set(boolean *target) {
	boolean rv = *target;
	*target = true;
	
	return rv;
}

// lock이라는 전역변수 가정 (0으로 초기화)
// lock은 Peterson's algorithm에서 turn, 즉 양보와 비슷한 개념
do {
	while (test_and_set(&lock)) // lock의 주소에 있는 값을 true로 변환
		; /* do nothing */
	
		/* critical section */
		
		lock = false; 
		
		/* remainder section */
	} while (true);
```

- `compare_and_swap()`
```cpp
// compare_and_swap은 atomic한 명령어
int compare_and_swap(int *value, int expected, int new_value) {
	int temp = *value;
	
	if (*value == expected)
		*value = new_value;
	
	return temp;
}

// lock이라는 전역변수 가정 (0으로 초기화)
while (true) {
	while (compare_and_swap(&lock, 0, 1) != 0) // lock의 주소에 있는 값을 1로 변환
		; /* do nothing */
		
		/* critical section */
		
	lock = 0;
	
		/* remainder section */
}
```

Atomic을 Java로 구현한 결과물은 다음과 같다. 이 과정에서 `.set()`과 `.get()`을 사용했다. 
`.set()`과 `.get()`의 경우에는 값이 변하거나 값을 가져올 동안에는 Context Switch가 발생하지 않는 메서드로, Java에서 지원한다. 

먼저, Java로 그냥 Peterson's Algorithm을 구현해 보았다. 
```java
public class Peterson1 {
	static int count = 0;
	
	static int turn = 0;
	static boolean[] flag = new boolean[2];
	
	public static void main(String[] args) throws Exception {
		Thread t1 = new Thread(new Producer());
		Thread t2 = new Thread(new Consumer());
		t1.start();
		t2.start();
		t1.join();
		t2.join();
		
		System.out.println(Peterson1.count);
	}
}

// Producer 클래스 구현
// Producer는 turn의 값과 flag의 인덱스로 0을 사용
static class Producer implements Runnable {
	@Override
	public void run() {
		for (int k = 0; k < 10000; k++) {
			/* entry section */
			flag[0] = true;
			turn = 1;
			while (flag[1] && turn == 1)
				;
			
			/* critical section */
			count++;
			
			/* exit section */
			flag[0] = false;
			
			/* remainder section */
		}
	}
}

// Consumer 클래스 구현
// Consumer는 turn의 값과 flag의 인덱스로 1을 사용
static class Consumer implements Runnable {
	@Override
	public void run() {
		for (int k = 0; k < 10000; k++) {
			/* entry section */
			flag[1] = true;
			turn = 0;
			while (flag[0] && turn == 0)
				;
			
			/* critical section */
			count--;
			
			/* exit section */
			flag[1] = false;
			
			/* remainder section */
		}
	}
}
```

그 다음은 위에서 설명했던 `.set()`과 `.get()`을 이용해 atomic variable을 선언하는 방향으로 Peterson's Algorithm을 구현해 보았다. 
```java
import java.util.concurrent.atomic.AtomicBoolean // Atomic을 위한 패키지

public class Peterson2 {
	static int count = 0;
	
	static int turn = 0;
	static AtomicBoolean[] flag; // Atomic variable
	static {
		flag = new AtomicBoolean[2];
		for (int i = 0; i < flag.length; i++)
			flag[i] = new AtomicBoolean();
	}
}

// Producer는 turn의 값과 flag의 인덱스로 0을 사용
static class Producer implements Runnable {
	@Override
	public void run() {
		for (int k = 0; k < 100000; k++) {
			/* entry section */
			flag[0].set(true);
			turn = 1;
			while (flag[1].get() && turn == 1)
				;
			
			/* critical section */
			count++;
			
			/* exit section */
			flag[0].set(false);
			
			/* remainder section */
		}
	}
}

// Consumer는 turn의 값과 flag의 인덱스로 1을 사용
static class Consumer implements Runnable {
	@Override
	public void run() {
		for (int k = 0; k < 100000; k++) {
			/* entry section */
			flag[1].set(true);
			turn = 0;
			while (flag[0].get() && turn == 0)
				;
				
			/* critical section */
			count--;
			
			/* exit section */
			flag[1].set(false);
			
			/* remainder section */
		}
	}
}
```

---
## 중요한 단어
1. Race Condition
2. Process Synchronization
3. Critical Section Problem
4. Mutual Exclusion (+ Progress, Bounded Waiting)
5. Peterson's Algorithm
6. Atomicity
