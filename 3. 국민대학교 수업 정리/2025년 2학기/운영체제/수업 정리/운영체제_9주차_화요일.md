---
tags:
  - Programming
  - 3학년_2학기
title: Synchronization Tools
---
## 학습 주제
1. Mutex Locks
2. Semaphores
3. Monitors
4. Liveness

---
## 연관 수업
[[운영체제_7주차]]

---
## 강의 요약
이번 강의에서는 Programming이나 OS 단에서 사용되는 Synchronization을 구현하기 위한 High-Level Tool들을 살펴볼 것이다. 이 Tool에는 Mutex Locks, Semaphore, Monitor, Liveness가 있다. 
### Mutex Locks
먼저 **Mutex Locks**란, *Mutual Exclusion을 구현하기 위하여 개발된 알고리즘*으로, 마치 화장실 문의 잠금장치처럼 Critical Section을 어떤 프로세스가 사용하고 있다면 해당 Critical Section에 대해서는 그 누구도 들어오지 못하도록 Lock을 걸어서 Race condition을 해결한다. 

이를 위해 프로세스는 Critical Section에 들어올 때 lock을 acquire하며, 반대로 Critical Section에서 나올 때는 lock을 release한다. 따라서, `acquire()`와 `release()` 두 개의 함수가 필요하며, 그 두 개의 함수가 공통으로 다루는 변수인 `lock`이라는 Boolean 변수가 필요하다. 

두 함수를 Pseudocode로 정의한 것은 다음과 같다. 
```cpp
acquire() {
	while (!available)
		; /* busy wait = 계속 화장실 문을 두들기면서 대기하는 상태 */ 
	available = false;
}

release() {
	available = true;
}
```
해당 코드에서 `acquire` 부분을 설명하자면, `while`문에서 `available`이 False, 즉 다른 프로세스가 Critical Section에 있는 경우에는 계속 대기하다가 `available`이 True = 다른 프로세스가 Critical Section에서 벗어난 경우, `available`을 False로 지정해 자신이 쓸 것이라고 공지한다. 
`release` 부분에선 이미 Critical Section에서 할 일을 다 마친 상태이기 때문에 `available` 변수를 True로 지정해 Critical Section에 진입하고 싶어하는 다른 프로세스가 들어올 수 있도록 한다. 

이 때, `acquire()`와 `release()`는 반드시 atomic하게 진행되어야 하는데, 이는 둘 다 `available`이라는 변수를 다루고 있기 때문이다. 따라서, 두 함수는 하드웨어 적용이 되어 있다. 

또한, `acquire()` 과정에서 **Busy Waiting**이 발생할 수 있으며, 이는 `acquire()`를 실행할 때 계속 프로세스가 루프를 도는 현상을 의미한다. 이 Busy waiting 현상은 멀티프로그래밍 시스템에서 안 좋은 현상인데, 왜냐하면, 이 대기하는 과정에서도 계속 CPU를 잡아먹기 때문에 다른 프로세스가 사용할 수 있는 귀중한 자원을 소비하기 때문이다. 

그래서, Mutex lock 중에서 Busy waiting 방식을 사용하는 것들을 따로 **Spinlock**이라 부르며, 이는 lock이 available할 때까지 계속 loop를 도는 것으로, 장단점이 전부 존재한다. 

장점으로는 다음과 같다. 
1. Context Switch가 필요 없다. (Context Switch는 은근 많은 시간을 소모한다.)
2. 구현이 상대적으로 간단하다. 
3. 멀티코어 시스템 환경에서 하나의 프로세싱 코어에서 lock을 기다리는 동안, 다른 코어에서 실행되는 Thread에서는 lock을 해제할 수 있어 빠른 응답이 가능하다. 

`pthread`를 이용해 Mutex Lock을 구현한 결과는 다음과 같다. 
![[Pasted image 20251105000334.png]]

### Semaphores
**Semaphore**라는 방법에 대하여 배워 볼 것이다. Semaphore란 단어의 의미는 '신호수'의 의미로, 아래 그림처럼 특정 상황에 대하여 어떻게 행동할지를 정해 주는 것이다. 
![[Pasted image 20251105000606.png]]

사실, 위에서 살펴봤던 Mutex Lock의 General한 버전으로, semaphore $S$는 Mutex lock에서의 boolean 변수 `available` 대신 정수(integer)값으로, 현재 사용 가능한 총 자원의 수를 나타낸다. 또한, 두 atomic한 operation으로 구성되며, `wait()`와 `signal()`, 또는 `P()` 또는 `V()`로 나타낼 수 있다. (이 수업에서는 전자로 지칭한다)

이를 이해하기 위한 적합한 예시 상황은 30대의 컴퓨터가 4개의 프린터를 사용하려고 하는 상황으로, 여기서 $S=사용\ 가능한\ 총\ 자원의\ 수 = 프린터의\ 개수 = 4$ 이다. 

이 때 `wait()`와 `signal()` 함수의 Pseudocode는 다음과 같다. 
![[Pasted image 20251105001041.png]]
`wait()`에서는 사용 가능한 자원이 없다면 기다리며, 사용 가능한 자원이 1이라도 있다면 $S$를 1 감소시키고 나서 자신이 그 자원으로 들어간다. 반면, `signal()`에서는 이미 사용한 자원을 반환하며, 이 과정에서 $S$를 1 증가시켜 자신이 그 자원을 다 사용했다는 것을 공지한다. 

Semaphore 방식의 구현에 있어서 문제가 없는 것은 아닌데, 대표적으로 Busy waiting 문제가 있다. 이는 Mutex lock보다 더 많은 Resource가 사용되고 더 많은 프로세스가 대기하기 때문에 나타나는 단점으로, 해당 문제를 해결하려면 `wait()`와 `signal()`의 정의를 busy wait 대신에 Waiting queue에 가서 자기 자신을 Suspend하고, 자원이 있을 경우 Ready queue로 옮기는 방식으로 구현할 수 있다. 

이를 자세하게 Pseudocode로 나타내면
![[Pasted image 20251105001459.png]]
이 사진과 같으며, `pthread`를 사용해 C 언어로 구현한 결과는 다음과 같다. 
![[Pasted image 20251105001536.png]]

### Monitors
Monitor는 약간 implicit한 방법으로, Semaphore 방식을 쓰다 보면 Timing Error가 발생할 수 있다. 이는 항상 일어나는 것은 아니지만 감지하기 어려운 상황으로, 예를 들어 `wait()`와 `wait()`를 호출하는 사이에 Critical Section 연산이 있을 경우, Semaphore가 2번 감소해서 Semaphore의 값이 음수가 될 수 있다. 

**Monitor**는 Implicit Threading처럼 추상적인 개념으로, Critical Section에 대한 접근을 제어하는 High-Level Synchronization 기법이다. Monitor 내부에서는 단 한 개의 프로세스만 동작하도록 설계되어 있으며, Conditional variable이라는 도구를 통해 자동으로 프로세스의 실행을 관리한다. 
![[Pasted image 20251105003526.png]]

### Liveness
Mutex lock이나 Semaphore에선 Mutual Exclusion에만 집중했다면, **Liveness**는 Progress와 Bounded Waiting (각각 Deadlock, Starvation 문제)을 담당한다. Liveness의 실패로 발생할 수 있는 문제는 Deadlock과 Priority Inversion 문제가 있다. 

먼저, Deadlock에 대해 알아보자. $S, Q$가 유이한 공유 자원이고, 프로세스는 $P_0, P_1$만 존재한다고 가정하자. 이 때, 다음처럼 서로서로 인질을 잡고 안 놔줘서 둘 다 실행이 안 되는 상황이 발생할 수 있다. 
![[Pasted image 20251105004053.png]]

그 다음으로는 Priority Inversion 문제가 발생할 수 있는데, 이는 우선순위가 높은 프로세스가 대기해야 하는 현상으로, 우선순위가 낮은 프로세스가 높은 프로세스보다 먼저 실행되는 현상이다. 

예를 들어, 낮은 우선순위 $P_1$, 중간 우선순위 $P_2$, 높은 우선순위 $P_3$가 있다고 가정해 보자. 
$P_1$이 Critical Section에서 실행 중이다. 이 때, $P_3$가 실행되며, 같은 Critical Section을 필요로 하는데 이미 Critical Section에서는 $P_1$이 있으므로 $P_3$는 대기 상태로 들어간다. 
그 사이 $P_2$가 실행되는데, $P_2$는 Critical Section에서의 작업을 필요로 하지 않아 계속 실행된다 가정하자. 

이러면 문제가 생기는데, 결과적으로 우선순위가 가장 높은 $P_3$는 대기 상태이고, 중간 우선순위인 $P_2$가 CPU를 점유하게 되어 낮은 우선순위인 $P_1$도 실행되지 못하고 결국 $P_3$ 또한 계속 대기한다. 
이처럼 낮은 우선순위위가 높은 우선순위의 실행을 막는 상황을 Priority Inversion이라 한다.

따라서, 이를 방지하기 위해 **Priority-inheritance Protocol(우선순위 상속 프로토콜)** 을 사용하게 되는데, 이는 자원을 점유한 낮은 우선순위 $P_1$이 일시적으로 높은 우선순위를 상속받아 먼저 실행되고, 자원을 해제하면 다시 원래의 우선순위로 돌아가는 방식이다. 

---
## 중요한 단어
1. Mutex Locks
2. Busy Waiting
3. Spinlock
4. Semaphores
5. Monitors
6. Liveness
7. Priority Inversion
8. Priority-inheritance Protocol
