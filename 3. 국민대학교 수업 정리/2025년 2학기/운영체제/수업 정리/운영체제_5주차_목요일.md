---
tags:
  - 3학년_2학기
---
## 학습 주제
1. CPU Scheduling
2. CPU Scheduler
3. Dispatcher
4. Scheduling Criteria
5. FCFS Scheduling
6. SJF Scheduling

---
## 연관 수업
[[운영체제_1주차_목요일]]

---
## 강의 요약
### CPU Scheduling
**CPU Scheduling**이란 멀티프로그래밍 운영체제의 기본이 되는 것으로, 멀티프로그래밍의 목적은 여러 개의 프로세스를 동시에 실행하는 것이자(Concurrency, Parallelism), CPU의 효율성을 최대로 끌어올리는 데 있다. 

여기서 하나의 개념이 나오는데, 바로 **CPU-I/O Burst**이다. 
이를 간단하게 설명하면, 프로세스가 CPU를 점유하는 시간(CPU-Burst)과 입출력 장치를 사용하는 시간(I-O Burst)이 번갈아 나타나는 것으로, CPU-I/O Burst Cycle이라고도 한다. 

이 때 우리가 집중해서 고려해야 할 것은, 바로 실제 CPU 사용 시간인 CPU-Burst의 분배이다.

### CPU Scheduler
CPU Scheduling을 수행하는 CPU Scheduler는 크게 두 가지로 나뉜다. 

먼저, Preemptive는 선제적, 자발적이라는 뜻으로, 어떤 상황에 맞게 알아서 대응한다는 의미이다.
Preemptive Scheduler는 효율성을 위해 프로세스가 CPU 내에서 완료되지 않아도 스케줄러에서 강제로 내려오게 할 수 있다. 

다른 하나인 Non-preemptive는 비자발적이라는 뜻으로, 프로세스는 그 프로세스가 완료되기 전까지 CPU를 점유하며, 그 말인 즉 프로세스가 끝나거나(Terminated), 또는 Waiting 상태로 들어가기 전까지 CPU를 사용한다는 의미이다. 

CPU Scheduling에서 판단이 필요한 상황은 다음 4가지가 있다:
1. 프로세스가 Running 상태에서 Waiting 상태로 전환할 때
2. 프로세스가 Running 상태에서 Ready 상태로 전환할 때
3. 프로세스가 Waiting 상태에서 Ready 상태로 전환할 때
4. 프로세스가 Terminate될 때

상황 1, 4번은 Scheduler의 입장에서는 현재 프로세스가 나가고 다음 프로세스가 들어오면 되기만 하는 상황이기 때문에, 이 두 상황에서만 동작하는 CPU Scheduler는 Non-preemptive이다. 
그러나, 2, 3번은 선택의 여지가 있다.

### Dispatcher
그 전에 Dispatcher라는 개념에 대해 알고 가야 하는데, Dispatcher란 Scheduler에서 선택한 프로세스를 실제 CPU에 올려 주는 OS의 구성 요소이다. 

Dispatcher는 다음 3가지의 역할을 수행한다. 
1. 프로세스 간 Context switching 실행
2. Kernel mode에서 User mode로 전환
3. 새로 시작된 프로세스의 프로그램 카운터 위치에서 프로세스 실행 시작\

![[Pasted image 20251006224016.png|300]]
이 중 Context switch 과정에서 하나의 실행 중인 프로세스를 멈추고 다음 프로세스가 시작하는 데 걸리는 시간을 **dispatcher latency**라 하며, 이 시간을 줄이기 위해 Dispatcher의 속도가 가능한 최대로 빨라야 한다. 

### Scheduling Criteria
CPU Scheduling에서 고려할 요소들은 다음 5가지이다:

1. CPU utilization
	- CPU를 얼마나 잘 굴리는지
	- Maximize해야 한다. 
2. Throughput
	- 단위 시간당 프로세스를 얼마나 많이 처리했는지
	- Maximize해야 한다.
3. Turnaround time
	- 프로세스 하나를 전부 처리하는 데 얼마나 시간이 많이 들었는지 
	- Minimize해야 한다. 
4. Waiting time
	- 프로세스가 Ready queue에서 얼마나 많은 시간 동안 있었는지
	- Minimize해야 한다.
5. Response time
	- 어떤 요청에서 그에 대한 첫 번째 반응이 나타날 때까지 얼마나 걸렸는지
	- Minimize해야 한다. 

이 기준들을 어떻게 잘 조정하는지에 따라 다양한 Scheduling algorithm들이 있으며, 오늘의 강의에서는 FCFS와 SJF algorithm에 대해 알아볼 것이다. 

### FCFS Scheduling
**FCFS Scheduling**은 First-Come, First-Served의 약자로, 가장 심플한 Scheduling algorithm이다. 
이 알고리즘은 말 그대로 가장 먼저 온 프로세스가 가장 먼저 처리되는 방식으로, FIFO queue로 구현할 수 있다. 

프로세스 $P_1, P_2, P_3$가 차례대로 도착하고, 각각의 CPU-Burst time은 각각 24, 3, 3ms라 가정하자. 

FCFS 알고리즘을 바탕으로 Gantt Chart로 표시하면 다음 그림과 같다. 
![[Pasted image 20251006231924.png]]
이 때의 Waiting time(프로세스 당 실행되기까지 대기 시간), Turnaround time을 계산한 결과는 다음과 같다 **(계산 문제는 시험에 나올 수도 있다)**: 
- Total Waiting time: $0 + 24 + 27 = 51ms$
- Average Waiting time: $\frac{51}{3} = 17ms$
- Total Turnaround time: $24 + 27 + 30 = 81ms$
- Average Turnaround time: $\frac{81}{3} = 27ms$

만약, 순서를 조금 바꿔서 $P2, P3, P1$의 순서대로 도착한다면 Gantt chart는 다음과 같다. 
![[Pasted image 20251006232218.png]]
- Total Waiting time: $0 + 3 + 6 = 9ms$
- Average Waiting time: $\frac{9}{3} = 3ms$
- Total Turnaround time: $3 + 6 + 30 = 39 ms$
- Average Turnaround time: $\frac{39}{3} = 13ms$

이렇듯, 순서만 바꿔도 대략적인 소모 시간이 확 줄거나 확 늘어나는 특징이 있으며, 첫 번째 예시처럼 큰 거 하나 때문에 나머지 또한 확 느려지는 것을 **Convoy Effect**라고 한다. 
![[Pasted image 20251006232908.png]]

### SJF Scheduling
**SJF Scheduling**은 Shortest-Job-First의 약자로, 앞의 FCFS Scheduling에서 지적된 단점을 보완하기 위해 고안된 알고리즘이라 할 수 있다. 이 알고리즘은 CPU가 사용 가능할 때, **다음** CPU Burst가 가장 작은 프로세스를 먼저 실행한다. 

만약 두 개 이상의 프로세스의 CPU-Burst가 같다면, 그 때는 FCFS Scheduling 방식으로 먼저 온 거 먼저 처리하게 된다. 

프로세스 $P_1, P_2, P_3, P_4$가 도착하고, 각각의 CPU-Burst time은 각각 6, 8, 7, 3ms라 가정하자. 
이 때는 CPU-Burst가 가장 작은 프로세스부터 실행하기 때문에 Gantt chart는 다음과 같다. 
![[Pasted image 20251006233416.png]]
이 때의 Waiting time과 Turnaround time을 각각 계산하면
- Total Waiting time: $0 + 3 + 9 + 16 = 28ms$
- Average Waiting time: $\frac{28}{4} = 7ms$
- Total Turnaround time: $3 + 9+ 16+24 = 52ms$
- Average Turnaround time: $\frac{52}{4} = 13ms$

이는 평균 13ms안에 싱글코어로 모든 프로세스를 끝낼 수 있어 상당히 좋은 알고리즘이다.
그러나 이는 **Provably optimal**, 즉 이론상 최적의 방법으로, 이 예시에서의 가정은 미래를 이미 알고 있어 즉 아직 실행하지 않았음에도 CPU Burst를 알 수 있다고 가정하기 때문에 실제 실행에서는 이를 예측을 해야 한다. 

CPU Burst를 예측하기 위한 방법으로는 **exponential average**를 사용하여 과거의 값을 바탕으로 하지만, 최근의 값에 더 가중치를 두어 예측하는 방법이 있다. 

이 방법을 점화식으로 쓰면  $\hat{\tau}_{n+1} = \alpha \tau_n + (1 - \alpha) \hat{\tau}_n$ 이다. 
- $\hat{\tau}_{n+1}$: 예상되는 다음 CPU Burst의 값
- $\tau_n$: 현재의 CPU Burst 관측값
- $\hat{\tau_n}$: 현재의 CPU Burst 예측값
- $\alpha$: 0과 1 사이의 값

이 방법을 쓰면 과거의 값일수록 계속 $(1-\alpha)$가 곱해지기 때문에 지수적으로 과거의 값의 영향력이 낮아져 최신 값을 더 잘 반영하게 된다. (다만, 이상과 현실 사이의 Gap 또한 존재한다)
![[Pasted image 20251006235306.png]]

또한, SJF Scheduling은 Preemptive도, Non-preemptive도 될 수 있다.
현재 프로세스가 실행되고 있을 때 새로운 프로세스가 들어오고 그 프로세스의 CPU-Burst가 현재 프로세스보다 낮을 때, 기존의 프로세스 실행을 중지하고 새로운 프로세스를 실행시킬 수 있으며, 이를 SRJF (Preemptive SJF)라고 한다. 

---
## 중요한 단어
1. CPU Scheduling
2. CPU-I/O Burst
3. dispatcher latency
4. FCFS Scheduling
5. Convoy Effect
6. SJF Scheduling
7. exponential average