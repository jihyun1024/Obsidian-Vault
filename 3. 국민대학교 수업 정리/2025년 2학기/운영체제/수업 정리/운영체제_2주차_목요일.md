---
tags:
  - 3학년_2학기
---
## 학습 주제
1. Process concept
2. Process state
3. Process Control Block (PCB)
4. Thread
5. Process scheduling
6. Context switch

---
## 이전 수업
[[운영체제_2주차_화요일]]

---
## 강의 요약
### Process concept
프로세스를 실행하기 위해서는 CPU 사용 시간, 메모리 공간, 파일, 입출력 디바이스 등의 HW/SW 자원이 필요하다. 
이 때 사용되는 메모리는 여러 섹션으로 나눌 수 있다. 

- Text section: 실행 가능한 프로그램 코드
- Data section: 전역변수
- Heap section: 프로그램이 실행될 동안 동적으로 할당된 메모리 공간
- Stack section: 함수 parameter, 리턴 주소(함수가 끝난 뒤 복귀할 주소), 지역 변수 등 임시적인 데이터가 저장되는 공간

이를 그림으로 표현하면 다음과 같다.![[Pasted image 20250913231413.png]]
이 그림에서 `x`, `y`는 각각 초기화되지 않은 전역변수와 초기화된 전역변수로, heap과 text section 사이에 들어가며, `argc, *argv[]`는 함수의 매개변수로 stack section 위에 들어간다. 
또한, `*values, i`는 지역변수로 stack section에, `values`는 동적할당된 공간으로 heap section에 들어간다. 

### Process state
프로세스가 실행되면, 모든 프로세스는 다섯 가지 상태(State) 중 하나로 결정된다. 

- New: 프로세스가 막 생성됨
- Running: 프로세스가 지금 실행 중임
- Waiting: 프로세스가 입출력 과정이나 기타 신호 등등을 받기 위해 대기 중임
- Ready: 프로세스가 프로세서에 의해 실행되는 것을 기다리고 있음
- Terminated: 프로세스가 실행을 끝냄

![[Pasted image 20250913232100.png]]

### Process Control Block (PCB)
PCB(Process Control Block) 또는 TCB(Task Control Block)는 각각의 프로세스에 대한 정보가 들어있는 일종의 꾸러미 같은 것으로, CPU가 처리하던 내용들을 프로세스 자신의 PCB에 저장하고, 다음에 다시 CPU를 점유해 작업을 수행할 때 PCB로부터 해당 정보들을 넘겨받아 계속해서 하던 작업을 마저 진행할 수 있게 한다. 

즉, PCB는 운영체제가 프로세스를 표현한 것이라 볼 수 있다. 

PCB에 저장되어 있는 정보는 다음과 같다. 
- 프로세스 상태
	- New, Ready, Running, Waiting, Terminated 등
- 프로그램 카운터
	- 프로그램에서 몇 번째 명령어까지 실행되었는지
	- 즉, 해당 프로세스가 다음에 실행할 명령어의 주소를 저장
- CPU 레지스터
	- 직전까지 계산했던 값이나 실행했던 명령들을 저장한 레지스터
- CPU 스케줄링 정보
- 메모리 관리 정보
- 프로세스 계정 정보
	- 프로세스 실행을 위해 사용된 CPU 시간, 실행 ID 등등
- I/O 상태 정보
	- 프로세스에 할당된 입출력 장치 목록, 열린 파일 등등

### Thread
스레드는 운영체제의 실행 단위 중 하나로 프로세스보다 작은 실행 단위이다. 예전에는 프로그램을 실행하는 흐름은 프로세스 뿐이었는데 소프트웨어가 진보하면서 하나의 프로세스에서 복잡한 동시 작업을 요구하기 시작하였다.

그러다보니 프로세스보다 작고 동시처리에 최적인 실행 단위가 필요하였고 그게 바로 스레드다. 하나의 프로세스에 여러 개의 스레드가 있을 수 있고, 서로 메모리를 공유하여 코드를 실행한다. 

대다수의 운영체제의 스케줄러는 스레드를 최소 단위로 하여 동작한다. 즉 스레드가 코드 실행을 담당한다.

### Process scheduling
Multiprogramming의 목표는 여러 개의 프로세스를 동시에 동작하는 것으로, 이를 통해 CPU의 효율을 극대화할 수 있다. 

또한, Time sharing(시분할 시스템)의 목표는 CPU 코어에서 실행되는 프로세스를 재빠르게 바꿔서 여러 프로세스가 실시간으로 동시에 실행되는 것(Real-time system)처럼 보이는 것이다. 

이를 위해 Scheduling queue라는 개념이 필요한데, 이는 다음과 같다. 
- 프로세스가 시스템 내에 들어오면, ready queue에 들어간다. 이 ready queue는 CPU 코어에 들어가 실행되는 것을 기다리기 위해 필요하다. 
- 만약 특정 작업이 실행되는 것을 기다리는 프로세스가 있다면, 그 프로세스는 waiting queue로 들어가서 해당 작업을 기다린다. 
- **이 queue들은 [[운영체제_2주차_목요일#Process Control Block (PCB)|PCB]]들을 엮은 Linked list로 구현한다.**

![[Pasted image 20250914000307.png]]

CPU를 사용한 후, 특정한 작업을 기다리는 것이 아닌 이상 바로 ready queue로 들어가며, 특정한 작업을 먼저 수행해야 한다면 해당 작업을 먼저 수행한 후에야 ready queue로 들어간다. 
![[Pasted image 20250914000517.png]]

또한, 대부분의 프로세스들은 I/O bound 또는 CPU bound process로 분류할 수 있다. 
- I/O bound process: I/O 작업에 더 많은 시간을 쓰는 프로세스
- CPU bound process: CPU를 활용한 계산 작업에 더 많은 시간을 쓰는 프로세스

### Context switch
프로세스의 내용물은 대부분 PCB 안에 정의되어 있다.
만약 인터럽트가 일어나면, 시스템은 현재 실행 중인 프로세스의 내용을 PCB를 만들어 저장해 나중에 다시 해당 프로세스를 실행할 때 해당 프로세스의 맥락(Context)을 복구해 작업이 순조롭게 이어질 수 있도록 한다. 

이 때 Context switch란 CPU 코어를 다른 프로세스가 사용하도록 하는 작업이며, 현재 프로세스의 state를 저장하고 다른(실행할) 프로세스의 state를 복구하는 작업이다. 

![[Pasted image 20250914005430.png]]
이 사진에서 "idle"이란, CPU가 쉬는 시간을 말하며 이 시간은 PCB에 현재 진행 상황을 저장하고, 다른 PCB를 불러와 그 PCB의 프로세스의 맥락을 복원하는 시간이다. 

따라서, 이 시간 동안에는 어떤 프로세스도 실행이 되지 않기 때문에 Context Switch 동안에는 비효율성을 유발할 수 있다. 

보통 Context switch에 걸리는 시간은 기기마다 각각 다르지만, 메모리가 얼마나 빠르냐에 달려 있고 typical한 속도는 보통 몇 마이크로초이다. 

----
## 중요한 단어
1. Process state
2. PCB(Process Control Block)
3. Context switch
4. Thread
5. Process scheduling