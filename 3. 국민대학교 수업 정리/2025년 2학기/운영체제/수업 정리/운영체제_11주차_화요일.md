---
tags:
  - Programming
  - 3학년_2학기
title: Deadlock (1)
---
## 학습 주제
1. System Model
2. Deadlock Characterization
3. Methods for Handling Deadlocks
4. Deadlock Prevention
5. Deadlock Avoidance

---
## 연관 수업
[[운영체제_9주차_화요일]]

---
## 강의 요약
이번 강의부터는 Synchronization이 아닌 Deadlock에 대하여 심층적으로 다룰 것이다. 
### System Model
**Deadlock**이란, 이름에서 알 수 있듯 좋지 않은 상황으로, 프로세스 X는 A라는 자원이 필요한 상태에서 B를 들고 있고 프로세스 Y는 B라는 자원이 필요한 상태에서 A를 들고 있어 서로 교착 상태에 빠진 상황을 의미한다. 

Deadlock은 다른 현상들보다 훨씬 더 심각한 상황으로, Mutual Exclusion은 진행할 수라도 있지만, Deadlock은 아예 실행도 안 되고 멈춰 버리는 상황이라 굉장히 프로그래밍적으로 피해야 하는 상황이다. 

유한한 개수의 자원이 존재하는 시스템이 있고, 몇 개의 Thread가 경쟁하고 있는 상황을 가정해 보자. 이 때, 자원이란 CPU Cycle, 파일, I/O 디바이스, 기타 접근 권한 등이 될 수 있다. 이 때 Thread들은 각 자원에 대해 요청을 하고, 요청을 하고 나서 권한을 획득해 사용한 뒤 해당 자원을 풀어줌으로 동작한다. 이를 **Request-Use-Release**라 한다. 

이를 코드 레벨에서 보여주면 다음과 같다. 
![[Pasted image 20251113022504.png]]

이 때, Deadlock이 일어날 수 있는데, 이는 Mutex의 순서가 반대로 설정되어 만약 두 작업이 동시에 실행될 경우, 서로가 서로 다른 자원에 대한 Mutex를 잡고 있어 둘 다 무한히 대기할 수 있다. 
(단, 실제 시간적인 순서 등의 이유로 100% 발생하지는 않을 수 있다.)

### Deadlock Characterization
위의 예시처럼, Deadlock은 다음과 같은 조건들이 전부 충족될 때 발생할 수 있다. 

- **Mutual Exclusion**
	- 적어도 한 개의 자원이 공유 불가능할 경우
	- 즉, 동기화(Synchronization)가 필요한 경우
- **Hold and Wait**
	- Thread가 적어도 하나의 자원을 가지고 있음
	- 동시에, 추가 자원을 가지기 위해 기다리고 있음
- **No preemption**
	- Preemptive한 작업이 CPU에서 일어나지 않을 경우
	- 즉, Thread가 자원을 CPU에 의해 뺏기지 않음
- **Circular Wait**
	- Thread 1은 자원 A를 원하고, 자원 A는 Thread 2한테 이미 할당
	- Thread 2는 자원 B를 원하고, 자원 B는 Thread 1한테 이미 할당
	- 원형의 형태로 Request와 Allocation이 발생하는 경우

Deadlock을 더 자세히 분석하기 위해, **Resource-Allocation Graph**라는 것을 사용하며 이 개념은 점과 선으로 이루어진 그래프로 자원의 할당과 요청을 나타낸 것이다. 

별 어려운 내용은 없는 그래프로, Thread를 나타내는 노드와 Resource를 나타내는 노드가 있으며, Thread가 Resource를 가리키는 화살표는 Thread가 해당 Resource를 요청하는 것이고 반대로는 Resource가 해당 Thread에 할당된 상태를 나타낸다. (하단 그림 참고)
![[Pasted image 20251113024135.png]]
위의 그림에서 $R_1$과 $R_3$는 Binary Semaphore이며, $R_2$는 General Semaphore이다. 즉, 하나의 자원이 꼭 하나에서만 사용되지 않을 수도 있다. 

그나저나, 또 다른 그림을 살펴보자. 
![[Pasted image 20251113024352.png]]
여기서는 사진의 간단한 설명처럼 두 개의 Cycle이 나타나는 것을 확인할 수 있으며, 해당 Cycle들 때문에 Deadlock이 발생할 수 있다. **(물론, Cycle이 있다고 해서 100% Deadlock은 아니다)**

### Methods for Handling Deadlocks
그렇다면, 어떻게 Deadlock에 관련한 문제를 처리할 수 있을까? 크게 세 가지로 이번 강의에서는 얘기해 볼 수 있다. 

1. Deadlock이 일어나지 않을 것이라고 가정하고 아예 무시하기
2. Deadlock이 일어나지 않게 예방하기
3. Deadlock이 발생한다 해도 피해가기 (Banker's Algorithm: [[운영체제_11주차_목요일|다음 시간]]에)

여기서 첫 번째 방법은 사실 딱히 권장하지는 않는 방법으로, CPU에서의 Preemptive한 처리 때문에 Deadlock이 발생하지 않을 수도 있지만, 100% 발생하지 않는다고 단정할 수도 없기 때문이다.

### Deadlock Prevention
2번째 방법인 **Deadlock Prevention**이란, Deadlock이 발생하기 위해 필요한 4가지 조건 중 하나라도 충족하지 않으면 Deadlock이 발생하지 않는다는 점을 이용한 방법이다. 

- Mutual Exclusion: 프로그램 간의 공유 자원을 사용하지 않는다는 것은 불가능한 방법
- Hold and Wait: 자원을 하나도 사용하지 않고 대기한다는 것은 거의 불가능한 방법
- No Preemption: No Preemption을 막는 것은 상당히 비효율적인 방법 (가능하긴 함)

위에서의 이유들로 인해, Circular Wait을 막는 것이 Deadlock Prevention을 위한 방법이 된다. 그렇다면, Circular Wait을 어떻게 방지할 수 있을까? 

해결 방법은 **Total Ordering**으로, 자원에 대해 순서를 매겨서 자원을 항상 오름차순이나 내림차순으로만 할당하게 해서 Cycle의 발생 확률 자체를 0으로 만드는 방법이다. (사진을 참고하자)
![[Pasted image 20251113030918.png]]

위의 경우, 높은 숫자의 자원을 낮은 숫자보다 먼저 획득하지 못하도록 강제해서 Cycle이 일어날 가능성 자체를 차단하는 효과가 있어 Deadlock이 이론적으로는 발생하지 않는다. 

그러나, Ordering으론 Deadlock을 100% 예방할 수는 없는데, 예를 들어 계좌에 실시간으로 송금 업무를 동시에 양쪽에서 진행할 경우(사진 참고), Deadlock이 발생할 수도 있다. 
![[Pasted image 20251113031152.png]]

### Deadlock Avoidance
위에서 설명했던 Deadlock Prevention의 또 다른 단점으로는 Low Device Utilization과 Reduced System Throughput이 있다. 이는 Prevention 과정에서 근본적인 것을 제한하기 때문이다. 

그래서 대안으로 나온 것이 **Deadlock Avoidance**로, 시스템이 자원 할당 요청을 받았을 때 무조건 자원을 할당받기 위해 대기를 하는 것이 아닌 Cycle이 생길지 먼저 판단하고 그 이후에 대기를 허락하는 것을 의미한다. 

예를 들어, Thread P가 $R_1$을 먼저 요청하고 $R_2$를 나중에 요청하며, Thread Q는 반대로 요청할 때, Q가 $R_2$를 요청하지 못하도록 차단한다. 따라서, Deadlock Avoidance는 이전의 정보를 바탕으로, Deadlock 상태에 들어갈 조짐만 보여도 바로 자원을 할당받지 못하도록 차단한다. 

이 개념의 구현을 위해, Safe state, Unsafe state, Deadlock 세 개의 state가 있다고 생각한다. ![[Pasted image 20251113032333.png]]
Deadlock은 Unsafe state 하위의 state로, Unsafe라 해서 100% Deadlock인 것은 아니다만 Deadlockd으로 들어갈 가능성이 존재는 하기 때문에 아예 Unsafe로 갈 가능성을 차단하는 것이 Deadlock Avoidance의 주요 개념이다. 

이를 위해 Request-Allocation Graph에서 새로운 Edge를 추가하는데, 바로 Claim Edge로, Thread가 어떤 자원을 미래에 요청할 것으로 생각되는 단계이다. 
이런 Claim Edge까지 보고 만약 Cycle이 발생할 것으로 의심되면, Request를 아예 허락하지 않는 식으로 동작해 Unsafe state까지도 가지 못하게 하며 Cycle이 발생하지 않는다고 판단하면 Request를 허락하는 방식으로 동작해 항상 Safe state에 머물러 있도록 한다. 

![[Pasted image 20251113032859.png]]
이 사진에서 $T_1$에서 $R_2$로 가는 Request는 수락해도 Cycle이 생기지 않아 문제가 없지만, $T_2$로 할당될 수 있는 $R_2$는 수락해 주면 나중에 Cycle이 생길 수 있어 Cycle이 발생하기 전까지는 허락하지 않는다. 

**이 때, Cycle의 판단 기준은 Claim edge까지 포함해서 판단한다.**

---
## 중요한 단어
1. Deadlock
2. Request-Use-Release
3. Hold and Wait
4. No preemption
5. Circular Wait
6. Resource-Allocation Graph
7. Deadlock Prevention
8. Total Ordering
9. Deadlock Avoidance