---
tags:
  - Programming
  - 3학년_2학기
title: Virtual Memory
---
## 학습 주제
1. Background
2. Demand Paging
3. Page Replacement

---
## 연관 수업
[[운영체제_12주차_화요일]]
[[운영체제_12주차_목요일]]

---
## 강의 요약
### Background
사실, 프로세스의 모든 부분을 항상 메모리에 올려두는 것 자체가 불가능하고, 가능하다 하더라도 용량의 문제로 그렇게 효율적이지도 않다. 
그래서, 우리가 메인 메모리에 모든 프로세스를 올려두기보다는 필요한 부분만 따로 빼서 메인 메모리에 올려놓고, 필요하지 않은 부분은 가상의 메모리인 **Virtual Memory**에 저장한다. 따라서, 우리는 Virtual memory를 어떻게 관리하고 어떻게 다룰 것인지에 대한 방법에 대하여 배울 것이다. 

![[Pasted image 20251127112830.png]]
이 사진을 참고하면 이해가 쉬워진다. 

Virtual memory는 memory map을 참고하며, virtual memory는 일단 찾는 데이터가 physical memory에 있든 **backing store**에 있든 기본적으로 프로세스의 메모리는 다 있다 가정한다. 

예를 들어 page 3을 찾고 싶다고 한다면 memory map을 뒤진다. 이때, memory map은 데이터가 physical memory에 있는지, 아니면 다른 곳에 있는지를 기억하고 있다. 

어쨌든, physical memory에 찾는 게 있다면 바로 쓸 수도 있지만, 없다면 backing store에서 가져와서 올리라고 할 수도 있다. 그런데, 올리면서 physical memory가 꽉 찰 수도 있기 때문에 오래 안 쓴 데이터나 최근에 썼어도 당장 필요한 것을 올리기 위해 뭔가를 내려야 하는 일이 필요할 수 있다. 따라서, 오늘 강의에서는 데이터를 올리거나 내리는 작업에 대해 배울 것이다. 

먼저, **Virtual Address Space**라는 것을 가지게 되며 Virtual Address Space에서 mapping이 되어 실제 physical memory로 변환이 이루어진다. 여기서 Virtual Address Space란 logical address와 비슷한 개념으로, 프로세스가 메모리에 어떻게 저장되어 있는지를 나타내며 주소 0부터 시작해 연속적으로 저장된다. 

따라서, 프로세스 내에서는 Virtual memory에 대해 virtual address space를 쓰다가 실제로 메모리에서 가져오면 **MMU(Memory Management Unit)** 가 처리를 해 주는 개념으로 이해하면 된다. 
(MMU에 대한 설명은 [[운영체제_12주차_화요일]] 강의를 참고하자)

### Demand Paging
첫 번째로 배울 기법은 **Demand Paging**이라는 기법이다. Demand paging은 말 그대로 요구 + paging이라는 의미로, 요구를 할 때 paging을 해 준다는 의미이다. 

Demand paging의 기본적인 개념은 프로세스가 실행되면, 어떤 페이지들은 메모리에 있고 어떤 페이지들은 secondary storage에 있을 것이다. 

이 때, 이 두 상황을 구분하기 위해 **valid-invalid bit**이라는 개념을 사용해 둘을 구분한다. 

- valid: page가 유효하면서 동시에 메모리 위에 적재되어 있는 상태
- invalid: page가 유효하지 않거나 유효해도 secondary storage에 적재되어 있는 상태

valid-invalid bit을 사용할 때는 1 또는 0을 사용해 다음 그림과 같이 사용한다. 
![[Pasted image 20251201010045.png]]

위의 상황에서 page A를 찾으려면 page table의 0번으로 가서 valid하다는 것을 알고, 해당 frame으로 가면 적재가 잘 되어 있다. 

반면, 1번, 즉 page B를 찾으려면 1번 페이지는 page table에서 invalid하다고 나와 있기 때문에 현재 physical memory에는 적재가 되어 있지 않다. 이런 경우에는 바로 physical memory를 참조하는 것이 아닌 backing store에서 1번에 해당하는 것을 physical memory에 적재를 시켜야 한다. 

이렇게 invalid bit를 만났을 때를 **page fault**라고 하며, 다음과 같이 해결한다. 

1. PCB 안의 정보들 중에서 페이지에 관한 정보를 찾아 유효한 메모리 접근인지 확인한다.
	1. 유효하지 않다면, 프로세스를 종료한다. 
	2. 유효하다면, backing store를 참조한다. 
2. 우선, free frame, 즉 physical memory 내의 빈 공간을 찾는다. 이 과정은 free-frame list라 하는 OS가 관리하는 리스트로 수행한다. 
3. Free frame이 존재할 경우, 해당 frame에 할당하고자 하는 page를 할당한다. 
4. 할당이 완료된 경우, 프로세스의 내부 테이블과 page table을 수정한다. 
	1. 목적: 어디에다가 올렸고, 이게 valid하다 공지하기 위해
5. 중단되었던 명령어를 재시작한다. 

다음 그림을 참고하자.
![[Pasted image 20251201011231.png]]

순수하게 아무 가정도 하지 않는다면, 모든 페이지를 메모리에 올리지 않은 상태에서 하나씩 채우는 방식으로 사용하지만, page fault가 너무 많이 일어나서 필수적인 것만 올리고 수행할 수 있다. 

만약 어떤 명령어에서 하나의 page를 원하고 데이터에서 여러 page를 원할 경우, page fault가 굉장히 많이 발생할 수 있다. 

그러나 실제로는 그렇게까지 많이 page fault가 발생하지 않으며, 이를 **Locality of Reference**라 한다. Locality of reference를 높이면 demand paging의 효율이 올라간다. 

다음 코드를 참고하자. 
```cpp
int i, j;
int[128][128] data;

// 첫 번째
for (j = 0; j < 128; j++) {
	for (i = 0; i < 128; i++) {
		data[i][j] = 0;
	}
}

// 두 번째
for (i = 0; i < 128; i++) {
	for (j = 0; j < 128; j++) {
		data[i][j] = 0;
	}
}
```

두 가지의 코드는 서로 같은 역할을 수행하지만, demand paging에서 더 빠른 것은 두 번째 코드인데, 이는 C언어에서 2차원 배열의 원소가 메모리에 어떤 순서대로 저장되는지 알면 쉽게 알 수 있는 문제로, 두 번째 코드가 page fault가 더 적게 일어난다. 

그 외에도 demand paging을 도와주는 세 가지 hardware적 support가 있다. 

- Page table
	- valid-invalid bit을 사용해 marking을 할 수 있는 능력
- Secondary memory
	- 메인 메모리에 적재되지 않은 page들이 존재할 다른 공간
	- 보통 고속 메모리나 NVM 디바이스 사용 (Memory와 계속해서 통신하는 특성)
- Instruction Restart
	- Demand paging에서 필수적인 요소
	- page fault가 일어날 시, 정보들을 전부 기억하고 있다 똑같은 상태로 재시작하기 위함
	- 연산을 실행하는 당시에 발생했다면 패칭을 다시 하면 됨
	- 연산을 실행하는 도중에 발생했다면 다시 처음부터 연산 실행 (약간의 비효율)

Demand paging을 하기 위해 backing store에 있는 page들을 physical memory에 적재하는 작업이 필요한데, 그러기 위해 physical memory에 빈 프레임들이 있어야 하며, 보통 그 리스트들은 OS가 관리한다. 

Free frame list는 linked list 형태로 저장된다. 

Demand paging의 performance를 수학적으로 분석해 보자. Demand paged memory에 대한 **Effective Access Time**은 다음과 같이 계산할 수 있다. 

$$EAT = (1-p)\times ma + p \times (page\ fault\ time)$$
- $p$: Page fault가 일어날 확률
- $ma$: 메모리 접근 시간

따라서, page fault를 처리하는 데는 page fault interrupt에 걸리는 시간 + 페이지를 읽어오는 시간 + 프로세스를 재시작하는 시간이 소요된다. 

### Page Replacement
여태까지는 demand paging 시 빈 프레임이 있다고 가정했지만, 만약 빈 프레임이 없을 경우, physical memory에 있는 page를 바꿔 주는 **Page Replacement**가 필요하다. 

Page replacement 시에는 page fault를 줄이는 방향으로 victim page를 정해야 한다. 

Page replacement 알고리즘은 여러 가지가 존재한다. 

- FIFO page replacement
	- 가장 먼저 온 것부터 replace하는 알고리즘
	- 예시에서는 15번의 page fault 발생![[Pasted image 20251201022333.png]]
	- frame 수를 늘렸는데도 page fault 횟수가 오히려 증가하는 **Belady's Anomaly** 현상이 생길 수 있음
- LRU page replacement
	- SRJF scheduling의 아이디어를 반영한 알고리즘
	- 마지막 사용이 가장 오래된 것부터 제거
	- 예시에서는 12번의 page fault 발생![[Pasted image 20251201022658.png]]
	- Optimal한 경우에는 미래를 알고 있다 가정하지만, 실제로는 과거만 알고 있기 때문
	- Counter를 사용하는 방법과 Stack을 사용하는 두 가지의 구현 방법이 존재
		- Counter: 각 페이지가 reference 될 때마다 카운터를 증가
		- Stack: 하나의 스택을 관리하며 가장 밑에 있는 것을 replace
	- 정확하게 측정하는 방법도 있으나, approximate하게 측정할 수도 있음 (0과 1 비트 사용)
- Second-Change algorithm
	- FIFO algorithm을 사용하긴 하나, reference bit를 조사하는 방법
		- bit가 0인 경우, 오래전에 들어왔고, 한 번도 사용되지 않았으므로 교체
		- bit가 1인 경우, 한 번은 사용되었다는 의미이므로 한 번의 기회를 더 주고 queue의 뒤로 보냄 (bit는 0으로 재설정)
		- 이해를 돕기 위한 사진![[Pasted image 20251201023534.png]]

한편, **Thrashing**이라는 현상이 있을 수 있는데, 이는 멀티 프로그래밍에서 충분한 page를 보유하고 있지 않을 경우, page fault의 비율이 급격하게 높아지는 현상을 의미한다. 

즉, 어떤 프로세스가 충분한 프레임을 보장받지 못해 계속해서 page fault가 일어나고, 그러다 보니 CPU의 사용 효율이 굉장히 떨어지게 되는 상황이다. 

이를 해결하기 위해 **Working-Set Model**이라는 개념이 사용된다. 
![[Pasted image 20251201031532.png]]

이는 어떤 기간 Δ 동안 reference된 page의 집합을 working set이라고 정의하며, working set에 있는 page들은 page replacement의 대상이 되지 않도록 하는 등으로 사용할 수 있다.

따라서, working-set model도 어떻게 보면 page replacement algorithm에서 사용할 수 있으며, 동시에 locality를 살리는 요소로도 쓸 수 있다.

---
## 중요한 단어
1. Virtual Memory
2. backing store
3. Virtual Address Space
4. MMU(Memory Management Unit)
5. Demand Paging
6. valid-invalid bit
7. Page fault
8. Locality of Reference
9. Page Replacement Algorithms
10. Belady's Anomaly
11. Thrashing
12. Working-Set Model