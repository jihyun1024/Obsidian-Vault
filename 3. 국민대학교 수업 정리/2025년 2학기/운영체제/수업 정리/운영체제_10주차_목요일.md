---
tags:
  - Programming
  - 3학년_2학기
title: Synchronization Examples (2)
---
## 학습 주제
1. Dining-Philosophers Problem
2. Possible Solutions to the Deadlock Problem
3. Monitor Solution
4. Solution to the Dining Philosophers Problem

---
## 연관 수업
[[운영체제_7주차]]
[[운영체제_9주차_화요일]]
[[운영체제_9주차_목요일]]
[[운영체제_10주차_화요일]]

---
## 강의 요약
저번 시간인 [[운영체제_10주차_화요일|10주차 화요일 강의]] 시간에 Bounded-Buffer Problem, Readers-Writers Problem에 대해 배웠다면, 이번 시간에는 **Dining-Philosophers Problem**, 즉 식사하는 철학자 문제에 대하여 공부할 것이다. 저번 시간에 공부한 내용들도 무슨 내용인지 설명할 수 있어야 한다. 
### Dining-Philosophers Problem
Dining-Philosophers Problem이란, 저녁 먹는 철학자들에 대해 다루는 문제로, 다음과 같은 상황을 가정한다. 

1. 다섯 명의 철학자들이 원형 식탁에 존재한다. 
2. 다섯 명은 각각 생각과 식사밖에 하지 않는다.
3. 원형 식탁에는 다섯 개의 젓가락이 철학자들 사이사이에 존재한다. 
4. 철학자가 배고파지면 그 사람 양 옆에 있는 젓가락들을 들려고 시도한다. 
5. 양 옆에 있는 젓가락들을 동시에 들고 있다면, 식사를 시작하며 젓가락은 식사가 끝날 때까지 놓지 않는다. 

이 상황은 여러 자원을 여러 프로세스에게 할당하는 문제와 동일한 상황이다. 

만약 모두가 동시에 왼쪽 젓가락을 집어든다면, 오른쪽 젓가락을 얻으려고 할 때 오른쪽 젓가락은 이미 그 사람 기준 오른쪽 사람이 가져간 상태이기 때문에 모든 사람들이 식사를 하지 못하게 되어 영원히 기다리는 Deadlock 상태에 빠질 수 있다. 

또한, A, B, C, D, E 순서대로 앉았을 때 A와 C가 젓가락을 들고 식사를 하고 있다면 B는 젓가락을 하나도 들 수 없어 계속 기다리고만 있는 Starvation 상태에 들어갈 수 있다. 

따라서, 이 문제에서는 Deadlock과 Starvation을 어떻게 해결하는지가 중요하다 할 수 있다. 물론, 어찌저찌 실행은 되는 Starvation 상태와는 달리 Deadlock 상태는 아무 것도 실행되지 않기 때문에 solution들은 보통 Deadlock-Free에 초점을 둔 경우가 많다. 

먼저, 간단하게 **Semaphore Solution**에 대해 생각해 보자. Semaphore는 공유 자원, 즉 젓가락에 거는 것이고, 젓가락은 한 사람이 사용하고 있다면 다른 사람은 사용하지 않는 것이기 때문에 Binary semaphore를 걸 수 있다. 
![[Pasted image 20251125044247.png]]
이 경우, `i`번째 젓가락과 `i + 1`번째 젓가락을 사용할 때는 `wait()`을 걸어서 신호를 주고, 음식을 먹고 난 뒤에는 `signal()`을 걸어서 자원을 반환해 주면 적어도 Mutual Exclusion을 이룰 수 있다. 단, 모두가 젓가락을 요구할 때는 Deadlock 상황이 발생할 수 있다. 
따라서, 단순히 Semaphore만 건다고 해서 이 문제를 해결할 수 있는 것은 아니다. 

### Possible Solutions to the Deadlock Problem
그렇다면, 어떻게 Deadlock을 방지할 수 있을까? 대표적으로 간단하게 3개의 방법이 존재한다. 

1. 최대 4명만 테이블에 앉아 있을 수 있도록 하기
2. 젓가락 두 개가 동시에 사용 가능할 때만 젓가락을 들어 올릴 수 있도록 하기
3. 비대칭적 Solution: 홀수 번째 사람은 왼쪽을 먼저, 짝수 번째 사람은 오른쪽을 먼저

1번 방법은 가장 간단한 방법으로, 마지막 한 명은 무조건 두 젓가락을 다 잡을 수 있으며 2번 방법은 각각의 젓가락에 대한 Mutex나 Semaphore를 가지고 동기화를 잘 해야 한다. 

사실, Deadlock-free solution들은 Starvation의 가능성을 완전히 제거하지는 못한다.

### Monitor Solution
철학자들이 각각 왼쪽과 오른쪽 젓가락이 전부 사용 가능할 때만 젓가락을 사용하게 하는 방법으로 **Monitor Solution**이 있다. 이 개념을 이해하기 위해서는 [[운영체제_9주차_화요일#Monitors|Monitor]]의 개념에 대해 자세히 알고 있어야 하기 때문에, 링크되어 있는 수업을 참고하자. (물론, 여기서도 다룰 것이다)

Monitor를 적용하기 위해서 철학자들의 배고픔 상태를 Thinking, Hungry, Eating의 세 단계로 나눈다. 이는 각각 밥 생각이 없는 상태, 밥을 먹을 생각을 하는 상태, 밥을 먹고 있는 상태이다. 

또한, 한 사람이 밥을 먹고 있다면 그 옆의 두 사람은 밥을 먹지 않는 상태여야만 한다. 
이를 구현하기 위해 **Condition Variable**, 즉 공유 자원을 쓰기 위한 조건 변수를 설정해 이 조건 변수가 만족되지 못하면 자원을 사용할 수 없게 하는 식으로 구현한다. 

먼저, monitor에 대해 복습을 하고 가자. monitor란 Shared Data를 건드리는 여러 상황에 대해 각각의 상황을 함수화 시켜 놓은 것으로, High-level Synchronization Tool에 해당한다. 

### Solution to the Dining Philosophers Problem
이제 Dining-Philosophers Problem을 풀기 위해 monitor를 사용할 것이다.

각각의 철학자는 배고픈 경우, 식사를 하기 전에 `pickup()`이라는 함수를 통해 양쪽 젓가락을 들 수 있는 상태인지 확인하고 들 수 없다면 기다리며, 양쪽 젓가락을 들 수 있다면 사용한 뒤 `putdown()` 함수를 통해 젓가락을 내려놓고 양 옆의 사람들에게 젓가락을 쓸 것인지 물어볼 수 있다. 

이 코드를 보자. ![[Pasted image 20251125053643.png]]
먼저 다섯 명의 상태를 정의한 후, Condition Variable인 `self`를 선언해 Condition Variable을 얻어야만 공유 자원에 접근할 수 있다. 

배가 고프다면 `pickup()`을 선언해 상태를 '배고픔'으로 바꾼 뒤 `test()`를 실행한다. 
`test()`에서 `if`문은 자기 왼쪽과 오른쪽 사람이 전부 `EATING` 상태가 아니고 자신의 상태가 `HUNGRY`라면 자신의 상태를 `EATING`으로 바꾸고 `signal()`을 사용해 자원을 사용한다. 

이후, 자신의 상태가 `EATING`이 아니라면 = 다 먹고 나면 condition variable인 `self`를 `wait()`으로 돌려 놓는다. 

`putdown()`은 내가 밥을 다 먹고 내려 놓는 상태로, `THINKING` 상태로 바꿔 놓은 뒤 왼쪽 사람과 오른쪽 사람이 기다리고 있었을 수도 있으니 `test`를 그 두 사람에게 실행해서 기다리고 있었다면 젓가락을 준다. 

pthread를 사용하면 다음과 같다. 
```cpp
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>

#define true 1
#define NUM_PHILS 5

enum {THINKING, HUNGRY, EATING} state[NUM_PHILS];

pthread_mutex_t mutex_lock;
pthread_cond_t cond_vars[NUM_PHILS];

void init() {
	for (int i = 0; i < NUM_PHILS; i++) {
		state[i] = THINKING;
		pthread_cond_init(&cond_vars[i], NULL);
	}
	
	pthread_mutex_init(&mutex_lock, NULL);
	srand(time(0));
}

// 왼쪽 사람
int leftOf(int i) {
	return (i + NUM_PHILS - 1) % NUM_PHILS;
}

// 오른쪽 사람
int rightOf(int i) {
	return (i + 1) % NUM_PHILS;
}

// 시간만 쓰는 함수 2개
void think(int id) {
	printf("%d: Now, I'm thinking...\n", id);
	usleep((1 + rand() % 50) * 10000);
}

void eat(int id) {
	printf("%d: Now, I'm eating...\n", id);
	usleep((1 + rand() % 50) * 10000);
}

// 철학자가 할 행위
void *philosopher(void *param) {
	int id = *((int *)param);
	while (true) {
		think(id);
		pickup(id);
		eat(id);
		putdown(id);
	}
}

// 양 옆이 먹고 있는지 + 내가 배고픈지 확인, 먹을 수 있을 경우 먹음
void test(int i) {
	if (state[i] == HUNGRY && state[leftOf(i)] != EATING && state[rightOf(i)] != EATING) {
		state[i] =  EATING;
		pthread_cond_signal(&cond_vars[i]); // 이제 먹어도 된다고 신호 전송
	}
}

// 배고플 경우 실행, 먹을 수 있는지 확인 및 아니라면 대기
void pickup(int i) {
	// state가 공유 자원이기 때문에 mutex를 걸어 동기화가 필요함
	pthread_mutex_lock(&mutex_lock);
	
	state[i] = HUNGRY;
	test(i);
	while (state[i] != EATING) {
		// 먹을 수 없는 상태인 경우, 조건이 만족될 때까지 mutex lock을 잠시 반납
		// 이는 먹고 있지 않을 경우, 젓가락을 양보하는 것과 비슷함
		pthread_cond_wait(&cond_vars[i], &mutex_lock);
	}
	
	pthread_mutex_unlock(&mutex_lock);
}

// 밥을 다 먹고 젓가락을 내려놓을 경우 -> 이 경우도 mutex 사용
void putdown(int i) {
	pthread_mutex_lock(&mutex_lock);
	
	state[i] = THINKING;
	test(leftOf(i));
	test(rightOf(i));
	
	pthread_mutex_unlock(&mutex_lock);
}
```

---
## 중요한 단어
1. Dining-Philosophers Problem
2. Semaphore Solution
3. Monitor Solution
4. Conditional Variables
