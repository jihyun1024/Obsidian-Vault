---
tags:
  - Programming
  - 3학년_2학기
title: Deadlock (2)
---
## 학습 주제
1. Deadlock Avoidance
2. Deadlock Detection
3. Recovery from Deadlock

---
## 연관 수업
[[운영체제_9주차_화요일]]
[[운영체제_11주차_화요일]]

---
## 강의 요약
[[운영체제_11주차_화요일|저번 시간]]에 이어 Banker's Algorithm부터 다뤄서 Deadlock에 대해 공부할 것이다. 
### Deadlock Avoidance
**Banker's Algorithm**이란 Deadlock avoidance에 사용되는 대표적인 알고리즘으로, 프로세스들이 최대 필요 자원을 미리 선언한다고 가정해 놓고, 현재 상태에서 어떤 자원 요청을 허용했을 때 시스템이 여전히 안전한지를 검사한다. 

이 때 "안전한 상태"란, 어떤 순서(안전 시퀀스)가 있어서 각 프로세스가 차례대로 끝날 수 있고, 그 과정에서 Deadlock이 발생하지 않는 상태이다. 

Data structure에 대해 정리해 보자. 

- $n$: 시스템의 thread의 개수
- $m$:  자원의 종류의 개수
- $Available[m]$: 각 자원 종류별로 사용 가능한 인스턴스의 개수
	- $Available[j] == k$인 경우, $j$라는 자원에 대하여 $k$개의 인스턴스가 사용 가능
- $Max[n \times m]$: Thread 당 최대 필요로 하는 자원의 개수
- $Allocation[n \times m]$: 각 thread 당 현재 할당되어 있는 자원의 개수
	- $Allocation[i][j] == k$인 경우, thread $i$에 대해 $j$라는 자원에 대하여 $k$개의 인스턴스 할당
- $Need[n \times m]$: $Max - Allocation$과 동일하며, 남은 필요량 (Thread가 끝나기 위해 추가로 필요한 자원의 양)
	- $Need[i][j] == k$인 경우, thread $i$에 대해 $j$라는 자원에 대하여 $k$개의 인스턴스 필요

이를 참고하여 **Safety Algorithm**에 대해 알아보자. 

Safety algorithm이란, 말 그대로 "현재 상태가 안전한가?"를 판단하는 알고리즘으로 다음 사진과 같이 실행된다. 
![[Pasted image 20251201170538.png]]
이때, 안전성 검사는 자원 요청 전에 수행한다.

이후, 자원 요청에 대한 처리를 담당하는 동시에 추가로 할당했을 때도 여전히 Safe한 상태인지 판단하는 **Resource Request Algorithm**을 다음과 같이 수행한다. 
![[Pasted image 20251201170733.png]]
이 알고리즘에서 요청은 단순히 $Available$이 충분하다는 것 뿐만 아니라, 허용했을 때의 전체 시스템 상태가 안전해야만 승인된다.

따라서, Safety algorithm은 Resource request algorithm을 포함하고 있다 이해하면 될 것이다.

예시를 들면서 알아보자. 
![[Pasted image 20251201171549.png]]
다음과 같이 $T_0, T_1, T_2, T_3, T_4$ 다섯 개의 thread가 있고, $A, B, C$ 세 개의 자원 타입, 각각의 자원 타입마다 $A = 10, B = 5, C = 7$로 최대치가 있다고 해 보자. 

먼저, $Need$를 각각 계산해 보면 다음과 같다. 

- $Need[T_0] = [7 - 0, 5-1, 3-0] = [7, 4, 3]$
- $Need[T_1] = [3-2, 2-0, 2-0] = [1, 2, 2]$
- $Need[T_2] = [9-3, 0-0, 2-2] = [6, 0, 0]$
- $Need[T_3] = [2-2, 2-1, 2-1] = [0, 1, 1]$
- $Need[T_4] = [4-0, 3-0, 3-2] = [4, 3, 1]$

이제 Safety Algorithm을 수행하면 다음과 같다. (단, CPU Scheduling은 고려하지 않는다)

초기:
- $Work = Available = [3, 3, 2]$
- $Finish = [F, F, F, F, F] (P0...P4)$
	
1. 어떤 프로세스 $i$에 대해 $Need[i] \leq Work$ 인지 확인(모두 타입별 비교).
	- $P0$: $Need [7,4,3]$ vs $Work [3,3,2]$ → 7 ≤ 3 ? 아니므로 불가.
	- $P1$: $Need [1,2,2]$ vs $Work [3,3,2]$ → 1 ≤ 3, 2 ≤ 3, 2 ≤ 2 → **모두 만족**.  
    → $P1$을 선택할 수 있음.

실행 $P1$:
- $Work = Work + Allocation[P1] = [3,3,2] + [2,0,0] = [5,3,2]$
- $Finish[P1] = true$
- 안전 시퀀스(일부분): ⟨P1, ...⟩
	
1. 계속:
	- $P0: Need [7,4,3] vs Work [5,3,2]$ → 7 ≤ 5 ? 아니므로 불가.
	- $P2: Need [6,0,0] vs Work [5,3,2]$ → 6 ≤ 5 ? 아니므로 불가.
	- $P3: Need [0,1,1] vs Work [5,3,2]$ → 0 ≤ 5, 1 ≤ 3, 1 ≤ 2 → **모두 만족**.  
    → $P3$ 선택.

실행 $P3$:
- $Work = [5,3,2] + Allocation[P3]([2,1,1]) = [5+2, 3+1, 2+1] = [7,4,3]$
- $Finish[P3] = true$
- 시퀀스: ⟨P1, P3, ...⟩
    
1. 반복:
	- $P0$: $Need [7,4,3] vs Work [7,4,3]$ → 7 ≤ 7, 4 ≤ 4, 3 ≤ 3 → **만족**.  
    → $P0$ 선택.

실행 $P0$:
- $Work = [7,4,3] + Allocation[P0]([0,1,0]) = [7, 5, 3]$
- $Finish[P0] = true$
- 시퀀스: ⟨P1, P3, P0, ...⟩
    
1. 남은 $P2, P4$ 확인:
	- $P2: Need [6,0,0] vs Work [7,5,3]$ → 6 ≤ 7, 0 ≤ 5, 0 ≤ 3 → **만족**.  
    → $P2$ 선택.

실행 $P2$:
- $Work = [7,5,3] + Allocation[P2]([3,0,2]) = [10,5,5]$
- $Finish[P2] = true$
- 시퀀스: ⟨P1, P3, P0, P2, ...⟩
    
1. 마지막 $P4$:
	- $P4: Need [4,3,1] vs Work [10,5,5]$ → 4 ≤ 10, 3 ≤ 5, 1 ≤ 5 → **만족**.
	- $Finish[P4] = true$
	- $Work$ 갱신(더 이상 필요 없음)

결과:
- 모든 $Finish$가 `true` → **안전 상태**.
- 하나의 안전 시퀀스는 ⟨P1, P3, P0, P2, P4⟩ (또는 순서가 바뀔 수 있음 — 위에서 실제로 도출한 순서는 ⟨P1, P3, P4, P0, P2⟩ 또는 ⟨P1,P3,P0,P2,P4⟩ 등, 검사 중 선택에 따라 다를 수 있음).  
    (위 계산에서 한 단계마다 어떤 프로세스를 선택했는지 정확히 적어둔 순서가 안전 시퀀스)
    

> 요약: 위 상태에서 Banker's 알고리즘의 안전성 검사 결과 **안전** 이므로, 어떤 프로세스가 현재 추가 자원을 요청했을 때도 위 절차대로 시험-검사해서 안전이면 허용한다.

사실, Deadlock avoidance는 모든 프로세스가 자신의 최대 요구량을 사전에 알고 있어야 하는 제한이 있기도 하고, 처리와 반복만 계속 수행하기 때문에 완벽한 알고리즘은 아니다. 

따라서, Deadlock을 대처하기 위해 밑에서 배울 **Deadlock Detection**을 더 많이 사용한다.

### Deadlock Detection
Deadlock detection이란, 만약 시스템이 deadlock을 prevent하지 못했거나 avoid하지 못했을 경우 발생하는 것으로, 해당 시스템에서는 중간중간 deadlock이 발생했는지 판단할 수 있는 algorithm과 deadlock을 recover할 수 있는 algorithm을 제공한다. 

단일 인스턴스에 대해서는 **Wait-for Graph**라는 개념이 나오는데, 이 개념은 thread 간 wait 관계만 남기고 나머지 resource는 제외한 그래프로, 왼쪽 그림이 일반 그래프라면 오른쪽 그림이 wait-for graph에 해당한다. 
![[Pasted image 20251201174633.png]]
위의 상황에서는 cycle이 2개가 보이는 것을 알 수 있으며, 따라서 2개의 deadlock 후보가 존재하는 것을 확인할 수 있다. 

한편, 다중 인스턴스 자원에 대한 Detection algorithm에서는 banker's algorithm을 기반으로 하지만, "안전성 검사"가 아니라 정반대로 "모두 $Finish = false$인 thread 집합"이 남아 있는지 찾는 알고리즘을 사용한다. 

이를 위의 deadlock avoidance에서 나온 개념을 참고해서 살펴보면 다음과 같다. 
![[Pasted image 20251201174944.png]]

이를 참고해서 다음의 상황을 살펴보자. 
![[Pasted image 20251201175053.png]]

이 사진의 상황에서는 정상 동작할 경우는 다음과 같으며, ![[Pasted image 20251201175226.png]]
Deadlock이 일어날 경우는 다음과 같다.![[Pasted image 20251201175213.png]]

Deadlockd을 찾았다면, Deadlock이 발생한 상태에서 원래 상태로 복구하는 **Recovery from Deadlock**이 사용된다. 

### Recovery from Deadlock
Deadlock이 발생한 상태로부터 정상 상태로 북구하는 방법에는 다음 세 가지 정도가 존재한다. 

- **Resource Preemption**
	- 강제로 어떤 프로세스에서 자원을 빼앗아 와 deadlock의 cycle을 끊는 방식
- **Process and Thread Termination**
	- 다소 단순한 방법
	- Deadlock 상태에 있는 프로세스를 전부 종료하는 방식
	- 또는 프로세스를 하나씩 종료해 보며 deadlock의 cycle만을 끊는 방식
- **Rollback**
	- Snapshot과 비슷한 기능으로, 시스템의 상태를 미리 백업해 놓음
	- 프로세스를 deadlock 이전의 safe state로 되돌리고 나서 재시작하는 방식

---
## 중요한 단어
1. Banker's Algorithm
2. Safety Algorithm
3. Resource Request Algorithm
4. Deadlock Detection
5. Recovery from Deadlock
6. Process and Thread Termination
7. Resource Preemption
8. Rollback