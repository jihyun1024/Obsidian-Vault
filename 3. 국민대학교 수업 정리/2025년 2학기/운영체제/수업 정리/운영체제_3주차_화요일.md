---
tags:
  - Programming
  - 3학년_2학기
---
## 학습 주제
1. Multitasking in Mobile Systems
2. Android Process Importance Hierarchy
3. Process Creation
4. Process Termination
5. Operations on Processes (C language)
6. Interprocess Communication

---
## 이전 수업
[[운영체제_2주차_목요일]]

---
## 강의 요약
저번 강의인 [[운영체제_2주차_목요일]] 강의에서 이어진다.

### Multitasking in Mobile Systems
iOS의 초기 버전 등 일부 모바일 시스템에서는 오직 하나의 프로세스만 동작하며, 나머지는 대기 상태로 실행을 기다린다. 

또한, 실제 화면 공간의 제약으로 인해 iOS가 제공하는 사용자 인터페이스에는 한계가 있다. 
- 단일 foreground 프로세스: 유저 인터페이스를 통해 제어된다. 
- 다중 background 프로세스: 메모리 내에서 실행 중이지만 화면에 표시되지 않으며, limit가 적용된다.
	- 해당 limit에는 단일, 단기 task, 이벤트 알림 수신, 특정한 장기 실행 작업(예시: 오디오 백그라운드 실행) 등이 포함된다.

Android는 더 적은 제한(limit)으로 foreground와 background에서 실행된다. 
- 백그라운드 프로세스는 작업을 수행하기 위해 **서비스**를 사용한다. 
	- 이 서비스는 백그라운드 프로세스가 중지된 상태에서도 계속 실행 가능하다.
	- 서비스는 사용자 인터페이스가 없으며, 메모리 사용량이 적다. 

### Android Process Importance Hierarchy
모바일 운영체제는 시스템 자원(메모리 등)을 회수하기 위해 프로세스를 종료해야 하는 경우가 있다. 

중요도 순으로 위에서부터
- Foreground process
- Visible process
- Service process
- Background process
- Empty process
로 나열되며, Android는 중요도가 가장 낮은 프로세스부터 종료한다. 

### Process Creation
프로세스는 여러 개의 새 프로세스를 생성할 수 있으며, 프로세스를 생성한 프로세스는 **parent(부모) process**라 하며, 생성된 프로세스는 **child(자식) process**라고 한다. 

parent process는 child process를 생성하며, 이 child process들은 프로세스 **트리**를 형성하고 일반적으로 프로세스들은 **process identifier(pid, 프로세스 식별자)** 를 통해 식별 및 관리된다. 

대표적으로, Linux에서 프로세스 트리는 다음과 같다. ![[Pasted image 20250918154251.png]]

부모 프로세스는 자식 프로세스와 동시에 계속 실행되며, parent process는 child process들이 전부 또는 일부 terminated 될 때까지 계속 대기한다.

주소 공간 관점에서 child process는 parent process의 복제본이며, child process에는 parent process에서 새로 로드된 프로그램이 있다. 

자원 공유 옵션으로는 세 가지가 있다. 
1. child와 parent가 모든 자원을 공유하는 경우
2. child는 parent의 일부 자원을 공유하는경우
3. child와 parent가 아무 자원도 공유하지 않는경우

UNIX 시스템을 예시로 들어 Process Creation을 이해할 수 있다. 
- `fork()`: 시스템 호출로, 새 프로세스를 생성한다.
- `exec()`: `fork()` 이후에 사용되는 시스템 호출로, 프로세스의 메모리 공간을 새로운 프로그램으로 대체하기 위해 사용한다.
- `wait()`: parent가 `wait()`를 호출하며, child가 terminate 될 때까지 대기한다.

```cpp
#include <stdio.h>
#include <unistd.h>
#include <wait.h>

int main() {
	pid_t pid;
	
	// fork a child process
	pid = fork();
	
	// fork가 실패한 경우
	if (pid < 0) {
		fprintf(stderr, "Fork Failed");
		return 1;
	} 
	// pid == 0은 해당 프로세스가 child라는 것을 의미한다.
	else if (pid == 0) {
		// child 프로세스의 메모리 공간을 대체
		execlp("/bin/ls", "ls", NULL);
	}
	// pid > 0은 해당 프로세스가 parent라는 것을 의미한다.
	else {
		wait(NULL);
		printf("Child Complete");
	}
	
	return 0;
}
```
위의 코드는 parent에서 `fork()`를 실행하고 child에서 `exer()`를 실행하며, parent에서는 child에서의 이 작업이 끝나기를 기다리는 것을 수행하는 C언어 코드이다. 

이를 사진으로 표시하면 다음과 같다. ![[Pasted image 20250918154203.png]]

### Process Termination
프로세스는 해당 프로세스의 마지막 명령을 실행한 후에 운영체제에 `exit()` 시스템 호출을 사용해 프로세스를 삭제하도록 요청한다. 이 과정에서 child에서 parent로 `wait()`를 통해 종료 당시의 상태 데이터를 반환하며, 프로세스의 자원은 OS에 의해 할당 해제된다. 

parent는 `abort()` 시스템 호출을 사용해 child의 실행을 종료할 수 있는데, 이 호출이 사용되는 상황은 다음과 같다. 
- child process가 그것에 할당된 자원의 양을 초과하는 경우
- child에게 할당된 작업이 더 이상 필요 없을 경우
- OS는 parent가 종료 중일 때 child가 계속 실행되는 것을 허용하지 않음
	- 프로세스가 종료되면, 그 child도 반드시 종료되어야 한다.
	- 이를 **cascading termination**이라 하며, 모든 자식, 손자, 증손자 프로세스 등등이 종료된다.
	- 이 종료는 OS에 의해 관리된다.

앞에서 봤듯이 parent는 child의 종료를 기다리기 위해 `wait()`를 호출하며, 이 시스템 호출은 상태 정보와 종료된 프로세스의 pid를 반환한다. (`pid = wait(&status)`)

또한, 특이한 상태의 프로세스가 있는데, Zombie와 Orphan이다. 
- Zombie process: 프로세스는 terminate 되었지만, 그 프로세스의 parent는 아직 `wait()`를 호출하지 않은 것
	- child가 작업을 완료하면 OS는 즉시 제거하지 않고, 대신 프로세스 ID, 종료 상태 등의 소량의 정보만 보유하게 해 나중에 parent가 이를 줍줍하게 한다. 
	- parent는 `wait()`를 호출해 이 정보를 "수확"하고 프로세스 테이블 항목을 완전히 free해야 한다. 
	- 만약 parent가 zombie를 수집하지 못하고 대신 수많은 child를 생성 및 종료하면, 프로세스 테이블이 가득 차서 새로운 프로세스의 생성을 막게 된다.
- Orphan process: 프로세스의 parent 프로세스가 있지만, 그 parent는 `wait()`를 호출하지 않은 상태에서 terminate 되어 child 혼자 덩그러니 남겨진 것
	- 이런 orphan들로 인해 시스템이 복잡해지는 것을 막기 위해 init process(pid = 1)가 이 orphan들을 "입양"한다. 
	- init process는 모든 orphan들에 대한 책임을 지며, 이들을 적절하게 처리해 zombie가 되는 것을 방지한다. 

한 편, UNIX 계열 운영체제에서는 
- 새로운 프로세스는 `fork()`에 의해 생성되며, 
- child는 parent의 주소 공간 복사본으로 구성된다. 
- child와 parent는 모두 `fork()`이후의 명령어에서 실행을 계속한다. 
	- child에서는 `fork()`의 반환 코드가 0이지만, 
	- parent에서는 `fork()`의 반환 코드가 0이 아닌 child의 pid이다. 
	- 이 때, `fork()`의 반환 코드는 `getpid()`로 얻는다. 

### Operations on Processes (C language)
몇 개의 예제로 여태껏 배웠던 것을 복습해 보자. 

예제 1. 이 코드에서 `LINE A`의 Output은 얼마일까?
```cpp
#include <stdio.h>
#include <unistd.h>
#include <wait.h>

int value = 5;

int main() {
	pid_t pid;
	pid = fork();
	
	if (pid == 0) 
		value += 15;
		return 0;
	}
	else if (pid > 0) {
		wait(NULL);
		printf("Parent: value = %d\n", value); // LINE A
	}
}
```
정답은 5로, `fork()` 이후 parent와 child는 서로 다른 메모리 공간을 가지기 때문에 child에서 `value`를 20으로 바꿔도 parent에는 영향을 주지 않는다. 
따라서, child는 pid = 0이고, parent는 pid > 0이기 때문에 `LINE A`에서의 Output은 5가 된다. 

예제 2. 이 코드에서 얼마나 많은 프로세스가 생성되는가?
```cpp
#include <stdio.h>
#include <unistd.h>
#include <wait.h>

int main() {
	fork();
	fork();
	fork();
	
	return 0;
}
```
정답은 8개로, `fork()`는 한 번 호출하면 현재 실행 중인 모든 프로세스가 복제된다. 이는 [[운영체제_3주차_화요일#Process Creation|Process Creation]] 단원에서 배웠던 것으로, 호출할 때마다 프로세스 개수가 두 배로 늘어나 $2^3 = 8$개의 프로세스가 생성된다. 
즉, 처음에는 parent 단 1개, 첫 번째 `fork()`에서는 총 2개, 두 번째 `fork()`에서는 총 4개, 세 번째 `fork()`에서는 총 8개 이런 식이다. 

예제 3. 이 코드에서 언제 `LINE J`로 도달할 수 있을까?
```cpp
#include <stdio.h>
#include <unistd.h>
#include <wait.h>

int main() {
	pid_t pid;
	pid = fork();
	
	if (pid == 0) {
		execlp("/bin/ls", "ls", NULL);
		printf("LINE J\n");
	}
	else if (pid > 0) {
		wait(NULL);
		printf("Child Complete\n");
	}
	
	return 0;
}
```
정답은 `execlp()`가 실패하지 않는 한, 절대 출력되지 않는다. 
이는 `execlp()`의 동작에 기반한 것으로, `execlp()`는 현재 프로세스를 새로운 프로그램으로 덮어쓴다. 즉, 성공하면 **기존 코드로는 절대 되돌아오지 않는다.** 따라서, `printf("LINE J\n");`은 실행되지 않으며, parent는 child가 끝날 때까지 기다려 자식이 `ls` 실행을 마치고 종료하면 `printf("Child Complete\n");`을 실행한다. 
만약 `/bin/ls` 파일이 없거나 권한 문제 등의 오류로 `execlp`가 실패한다면, `execlp`는 -1을 반환하고 `printf("LINE J\n");`이 실행된다. 

예제 4. 이 코드에서 어떤 값이 출력될까? 
```cpp
#include <stdio.h>
#include <unistd.h>
#include <wait.h>

int main() {
	pid_t pid, pid1;
	pid = fork();
	if (pid == 0) {
		pid1 = getpid();
		printf("Child: pid = %d\n", pid); // A
		printf("Child: pid1 = %d\n", pid1); // B
	}
	else if (pid > 0) {
		pid1 = getpid();
		printf("Child: pid = %d\n", pid); // C
		printf("Child: pid1 = %d\n", pid1); // D
	}
}
```
정답은 [[Cygwin]]에서 실행하여 보면
```
Child: pid = 0
Child: pid1 = 1637
Child: pid = 1637
Child: pid1 = 1636
```
으로 결과가 나왔다. 
이는 parent가 child가 끝날 때까지 기다리기 때문에 가능한 것으로, 먼저 `fork()`로 child를 생성한다. 그 뒤 child와 parent가 동시에 실행되며, terminate 되면 [[운영체제_3주차_화요일#Process Termination|Process Termination]] 단원에서 공부한 것처럼 child는 `fork()`의 반환값으로 0을, parent는 `fork()`의 반환값으로 child의 pid를 반환한다. 
또한, `getpid()`는 현재 실행 중인 프로세스의 pid를 반환하여 parent와 child에서 서로 다른 값이 나온다. 
따라서, 출력을 해석해 보면 다음과 같다. 
- child 프로세스 pid 반환
	- A: pid = 0
	- B: pid1 = (child pid)
- parent 프로세스 pid 반환
	- C: pid = (child pid) -> 이미 child의 실행을 끝냈기 때문에 child의 pid 반환
	- D: pid1 = (parent pid)
내가 실행했던 Windows(Cygwin을 통해 Linux를 구현했음) 환경에서는 parent pid = 1636, child pid = 1637이었기 때문에 위와 같은 값이 나왔다. 

예제 5. 이 코드에서 `LINE X`와 `LINE Y`에서 어떤 출력이 나올까?
```cpp
#define SIZE 5

#include <stdio.h>
#include <unistd.h>
#include <wait.h>

int nums[SIZE] = {0, 1, 2, 3, 4};

int main() {
	pid_t pid;
	pid = fork();
	
	if (pid == 0) {
		for (int i = 0; i < SIZE; i++) {
			nums[i] *= i;
			printf("CHILD: %d\n", nums[i]); // LINE X
		}
	}
	else if (pid > 0) {
		wait(NULL);
		for (int j = 0; j < SIZE; j++) {
			printf("PARENT: %d\n", nums[i]); // LINE Y
		}
	}
	
	return 0;
}
```
정답은 `CHILD` 배열은 `{0, 1, 4, 9, 16}`, `PARENT` 배열은 `{0, 1, 2, 3, 4}`로 각각 다르게 출력된다. 
이는 child와 parent는 각각 동일한 상태를 복사해서 가지나, 메모리 공간은 서로 공유하지 않기 때문에 child에서 바꾼 배열 값이 parent에서 반영되지 않기 때문이다. 

예제 6. 다음 사진에 적절한 답이 뭘까?
![[Pasted image 20250918174813.png]]
정답은 의외로 `c`로, 풀이 과정은 다음과 같다. 
`fork()` 호출 시 parent의 주소 공간은 child에게 복사된다. 이 과정에서 Stack 영역과 Heap 영역이 복사되며, 이 공간들은 child가 변경해도 위의 예제 5처럼 parent에게 반영되지 않는다. 이는 기본적으로 **parent와 child가 메모리를 공유하지 않기** 때문에 일어나는 것이다. 
그러나, Shared memory segment는 아예 공유 메모리 영역(예: `shmget()`으로 만든 것)이기 때문에, parent와 child가 동일하게 접근 가능하다.

이 예제들에서도 알겠지만, 복습이 정말정말 중요하다...
그러니 복습을 열심히 하자.
### Interprocess Communication
[[운영체제_3주차_목요일]] 시간에 연속해서 다룰 것이다.

---
## 중요한 단어
1. 서비스
2. parent/child process
3. process creation/termination
4. pid (process identifier)
5. system call (`fork, exec, wait, exit, abort`)
6. cascading termination
7. zombie & orphan process