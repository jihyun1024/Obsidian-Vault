---
tags:
  - 암호학
  - Programming
  - 3학년_2학기
title: 인증 및 보안 프로토콜 (2)
---
## 학습 주제
1. OpenSSL 암호화 프로그래밍
2. 일회용 비밀번호 기법 (이론)

---
## 연관 수업
[[5주차 수업]]

---
## 강의 요약
이번 시간에는 저번 [[5주차 수업|5주차 수업]]에서 다룬 내용을 복습하고, 다른 내용을 추가로 더 배운다. 
### OpenSSL 암호화 프로그래밍
**OpenSSL**에서 사용하는 EVP 라이브러리를 이용한 암호화 프로그래밍 중에서 [[5주차 수업#예제 1 - 해시 함수|해시 함수]]를 이용한 프로그래밍과 [[5주차 수업#예제 2 - HMAC 함수|HMAC]]을 이용한 프로그래밍은 이미 다뤘으니 넘어갈 것이다. 

굳이 이 내용에서 짚고 넘어갈 게 있다면 Hash를 이용한 프로그래밍이건 HMAC을 이용한 프로그래밍이건 **증분 방식에서** 처음에는 `EVP_...CTX_new()` 함수로 컨텍스트를 생성하고, `EVP_..._Init()` 함수로 초기화, `EVP_..._update()` 함수로 계속 업데이트하다가 다 끝나면 `EVP_..._Final()` 함수로 계산 완료하고 `EVP_..._CTX_free()` 함수로 컨텍스트를 해제한다. 

이 때, `ex` 키워드가 `Init`이나 `Final`이 들어간 함수의 뒤에 들어가고, 대문자 `I`, `F`를 사용하는 경우가 있는데, 이 경우는 일반 메시지 다이제스트의 경우이며, HMAC의 경우는 소문자 `i`, `f`를 사용하고 `ex`를 사용하지 않는다. 
또한, HMAC에서는 키가 필요하기 때문에 `HMAC` 함수나 `EVP_MAC_init()` 함수의 인자로 키와 키 길이가 들어간다. 

이 수업에서 새로 알아갈 것은 **대칭키 암복호화 함수**이다. 

먼저, **관련 객체와 핸들**에 대해 알고 있어야 한다. 
- `EVP_CIPHER`
	- 대칭키 암호 알고리즘 핸들
	- OpenSSL3에서 `EVP_CIPHER_fetch(NULL, "알고리즘 이름", NULL)`로 생성한다. 
- `EVP_CIPHER_CTX`
	- 대칭키 암복호화 연산에서의 컨텍스트 객체
	- `EVP_CIPHER_CTX_new()`로 생성하고, `EVP_CIPHER_CTX_free()`로 해제한다. 

그 다음 주요 함수에 대해 알아보자. (복호화도 비슷하게 진행한다.)
- `EVP_CIPHER *EVP_CIPHER_fetch(OSSL_LIB_CTX *libctx, const char *name, const char *propq)`
	- `EVP_CIPHER`핸들을 얻기 위해 호출한다. 
	- 이 함수를 쓰는 대신 `EVP_EncryptInit_ex`함수의 인자를 명시해서 대신할 수 있다.
- `EVP_CIPHER_CTX *EVP_CIPHER_CTX_new(void)`
	- `EVP_CIPHER_CTX` 컨텍스트 객체를 얻기위해 호출한다. 
	- `EVP_CIPHER_CTX_free()`로 해제한다. 
- `EVP_EncryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher, ENGINE *impl, const unsigned char *key, const unsigned char *iv)`
	- 암호 알고리즘, IV, 키를 지정한다. 
	- 키와 IV를 나중에 지정하려면 `NULL`을 넣어도 된다.
- `EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl, const unsigned char *in, int inl)`
	- 여러 번 호출하여 평문 블록 `in`을 `inl`만큼 읽어 온다. 
	- 이후 `out`이 가리키는 버퍼에 암호화된 평문 블록을 `outl`만큼 저장한다. 
- `EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)`
	- 암호 계산 완료 시 호출한다. 
	- `outl`에 실제 바이트 길이를 반환한다. 
- `EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr)`
	- AEAD 관련 제어 함수이다. 

대칭키 암복호화 예제를 프로그래밍해보면 다음과 같다. 
```cpp
#include <stdio.h>
#include <string.h>
#include <openssl/evp.h>
#include <openssl/rand.h>
#include <openssl/err.h>

static void hexprint(const char* label, const unsigned char* p, int len) {
        printf("%s:", label);
        for (int i = 0; i < len; ++i) printf("%02x", p[i]);
        printf("\n");
}

int main(void) {
        ERR_load_crypto_strings();
        OpenSSL_add_all_algorithms();;

        const unsigned char* plaintext = (unsigned char*)"This is a short sentence.";
        int plaintext_len = (int)strlen((char*)plaintext);

        unsigned char key[32];
        unsigned char iv[16];

        if (RAND_bytes(key, sizeof(key)) != 1 || RAND_bytes(iv, sizeof(iv)) != 1) {
                fprintf(stderr, "RAND_bytes failed\n");
                return 1;
        }

        // Encryption
        EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
        int len = 0;
        int ciphertext_len = 0;
        unsigned char ciphertext[128];

        if (!ctx) return 1;
        
        // EVP_CIPHER_fetch 함수를 쓰지 않고 알고리즘 설정
        if (1 != EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, iv)) {
                fprintf(stderr, "EncryptInit failed\n"); EVP_CIPHER_CTX_free(ctx); return 1;
        }

        if (1 != EVP_EncryptUpdate(ctx, ciphertext, &len, plaintext, plaintext_len)) {
                fprintf(stderr, "EncryptUpdate failed\n"); EVP_CIPHER_CTX_free(ctx); return 1;
        }
        ciphertext_len = len;

        if (1 != EVP_EncryptFinal_ex(ctx, ciphertext+len, &len)) {
                fprintf(stderr, "EncryptFinal failed\n"); EVP_CIPHER_CTX_free(ctx); return 1;
        }
        ciphertext_len += len;

        EVP_CIPHER_CTX_free(ctx);

        hexprint("Key", key, sizeof(key));
        hexprint("IV", iv, sizeof(iv));
        hexprint("Ciphertext", ciphertext, ciphertext_len);


        //Decryption
        ctx = EVP_CIPHER_CTX_new();
        unsigned char recovered[128];
        int recovered_len = 0;

        if (1 != EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, iv)) {
                fprintf(stderr, "DecryptInit failed\n"); EVP_CIPHER_CTX_free(ctx); return 1;
        }

        if (1 != EVP_DecryptUpdate(ctx, recovered, &len, ciphertext, ciphertext_len)) {
                fprintf(stderr, "DecryptUpdate failed\n"); EVP_CIPHER_CTX_free(ctx); return 1;
        }
        recovered_len = len;

        if (1 != EVP_DecryptFinal_ex(ctx, recovered+len, &len)) {
                fprintf(stderr, "DecryptFinal failed (bad padding / key?)\n"); EVP_CIPHER_CTX_free(ctx); return 1;
        }
        recovered_len += len;

        EVP_CIPHER_CTX_free(ctx);

        recovered[recovered_len] = '\0';
        printf("Recovered plaintext: %s\n", recovered);

        OPENSSL_cleanse(key, sizeof(key));
        EVP_cleanup();
        ERR_free_strings();

        return 0;
}
```

46행에서 `ciphertext + len`이 사용된 이유는 **버퍼의 개념과 관련이 있다**. 41행의 `if`문에서 사용된 `ciphertext`는 암호문을 저장할 버퍼의 시작 부분의 포인터이고, 44행의 `len`은 암호문을 저장하고 나서 그 위치를 나타내는 포인터이다. 
이 때 암호화 작업을 마치는 `EVP_EncryptFinal_ex`함수에서 패딩까지 같이 하는데, 이 때 사용되는 `ciphertext + len`은 암호문의 바로 뒤, 즉 패딩의 시작 부분이다. 

 또한 **AEAD**가 굉장히 중요한 개념으로, 암호화와 MAC 계산이 합쳐진 개념이다. 
- IV 관리: 재사용 절대 금지, 권장 12 bytes
- AAD(선택): 추가 인증 데이터가 있으면 암복호화 전에 `EVP_EncryptUpdate(NULL, NULL, &len, aad, aad_len)`으로 공급해야 한다. 
- Encrypt
	- 암호화 후에 인증태그 획득 **(GET)**
	- `EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_GET_TAG, tag_len, (void*)tag_buf)`
- Decrypt
	- 복호화 전에 인증태그 설정 **(SET)**
	- `EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_TAG, tag_len, (void*)tag_buf)`
	- `EVP_DecryptFinal_ex` 호출 시 태그 불일치면 실패 (0 반환)
- Tag 길이: 보통 16 bytes 권장

### 일회용 비밀번호 기법 (이론)
**일회용 비밀번호 인증**이란 비밀번호 가로채기 공격과 비밀번호 재전송 공격에 대응하기 위해 한 번 사용하고 버리는 비밀번호인 일회용 비밀번호를 사용해 사용자를 인증하는 기술이다. 
![[Pasted image 20251011052141.png]]
이는 일반적으로 비밀번호를 생성해 주는 별도의 HW나 SW가 필요하며 능동적 공격에 취약하다. 

일회용 비밀번호에는 4가지의 유형이 있다. 
1. 비밀번호 목록에 의한 방식
2. S/Key 방식
3. 질의-응답 방식
4. 동기화 방식

이 중에서 **질의-응답 방식과 동기화 방식**에 대해 깊게 알아볼 것이다. 이 둘의 공통점은 별도의 비밀번호 생성장치를 요구한다는 것이다. 

질의-응답(Challenge-Response) 방식은 클라이언트와 서버의 비밀정보 공유를 전제로 하여 이루어지며, 다음과 같은 순서로 동작한다. 
*(가정: C는 사전에 S에 자신의 아이디 id와 비밀정보 $K$를 등록함)*
1. C -> S: $id$
2. S -> C: $RV$ ($RV$는 S가 임의로 생성한 난수)
3. C -> S: otp (otp는 $K, RV$를 가지고 해시 연산 또는 HMAC 연산한 결과)

동기화 방식은 클라이언트와 서버 사이의 동기화된 카운터 정보와 공유 비밀정보를 통해 일회용비밀번호를 생성하며, 카운터 정보의 종류에는 인증이 발생할 때마다 1씩 증가하는 **이벤트 동기화** 방식과 동기화된 시간 정보를 사용하는 **시간 동기화** 방식이 있다. 

이 두 방식 간에는 각각 장점과 단점이 모두 존재하며, 동작 과정은 질의-응답 방식과 비슷하다. 

---
## 중요한 단어
1. OpenSSL
2. 해시 함수
3. HMAC
4. 대칭키 암복호화
5. AEAD
6. 일회용 비밀번호 인증 (One-time Password)
7. 질의-응답 방식
8. 동기화 방식
