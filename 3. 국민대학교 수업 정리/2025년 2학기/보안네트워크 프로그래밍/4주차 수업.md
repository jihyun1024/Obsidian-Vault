---
tags:
  - Programming
  - 3학년_2학기
title: TCP & IP 클라이언트_서버 소켓 프로그래밍 (2)
---
## 학습 주제
1. 예제 1: Echo 메시지 대문자 변환
2. 예제 2: 현재 시간 안내 (단순 서버)
3. 예제 3: 현재 시간 안내 (일반 서버)
4. 예제 4: 가위 바위 보 게임 (TCP Echo)
5. Makefile을 이용한 효율적인 컴파일

---
## 연관 수업
[[3. 국민대학교 수업 정리/2025년 2학기/보안네트워크 프로그래밍/2주차 수업]]
[[3. 국민대학교 수업 정리/2025년 2학기/보안네트워크 프로그래밍/3주차 수업]]

---
## 강의 요약
이 강의에서는 2주차와 3주차 강의 내용을 바탕으로, 4개의 예제를 통해 소켓 프로그래밍과 더욱 친숙해지는 시간을 가져볼 것이다. 
### 예제 1: Echo 메시지 대문자 변환
TCP Echo 서버가 TCP Echo 클라이언트로부터 수신한 메시지에 소문자가 포함될 경우, 대문자로 변경한 후, TCP Echo 클라이언트에게 보내도록 `TCPEchoServer.c`를 수정하는 예제이다. 

>힌트: `int toupper(int c);`를 사용할 수 있다. 

```cpp 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys.types.h>
#include <sys.socket.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "Practical.h"
#include <ctype.h> // 새로 추가

// 추가: 함수 선언
void ToUpperMsg(char* buffer, int size);
void HandleTCPClient(int clntSocket);

int main(int argc, char* argv[]) {
......
}

void ToUpperMsg(char* buffer, int size) {
	if (buffer == NULL || size < 1) return;
	
	// 버퍼의 길이만큼 대문자로 변환 (toupper 함수 사용)
	int len = strlen(buffer);
	for (int i = 0; i < len; i++) {
		buffer[i] = toupper(buffer[i]);
	}
}

void HandleTCPClient(int clntSocket) {
	char buffer[BUFSIZE];
	
	// recv 함수를 사용, 문자열 종료 처리를 해야 정상적으로 돌아가므로 
	// BUFSIZE-1로 사용 -> numBytesRcvd는 받은 바이트의 수
	ssize_t numBytesRcvd = recv(clntSocket, buffer, BUFSIZE-1, 0);
	if (numBytesRcvd < 0) {
		DieWithSystemMessage("recv() failed");
	}
	
	// 널 문자 처리하고 대문자로 변경
	buffer[numBytesRcvd] = 0;
	ToUpperMsg(buffer, numBytesRcvd);
	
	while (numBytesRcvd > 0) {
		ssize_t numBytesSent = send(clntSocket, buffer, numBytesRcvd, 0);
		if (numBytesSent < 0) {
			DieWithSystemMessage("send() failed");
		}
		else if (numBytesSent != numBytesRcvd) {
			DieWithUserMessage("send()", "sent unexpected number of bytes");
		}
		
		numBytesRcvd = recv(clntSocket, buffer, BUFSIZE-1, 0);
		if (numBytesRcvd < 0) {
			DieWithSystemMessage("recv() failed");
		}
		
		// 새로 추가한 부분
		buffer[numBytesRcvd] = 0;
		ToUpperMsg(buffer, numBytesRcvd);
	}
	
	close(clntSocket);
}
```

뒤에서 소개할 makefile을 이용해 컴파일하면
```
CC = gcc
CFLAGS = -Wall
all: server client

server: TCPEchoServer.c DieWithMessage.c AddressUtility.c Practical.h
	$(CC) $(CFLAGS) -o server TCPEchoServer.c DieWithMessage.c AddressUtility.c
	
client: TCPEchoClient.c DieWithMessage.c Practical.h
	$(CC) $(CFLAGS) -o client TCPEchoClient.c DieWithMessage.c AddressUtility.c
	
clean: 
	rm -f server client
```
이며, `make`를 입력하면 제대로 컴파일된다. 

이어서 Cygwin 창을 두 개 열어놓고 
```
./server 1024

./client 127.0.0.1 "beyond security - 보안이상의 보안" 1024
```
이 두 개의 명령어를 각각 순서대로 치면 정상적으로 소문자가 대문자로 바뀐다. 

### 예제 2: 현재 시간 안내 (단순 서버)
클라이언트가 접속하면 서버가 현재 시간을 ISO 형식으로 작성해 클라이언트에게 알려주도록 `TCPServer.c`와 `TCPClient.c`를 변경하는 예제이다. 

>힌트: 시간 관련 함수 `time()`과 `local()`을 사용할 수 있다. 

먼저, `TCPClient.c`의 경우는 이렇게 수정할 수 있다. 
```cpp
#include <stdio.h>
.....

int main(int argc, char* argv[]) {
	....
	....
	
	// 시간정보를 받는 부분 추가
	unsigned int numBytes = 0;
	fputs("\nReceived: ", stdout);
	
	do {
		char buffer[BUFSIZE];
		numBytes = recv(sock, buffer, BUFSIZE-1, 0);
		if (numBytes < 0) {
			DieWithSystemMessage("recv() failed");
		}
		else if (numBytes == 0) {
			break;
		}
		
		// 받은 시간정보를 출력
		buffer[numBytes] = '\0';
		fputs(buffer, stdout);
	} while (1);
	
	close(sock);
}
```

그 다음 , `TCPServer.c`를 수정하면 
```cpp
#include <stdio.h>
.....

#include <time.h>

...... 
void getCurrentDateTime(char* res) {
	time_t t;
	time(&t);
	
	struct tm* p;
	p = localtime(&t);
	sprintf(res, "%04d-%02d-%02d %02d:%02d:%02d", 1900+p->tm_year, 
	1+p->tm_mon, p->tm_mday, p->tm_hour, p->tm_min, p->tm_sec);
}

int main(int argc, char* argv[]) {
	......
	
	printf("Connected to Client: ");
	PrintSocketAddress((struct sockaddr*)&clntAddr, stdout);
	
	// 새로 추가한 부분으로, 현재 시간을 가져옴.
	getCurrentDateTime(buffer);
	if ((len = strlen(buffer)) <= 0) 
		DieWithUserMessage("getCurrentDateTime()", "failed to get the current time");
	
	// 현재 시간 전송
	numBytesSent = send(clntSock, buffer, len, 0);
	if (numBytesSent < 0) 
		DieWithSystemMessage("send() failed");
	else if (numBytesSent != len)
		DieWithUserMessage("send()", "sent unexpected number of bytes");
		
	close(clntSock);
	close(servSock);
}	
```

makefile을 이용해 컴파일하면
```
CC = gcc
CFLAGS = -Wall
all: server client

server: TCPServer.c DieWithMessage.c Practical.h
	$(CC) $(CFLAGS) -o server TCPServer.c DieWithMessage.c AddressUtility.c
	
client: TCPClient.c DieWithMessage.c Practical.h
	$(CC) $(CFLAGS) -o client TCPClient.c DieWithMessage.c AddressUtility.c
	
clean: 
	rm -f server client
```
이며, `make`를 입력하면 제대로 컴파일된다. 

이어서 Cygwin 창을 두 개 열어놓고 
```
./server 1024

./client 127.0.0.1 1024
```
이 두 개의 명령어를 각각 순서대로 치면 현재 시간을 ISO 타입으로 확인할 수 있다.

### 예제 3: 현재 시간 안내 (일반 서버)
문제 2번의 서버는 첫 클라이언트와 통신 한 후 종료된다. 이 때 서버는 종료되지 않고 다른 클라이언트의 요청을 계속해서 받을 수 있도록 `TCPServer.c`를 수정하는 예제이다. 

이 예제에서는 단순히 `listen()` 뒤에 있는 `getCurrentDateTime()`함수를 포함한 서버 연결 부분, 즉 `listen()` 바로 뒤 부터 `close(servSock)` 이전까지 전부 `for(;;) {}`문을 통해 무한루프를 돌리면 된다. 

 이후 makefile을 이용해 예제 2와 똑같이 컴파일하고 나서 Cygwin 창을 두 개 열어놓고 
```
./server 1024

./client 127.0.0.1 1024
```
클라이언트 단에서 이 `./client 127.0.0.1 1024` 명령어를 원하는 시간마다 여러 번 치면 그 때마다 현재 시간이 여러 번 출력된다.  

### 예제 4: 가위 바위 보 게임 (TCP Echo)
클라이언트에서 가위는 0, 바위는 1, 보는 2라고 할 때 클라이언트가 선택한 번호를 서버에게 전달하면 서버는 임의의 숫자를 생성, 비교해 결과를 알려주는 프로그램을 `TCPEchoClient.c`와 `TCPEchoServer.c`를 수정하여 작성하는 예제이다. 

>힌트: `srand()`와 `rand()`를 사용할 수 있다. 

이 예제의 구현은 하나하나 적기 너무 귀찮으니 사진으로 대신한다. 
![[Pasted image 20251007030514.png]]
![[Pasted image 20251007030523.png]]
![[Pasted image 20251007030537.png]]
![[Pasted image 20251007030554.png]]
![[Pasted image 20251007030604.png]]

makefile을 이용해 컴파일하면
```
CC = gcc
CFLAGS = -Wall
all: server client

server: TCPEchoServer.c DieWithMessage.c Practical.h
	$(CC) $(CFLAGS) -o server TCPEchoServer.c DieWithMessage.c 
	
client: TCPEchoClient.c DieWithMessage.c Practical.h
	$(CC) $(CFLAGS) -o client TCPEchoClient.c DieWithMessage.c 
	
clean: 
	rm -f server client
```
이며, `make`를 입력하면 제대로 컴파일된다. 

이어서 Cygwin 창을 두 개 열어놓고 
```
./server 1024

./client 127.0.0.1 (원하는 숫자, 단 0부터 2까지) 1024
```
이 두 개의 명령어를 각각 순서대로 치면 가위바위보가 잘 실행된다. 

### Makefile을 이용한 효율적인 컴파일
저번 강의에서처럼 [[Cygwin]] 터미널에서 일일히 `gcc -o server TCPServer.c`를 통해 컴파일하는 방법도 있지만, makefile을 통해 몇 가지의 명령어만 바꿔 효율적으로 컴파일하는 방법이 있다. 

먼저, `makefile`이란 이름의 파일을 nano를 통해 만들고, 다음 내용을 기록한다.
```
// 사용할 컴파일러 설정
CC = gcc

// 컴파일 옵션 설정 (-Wall은 모든 일반적인 경고 메시지 출력)
CFLAGS = -Wall

// 기본 타깃: 서버와 클라이언트 두 단을 server와 client라는 이름으로 빌드
all: server client

// 서버 빌드
server: TCPServer.c DieWithMessage.c Practical.h
	$(CC) $(CFLAGS) -o server TCPServer.c DieWithMessage.c Practical.h
	
// 클라이언트 빌드
client: TCPClient.c DieWithMessage.c Practical.h
	$(CC) $(CFLAGS) -o client TCPClient.c DieWithMessage.c Practical.h
	
// 생성된 실행 파일 삭제
clean: 
	rm -f server client // rm -f: 내용들까지 모두 삭제(remove)
```
이렇게 설정해 놓으면 Cygwin 터미널에서는 `make`명령어만 치면 알아서 컴파일 해 주며, 만약 컴파일할 대상이 바뀔 경우에는 `server`와 `client` 빌드에 있는 파일들만 다른 이름으로 해 주면 되고, 응용 프로그램 이름이 바뀔 경우에는 `server`와 `client`의 이름들만 바꿔 주면 된다.

```
사용법

make -> server, client 모두 빌드
make server -> server만 빌드
make client -> client만 빌드
make clean -> 빌드된 실행 파일 삭제
```

---
## 중요한 단어
1. Makefile
