---
tags:
  - 수업_정리
  - 암호학
  - Programming
title: 인증 암호 및 암호화 기반 인증
---
## 학습 주제
1. 인증 암호 (Authenticated Encryption)
2. TOTP: 시간 동기화 일회용 비밀번호 인증

---
## 연관 수업
[[5주차 수업]]
[[3. 국민대학교 수업 정리/2025년 2학기/보안네트워크 프로그래밍/6주차 수업]]

---
## 강의 요약
### 인증 암호 (Authenticated Encryption)
기존의 방식은 대칭키 또는 공개키 암호화를 통해 기밀성을 제공하고, MAC이나 HMAC을 통해 무결성을 제공했다. 이는 구현에 오류가 있을 가능성이 높고, 순서를 바꾸거나 일부만 검증하는 등의 간단한 방식으로도 보안이 깨질 우려가 있어 딱히 안전하지는 않은 방법이다. 

따라서, **인증 암호 (Authenticated Encryption)** 라는 새로운 방식을 고안해 냈는데, 이는 기밀성과 인증을 동시에 제공하는 방법으로, 데이터에 대해 무결성과 인증을 암호화와 같이 제공해 수신자는 메시지가 변경되지 않았고, 올바른 송신자로부터 왔음을 동시에 검증할 수 있다. 

인증 암호를 구현하는 방식은 크게 세 가지로 나눠진다. 

1. EtM (Encrypt-then-MAC)
	1. 암호화 이후 MAC 값을 연산한다.
2. E&M (Encrypt-and-MAC)
	1. 암호화와 MAC 연산을 동시에 수행한다. 
3. MtE (MAC-then-Encrypt)
	1. MAC값을 먼저 계산하고, MAC 값을 포함해 암호화를 수행한다.

이를 그림으로 나타낸 것은 다음과 같다.
![[Pasted image 20251023173411.png]]

인증 암호의 확장 개념으로 **연관 데이터 (Associated Data)** 를 활용한 AEAD(Authenticated Encryption with Associated Data)가 있는데, 이는 암호화되지는 않지만, 변조되는 경우 검증이 실패해서 보안이 강화되도록 하는 데이터로 주로 *네트워크 프로토콜의 헤더, 파일의 메타데이터* 등이 사용된다. 

따라서, $K$가 대칭키, $IV, N$이 각각 Initial Vector와 Nonce, $P$가 평문, $AAD$가 부가 데이터, $C$가 암호문, $Tag$가 인증 태그일 때,  AEAD를 이용한 암호화와 복호화는 다음과 같이 작동한다. 

- 암호화 함수: $(C, Tag) = AEAD_{Enc}(K, N, AAD, P)$
- 복호화 함수: $P = AEAD_{Dec}(K, N, AAD, C, Tag)$

이때, 복호화 과정에서 태그가 일치하지 않을 경우 인증에 실패하게 된다. 

AEAD를 이용한 알고리즘에는 다음 세 가지가 존재한다. 
1. AES-GCM (Galois/Counter Mode)
	- 암호화: AES-CTR
	- 인증: G-Hash
	- 특징: 매우 빠름, 병렬화의 용이함, IV 재사용 시 키 유출, 서버에서 가장 널리 사용
2. AES-CCM (Counter + CBC-MAC)
	- 암호화: AES-CTR
	- 인증: CBC-MAC
	- 특징: 단순함, 병렬화 불가능, IoT 및 저전력 환경에서 구현 용이, Tag 길이 가변
3. ChaCha20-Poly1305
	- 암호화: ChaCha20 스트림 암호
	- 인증: Poly1305 MAC (1회용 키 기반 One-time MAC)
	- 특징: AES 하드웨어 가속이 없는 환경에서 GCM보다도 빠름, 타이밍 공격에 강함

AEAD 파일 암복호화를 구현한 예제는 다음과 같다.
```cpp
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include <openssl/evp.h>
#include <openssl/rand.h>
#include <openssl/err.h>

// 일반적인 크기로 설정
#define IV_LEN 12
#define TAG_LEN 16
#define KEY_LEN 32
#define CHUNK 4096

// 바이트 배열을 16진수로 출력
static void hexprint(const char* label, const unsigned char* b, size_t n) {
	printf("%s: ", label);
	for (int i = 0; i < n; i++) printf("%02x", b[i]);
	printf("\n");
}

// SHA-256을 사용한 단순 키 파생 (실제로는 PBKDF2, HKDF 등을 사용)
int derive_key_from_password(const char* pwd, unsigned char key[KEY_LEN]) {
	unsigned int outlen = 0;
	int (!EVP_Digest((const unsigned char*)pwd, strlen(pwd), key, &outlen, EVP_sha256(), NULL)) return 0;
	return outlen == KEY_LEN
}

// 주어진 파일을 AES256-GCM으로 암호화하여 저장
// 출력 파일 포맷: [IV:12bytes] + [Ciphertext] + [Tag:16bytes]
int encrypt_file(const char* inpath, const char* outpath, const unsigned char key[KEY_LEN]) {
	// 입력, 출력 파일 오픈 (파일 포인터 사용)
	FILE* inf = fopen(inpath, "rb");
	FILE* outf = fopen(outpath, "rb");
	
	EVP_CIPHER_CTX* ctx = NULL;
	int ret = 0;
	unsigned char iv[IV_LEN];
	
	// 오류 검증 및 IV 생성, IV 쓰기, 암호 컨텍스트 생성
	if (!inf || !outf) goto done;
	if (1 != RAND_bytes(iv, sizeof(iv)))          goto done;
	if (fwrite(iv, 1, IV_LEN, outf) != IV_LEN)    goto done;
	if ((ctx = EVP_CIPHER_CTX_new()) == NULL)     goto done;
	
	// AES-GCM의 IV 길이를 기본값으로 할 경우
	if (1 != EVP_EncryptInit_ex(ctx, EVP_aes_256_gcm(), NULL, key, iv))    goto done;
	
	unsigned char inbuf[CHUNK], outbuf[CHUNK+16];
	int inlen, outlen;
	
	// 원본 파일에서 inbuf만큼의 데이터를 읽어 와 암호화
	while ((inlen = fread(inbuf, 1, sizeof(inbuf), inf)) > 0) {
		if (1 != EVP_EncryptUpdate(ctx, outbuf, &outlen, inbuf, inlen))    goto done;
		if (outlen > 0) { // 이 경우, 암호화된 내용을 파일에 기록함
			if (fwrite(outbuf, 1, outlen, outf) != (size_t)outlen)          goto done;
		}
	}
	if (ferror(inf))    goto done;
	
	if (1 != EVP_EncryptFinal_ex(ctx, outbuf, &outlen))    goto done;
	if (outlen > 0) if (fwrite(outbuf, 1, outlen, outf) != (size_t)outlen)   goto done;
	
	unsigned char tag[TAG_LEN];
	if (1 != EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_GET_TAG, TAG_LEN, tag))   goto done;
	if (fwrite(tag, 1, TAG_LEN, outf) != TAG_LEN)    goto done;
	
	
	// 에러 처리 및 반환 (오류 처리를 한 곳에서 모아서 수행)
	ret = 1;
	done:
		if (ctx != NULL) EVP_CIPHER_CTX_free(ctx);
		if (inf != NULL) fclose(inf);
		if (outf != NULL) fclose(outf);
		return ret;
}


int decrypt_file(const char* inpath, const char* outpath, const unsigned char key[KEY_LEN]) {
	EVP_CIPHER_CTX* ctx = NULL;
	int ret = 0;
	
	FILE* inf = fopen(inpath, "rb");
	FILE* outf = fopen(outpath, "rb");
	if (!inf || !outf)    goto done;
	
	if (fseek(inf, 0, SEEK_END) != 0)    goto done;
	long fsize = ftell(inf); //  파일 크기 계산
	if (fsize < IV_LEN + TAG_LEN)    goto done;
	long ctext_len = fsizE - IV_LEN - TAG_LEN; // 암호문 크기 계산
	rewind(inf); // 파일 포인터를 다시 처음으로 원상복귀
	
	// IV 읽어오기 및 오류 처리
	unsigned char iv[IV_LEN];
	if (fread(iv, 1, IV_LEN, inf) != IV_LEN)              goto done;
	if (fseek(inf, IV_LEN, SEEK_SET) != 0)                goto done;
	
	// TAG 읽어오기 및 오류 처리 & EVP 객체 생성
	unsigned char tag[TAG_LEN];
	if (fread(tag, 1, TAG_LEN, inf) != TAG_LEN)           goto done;
	if (fseek(inf, IV_LEN + ctext_len, SEEK_SET) != 0)    goto done;
	if ((ctx = EVP_CIPHER_CTX_new()) == NULL)             goto done;
	
	// AES-GCM의 IV 길이를 기본값으로 한 경우
	if (1 != EVP_DecryptInit_ex(ctx, EVP_aes_256_gcm(), NULL, key, iv))     goto done;
	
	unsigned char inbuf[CHUNK], outbuf[CHUNK + 16];
	long remaining = ctext_len;
	int inlen, outlen;
	
	// 복호화할 데이터가 남지 않을 때까지 반복
	while (remaining > 0) {
		int toread = (remaining > (long)sizeof(inbuf)) ? sizeof(inbuf) : (int)remaining;
		if (toread != (inlen = fread(inbuf, 1, toread, inf)))     goto done;
		remaining -= inlen;
		
		if (1 != EVP_DecryptUpdate(ctx, outbuf, &outlen, inbuf, inlen))   goto done;
		if (outlen > 0) {
			if (fwrite(outbuf, 1, outlen, outf) != (size_t)outlen)       goto done;
		}
	}
	
	// TAG 관련 설정
	if (1 != EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_TAG, TAG_LEN, tag))   goto done;
	if (1 != EVP_DecryptFinal_ex(ctx, outbuf, &outlen))    goto done;
	if (outlen > 0) {
		if (fwrite(outbuf, 1, outlen, outf) != (size_t)outlen)    goto done;
	}
	
	
	// 에러 처리 및 반환
	ret = 1;
	done:
		if (ctx != NULL) EVP_CIPHER_CTX_free(ctx);
		if (inf != NULL) fclose(inf);
		if (outf != NULL) fclose(outf);
		return ret;
}


// 사용법: ./aeadfile enc|dec <password> <infile> <outfile>
int main(int argc, char** argv) {
	if (argc != 5) { // 사용법을 모를 경우
		fprintf(stderr, "Usage: %s enc|dec <password> <infile> <outfile>\n", argv[0]);
		return 1;
	}
	
	ERR_load_crypto_strings();
	OpenSSL_add_all_algorithms();
	
	// 모드, 비밀번호, 입출력 파일 지정
	const char* mode = argv[1];
	const char* pwd = argv[2];
	const char* infile = argv[3];
	const char* outfile = argv[4];
	
	unsigned char key[KEY_LEN];
	if (!derive_key_from_password(pwd, key)) {
		fprintf(stderr, "derive key fail\n"); 
		return 1;
	}
	
	// 암호화 또는 복호화 수행
	if (strcmp(mode, "enc") == 0) {
		if (!encrypt_file(infile, outfile, key)) {
			fprintf(stderr, "encryption failed\n");
			return 1;
		}
		printf("Encrypted %s -> %s\n", infile, outfile);
	}
	else if (strcmp(mode, "dec") == 0) {
		if (!decrypt_file(infile, outfile, key)) {
			fprintf(stderr, "decryption failed\n");
			return 1;
		}
		printf("Decrypted %s -> %s\n", infile, outfile);
	}
	else {
		fprintf(stderr, "mode must be enc or dec\n");
		return 1;
	}
	
	// 뒷처리
	EVP_cleanup();
	ERR_free_strings();
	return 0;
}
```

### TOTP: 시간 동기화 일회용 비밀번호 인증
**TOTP (Time-Based One-Time Password Algorithm)** 이란 OAUTH에서 제안한 표준 시간 동기화 일회용 비밀번호 인증 알고리즘으로 HMAC을 기반으로 동작한다. 

긴 말 하지 않고 바로 구현으로 들어가자. 조금 길다. 
```cpp
// OTPlib.h 파일
#ifndef OTPLIB_H_
#define OTPLIB_H_

// 유닉스 시작 시간을 나타내는 상수
#define t0  0

// 일회용 비밀번호 변경 주기
#define OTP_STEP 30

// TOTP 기반 OTP 생성 및 검증 함수
bool calc_otp(char* pwd, char* otp, int* otplen);
bool verity_otp(char* pwd, char* otp, int otplen);

#endif

/* ----------------------------------------------------------------- */

// OTPlib.c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>

#include <openssl/opensslv.h>
#include <openssl/crypto.h>
#include <openssl/hmac.h>
#include <openssl/evp.h>
#include <openssl/cose_names.h>
#include <openssl/params.h>
#include <openssl/err.h>

#include "Practical.h"
#include "OTPlib.h"

// OTP 생성 함수
bool calc_otp(char* pwd, char* otp, int* otp_len) {
	if (pwd == NULL || otp == NULL || otp_len == NULL) 
		DieWithUserMessage("calc_otp() failed", "invalid input parameter");
		
	unsigned char key[EVP_MAX_MD_SIZE];
	unsigned int key_len = 0; 
	unsigned int len = strlen(pwd);
	
	// pwd를 통해 sha256 기반으로 otp 파생
	// 입력 인자: 알고리즘 이름, 키, 키 길이, 시간 정보, 시간 정보 길이, 저장할 OTP, 저장할 OTP의 길이
	time_t t = floor((time(NULL) - t0 / OTP_STEP);
	if (NULL == HMAC(EVP_sha256(), key, (int)key_len, (const unsigned char*)&t, sizeof(t), (unsigned char*)otp, (unsigned int*)otplen))      return false;
	
	return true;
}


// OTP 검증 함수
bool verify_otp(char* pwd, char* otp, int otplen) {
	char d_otp[EVP_MAX_MD_SIZE];
	int len = 0;
	memset(d_otp, 0, EVP_MAX_MD_SIZE);
	
	if (!calc_otp(pwd, d_otp, &len))
		return false;
	else if (len != otplen)
		return false;
	
	// 메모리의 값을 비교할 때는 CRYPTO_memcmp를 사용하는 게 안전함	
	return (0 == CRYPTO_memcmp(d_otp, otp, (size_t)len));
}
```

```cpp
// TCPClient.c

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <openssl/opensslv.h>
#include <openssl/hmac.h>
#include <openssl/evp.h>
#include <openssl/core_names.h>
#include <openssl/params.h>
#include <openssl/err.h>

#include <time.h>
#include <math.h>
#include "Pracical.h"
#include "OTPlib.h"


static void hexprint(const unsigned char* p, size_t len) {
	for (size_t i = 0; i < len; ++i) printf("%02x", p[i]);
	printf("\n");
}


// calc_otp 함수를 통해 pwd에 대해 otp를 계산
// 이를 입력된 id와 함께 서버에 전송하는 함수
void send_msg(int sock, char* id, char* pwd) {
	if (sock == 0 || id == NULL || pwd == NULL)
		DieWithUserMessage("send_msg() failed", "invalid input parameters");
	
	char buffer[BUFSIZE], otp[BUFSIZE];
	int len, id_len;
	int numBytes;
	
	memset(buffer, 0, BUFSIZE);
	memset(otp, 0, BUFSIZE);
	
	// otp 생성
	if(!calc_otp(pwd, otp, &numBytes)) 
		DieWithUserMessage("send_msg() failed", "calc_otp() error");
	printf("\nOTP: ");
	hexprint((const unsigned char*)otp, numBytes);
	id_len = strlen(id);
	len = id_len + 1 + numBytes;
	if (len > BUFSIZE)
		DieWithUserMessage("send_msg() failed", "buffer size is too small");
		
	// 세미콜론을 구분자로 하여 id와 otp로 전송할 데이터 생성
	// 생성 방법: for문을 돌려서 buffer에 id와 otp를 그냥 삽입
	for (int i = 0; i < id_len; i++) buffer[i] = id[i];
	buffer[id_len] = ';';
	for (int i = 0; i < numBytes; i++) buffer[id_len + i + 1] = otp[i];
	
	// buffer에 담긴 데이터 전송
	numBytes = send(sock, buffer, len, 0);
	if (numBytes < 0) 
		DieWithSystemMessage("send() failed");
	else if (numBytes != len) 
		DieWithUserMessage("send()", "sent unexpected number of bytes");
}


int main(int argc, char* argv[]) {
	if (argc < 5 || argc > 6) 
		DieWithUserMessage("Parameter(s)", "<Server Address> <User ID> <User Password> [<Server Port>]");
		
	char* servIP = argv[1];
	char* userID = argv[2];
	char* userPWD = argv[3];
	in_port_t servPort = (argc == 5) ? atoi(argv[4]) : 7;
	
	// 소켓 생성
	int sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (sock < 0)
		DieWithSystemMessage("socket() failed");
		
	// 서버 주소 설정
	struct sockaddr_in servAddr;
	memset(&servAddr, 0, sizeof(servAddr));
	servAddr.sin_family = AF_INET;
	int rtnval = inet_pton(AF_INET, servIP, &servAddr.sin_addr.s_addr);
	if (rtnval == 0)
		DieWithUserMessage("inet_pton() failed", "invalid address string");
	else if (rtnval < 0) 
		DieWithSystemMessage("inet_pton() failed");
	servAddr.sin_port = htons(servPort); // 호스트와 네트워크 간 바이트 순서 정렬
	
	// 연결 요청을 서버에게 전송
	if (connect(sock, (struct sockaddr*) &servAddr, sizeof(servAddr)) < 0)
		DieWithSystemMessage("connect() failed");
	printf("Connected to Server: ");
	PrintSocketAddress((struct sockaddr*)&servAddr, stdout);
	
	// ID와 PWD를 서버에 전송
	printf("\nSending User Account to Server: %s/%s", userID, userPWD);
	send_msg(sock, userID, userPWD);
	
	// 서버로부터 응답을 받음
	unsigned int numBytes = 0;
	fputs("Received: ", stdout);
	do {
		char buffer[BUFSIZE];
		numBytes = recv(sock, buffer, BUFSIZE-1, 0);
		if (numBytes < 0)
			DieWithSystemMessage("recv() failed");
		else if (numBytes == 0) 
			break;
			
		buffer[numBytes] = '\0';
		fputs(buffer, stdout);
	} while (1);
	
	close(sock);
}
```

```cpp
//TCPServer.c

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <openssl/opensslv.h>
#include <openssl/hmac.h>
#include <openssl/evp.h>
#include <openssl/core_names.h>
#include <openssl/params.h>
#include <openssl/err.h>

#include <time.h>
#include <math.h>
#include "Pracical.h"
#include "OTPlib.h"


static const int MAXPENDING = 5; // 최대 연결 가능한 요청 수

// 간단한 사용자 데이터베이스 정의
#define MAX_USER_NUMBER 200
#define MAX_USER_ACCOUNT_LEN 100

char list_user_id[MAX_USER_NUMBER][MAX_USER_ACCOUNT_LEN];
char list_user_pwd[MAX_USER_NUMBER][MAX_USER_ACCOUNT_LEN];
int registered_user_num; // 현재 등록된 사용자 수


// 새로운 사용자 등록
int add_user_2_db(const char* id, const char* pwd) {
	if (id == NULL || pwd == NULL)
		DieWithUserMessage("add_user_2_db() failed", "~");
	if (registered_user_num >= MAX_USER_NUMBER)
		DieWithUserMessage("add_user_2_db() failed", "~");
		
	// 배열에 User의 ID를 대입
	int len = strlen(id);
	if (len > MAX_USER_ACCOUNT_LEN - 1) 
		DieWithUserMessage("add_user_2_db() failed", "~");
	strncpy(list_user_id[registered_user_num], id, len);
	list_user_id[registered_user_num][len] = '\0';
	
	// 배열에 User의 PWD를 대입
	len = strlen(pwd);
	if (len > MAX_USER_ACCOUNT_LEN -1)
		DieWithUserMessage("add_user_2_db() failed", "~");
	strncpy(list_user_pwd[registered_user_num], pwd, len);
	list_user_pwd[registered_user_num][len] = '\0';
	
	// 등록된 사용자 수 증가
	registered_user_num++;
	return registered_user_num;
}


// 사용자 데이터베이스 초기화
void init_user_db() {
	// 변수 초기화
	memset(list_user_id, 0, sizeof(list_user_id));
	memset(list_user_pwd, 0, sizeof(list_user_pwd));
	registered_user_num = 0;
	
	// 사용자 추가
	add_user_2_db("CryptoWorld", "1234");
	add_user_2_db("kmulSCM", "1233");
	add_user_2_db("dr_You", "1901");
}


static void hexprint(const unsigned char* p, size_t len) {
	for (size_t i = 0; i < len; ++i) printf("%02x", p[i]);
	printf("\n");
}


// 상수 시간 내에 문자열 비교
static bool const_time_str_eq_fixed(const char* fixed, const char* var, size_t var_len, size_t fixed_len) {
	unsigned char diff = 0;
	for (size_t i = 0; i < fixed_len; ++i) {
		unsigned char a = (unsigned char)fixed[i];
		unsigned char b = (unsigned char)(i < var_len ? var[i]: '\0');
		diff |= (a ^ b);
		if (diff != 0) break;
	}
	diff |= (unsigned char)(var_len >= fixed_len ? 1 : 0);
	return (diff == 0);
}


// id와 pwd를 받아 사용자 ID, PWD 배열을 순회하며 사용자 검색
// 사용자가 존재한다면 verify_otp 함수 호출
bool authenticate_user(const char* id, int id_len, const char* pwd, int pwd_len) {
	if (id == NULL || pwd == NULL || id_len < 0 || pwd_len < 0 || id_len > MAX_USER_ACCOUNT_LEN || pwd_len > MAX_USER_ACCOUNT_LEN) 
		return false;
	
	int n = registered_user_num;
	if (n < 0) n = 0;
	if (n > MAX_USER_NUMBER) n = MAX_USER_NUMBER;
	
	// 주어진 ID에 매치하는 사용자 조회
	for (int i = 0; i < MAX_USER_NUMBER; ++i) {
		bool id_eq = const_time_str_eq_fixed(list_user_id[i], id, (size_t)id_len, MAX_USER_ACCONT_LEN);
		bool pwd_eq = verify_otp((char*)list_user_pwd[i], (char*)pwd, pwd_len);
		if (id_eq & pwd_eq) return true;
	}
	
	return false;
}


// Client로부터 ID와 PWD를 받아 파싱해 id와 pwd 값을 구하고 반환
void recv_msg(int c_sock, char* p_id, int* p_id_len, char* p_pwd, int* p_pwd_len) {
	if (c_sock < 0 || p_id == NULL || p_pwd == NULL || p_id_len == NULL || p_pwd_len == NULL)
		DieWithUserMessage("recv_msg() failed", "invalid");
	
	char buffer[BUFSIZE];
	int numBytes;
	int i = 0;
	
	memset(buffer, 0, BUFSIZE);
	numBytes = recv(c_sock, buffer, BUFSIZE, 0);
	if (numBytes < 0) 
		DieWithSystemMessage("recv() failed");
	else if (numBytes == 0) 
		return;
		
	// 세미콜론으로 구분된 ID와 PWD 파싱
	while (buffer[i] != ';' && i < numBytes) {
		p_id[i] = buffer[i];
		i++;
	}
	if (i >= numBytes)
		DieWithUserMessage("recv_msg() failed", "~");
	*p_id_len = i++;
	*p_pwd_len = numBytes - i;
	while (i < numBytes) {
		p_pwd[i - *p_id_len - 1] = buffer[i];
		i++;
	}
}


int main(int argc, char* argv[]) {
	char buffer[BUFSIZE]; // 환영 메시지를 위한 버퍼
	ssize_t len = 0; numBytesSent = 0;
	
	if (argc != 2)
		DieWithUserMessage("Parameter(s)", "<Server Port>");
	
	// 문자열을 숫자로 변환하면서 서버 포트 설정
	in_port_t servPort = atoi(argv[1]);
	
	// 사용자 데이터베이스 초기화
	init_user_db();
	
	// 소켓 생성
	int servSock;
	if ((servSock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
		DieWithSystemMessage("socket() failed");
	
	// 주소정보 설정
	struct sockAddr_in servAddr;
	memset(&servAddr, 0, sizeof(servAddr));
	servAddr.sin_family = AF_INET;
	servAddr.sin_addr.s_addr = htonl(INADDR_ANY);
	servAddr.sin_port = htons(servPort);
	
	// Client로부터 오는 통신 대기
	if (bind(servSock, (struct sockaddr*)&servAddr, sizeof(servAddr)) < 0)
		DieWithSystemMessage("bind() failed");
	if (listen(servSock, MAXPENDING) < 0)
		DieWithSystemMessage("listen() failed");
		
	// Client로부터 연결 요청이 올 경우
	for (;;) {
		struct sockaddr_in clntAddr;
		socklen_t clntAddrLen = sizeof(clntAddr);
		char id[MAX_USER_ACCOUNT_LEN], pwd[MAX_USER_ACCOUNT_LEN];
		int id_len, pwd_len;
		
		// 연결 요청 수락
		int clntSock = accept(servSock, (struct sockaddr*)&clntAddr, clntAddrLen);
		if (clntSock < 0)
			DieWithSystemMessage("accept() failed");
			
		printf("\n >>> Connected to Client: ");
		PrintSocketAddress((struct sockaddr*)&clntAddr, stdout);
		
		memset(id, 0, MAX_USER_ACCOUNT_LEN);
		memset(pwd, 0, MAX_USER_ACCOUNT_LEN);
		
		recv_msg(clntSock, id, &id_len,, pwd, &pwd_len);
		printf("\n%s's OTP: ", id);
		hexprint((const unsigned char*)pwd, pwd_len);
		if (authenticate_user(id, id_len, pwd, pwd_len)) {
			sprintf(buffer, "Welcome %s", id);
			printf("The User %s is successfully authenticated\n", id);
			len = strlen(buffer);
		}
		else {
			strcpy(buffer, "Authentication failed. Please re-enter");
			printf("The User %s is declined\n", id);
			len = strlen(buffer);
		}
		
		numBytesSent = send(clntSock, buffer, len, 0);
		if (numBytesSent < 0)
			DieWithSystemMessage("send() failed");
		else if (numBytesSent != len)
			DieWithUserMessage("send()", "sent unexpected number of bytes");
			
		close(clntSock);	
	}
	close(servSock);	
}
```

---
## 중요한 단어
1. 인증 암호
2. EtM, E&M, MtE
3. 연관 데이터
4. AEAD
5. TOTP