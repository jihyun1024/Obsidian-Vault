## 동작 분석 Warn-Up
x64dbg에 랜섬웨어를 물려 놓고 F9 키를 여러 번 누르면 [[함수 프롤로그 & 에필로그|함수 프롤로그]]를 발견할 수 있다. 

`다음을 찾기 > 모든 모듈 > 모듈간 호출`로 `Crypt`가 들어가는 암호화 관련 함수를 찾아보려 했으나, 유의미한 결과가 나오지 않아 랜섬웨어 관련 핵심 함수에 뭔가 난독화 같은 게 적용되었다고 추측할 수 있었다. 
![[Pasted image 20251030173054.png]]
이는 DLL(Dynamic Link Library) 파일의 사용을 봐도 알 수 있듯이, 암호화 관련 DLL은 딱히 정의되지 않았던 것을 확인할 수 있다. 

반면, `File`로 필터링한 결과는 다음과 같이 정상적으로 나오기에 이 파일은 암호화 관련 함수, DLL 등 정적 분석에서 확인할 수 있는 것을 난독화하여 안티 바이러스 엔진을 회피한다. 
따라서, 랜섬웨어를 정상적으로 작동시키기 위해서는 **악성 행위 이전에 난독화를 해제하는 코드가 있을 것이라 예측할 수 있다.**

x32dbg 대신 x64dbg를 사용했기 때문에 전반적으로 뭔가 [[Ragnar Locker 랜섬웨어 분석]] 때보다 exe 파일 뒤의 숫자가 더 길어진 것을 확인할 수 있다. 
```assembly
sub rsp, 28
call lockbit.7FF7D30D0BC4
add rsp, 28
jmp lockbit.7FF7D30D06E0
```
(앞으로는 `lockbit.` 뒤의 중복되는 것은 생략하던가 해야겠다. 아마 `7FF7D3` 부분)
이제 해당 function call 또는 system call 지점에 중단점을 찍고, 한 줄씩 내려가면서 분석해 보자. 

먼저, `call lockbit.0D0BC4` 부분을 타고 들어가면 다음과 같으며, 실행하는 코드는 다음과 같다.
![[Pasted image 20251029041431.png]]
여기서는 `GetSystemTimeAsFile`, `GetCurrentThreadId`, `GetCurrentProcessId`, `QueryPerformanceCounter` 함수가 사용된다. 
이 함수들은 현재 시스템의 시간 정보와 현재 Thread, Process의 ID를 얻어 오는 데에 사용되어 랜섬웨어에서는 딱히 중요하지 않은 부분인 것 같아 넘어가도 될 것 같다.

이 함수를 나가서 `jmp 0D06E0`를 실행하면 다음 사진처럼 여러 함수가 밑에 있는 것을 확인할 수 있다. 이 중 가장 먼저 보이는 `lockbit.0D094C`를 먼저 분석해 보자. 
![[Pasted image 20251029042811.png]]

`jmp 0D06E0`를 수행하고 나서 가장 먼저 나오는 함수인 `lockbit.0D094C`의 내부에 들어가 보면 뭔가 연산을 엄청 많이 수행하는 `lockbit.0D0F90` 함수가 존재한다. 
이 때 이 함수를 자세하게 살펴보면 특정 메모리에 있는 값을 참조한 뒤, 각각의 레지스터에 있는 값들과 8자리 16진수 값 여러 개를 XOR 연산하는 것을 확인할 수 있었으며 r8d, r9d, r10d 레지스터의 XOR의 경우는 각각 RBX, RDX, RCX 레지스터의 값과 동일한 값을 XOR 한다는 것을 동적으로 확인할 수 있다. 
![[Pasted image 20251029075357.png]]
(이 사진에서 RAX, RBX, RCX, RDX, RBP 등의 레지스터의 값은 아직 XOR 하기 이전의 값이다)

이후로도 한 번 더 XOR 연산을 수행해 RCX, RDX 등의 레지스터의 값을 새로 지정하고, R8, R9 레지스터의 값을 0으로 설정하고, 이후 몇 번의 연산을 거친 뒤 함수 에필로그로 밖으로 나간다.

그 뒤로 `GetCommandLineA` 등의 여러 함수들을 수행하면서 랜섬웨어 파일이 있는 디렉터리를 한 문자씩 읽어 나간다. 
![[Pasted image 20251029081416.png]]

그 이후 실제 랜섬웨어의 시작 지점인 `lockbit.0CC030` 함수에 도착하게 된다. 여기까지는 랜섬웨어 시작 단계도 아닌 시작 준비 단계이기 때문에, 동작 과정을 소개할 때는 간단하게 소개하거나 아예 건너뛰어도 될 듯 하다. 

## 메인 함수 분석
랜섬웨어의 동작이 시작되는 함수인 `lockbit.0CC030` 함수에 도착해 F7으로 들어가 보면 다음과 같은 어셈블리 명령어들이 있는 것을 확인할 수 있다. 
![[Pasted image 20251030135502.png]]
이 사진은 나중에 발표를 위해 캡처해 두고, F7과 F8을 사용해 코드를 계속 실행하다 보면 `lockbit.0B3570` 함수 내부의 `lockbit.0B2F00` 함수에서 추가적인 함수 호출이 거의 없이 특정 코드를 반복 실행하는 것을 확인할 수 있었다. 
![[Pasted image 20251030142009.png]]

 `while` 연산이 끝난 뒤, 그 함수 내부에서도 `lockbit.0B2CA0`를 호출하며, 그 내부에서 실행을 마치고 마지막에`lockbit.0B4870` 함수를 호출한다.

`lockbit.0B4870` 함수 내부에서는 추가적인 함수 호출은 없었으며, 하단의 사진과 같이 특정 값인 `5BD1E995`를 기반으로 XOR, 오른쪽 비트 시프트 등의 연산을 여러 번 하는 것을 확인했다. 
![[Pasted image 20251030143936.png]]

### 암호화 관련 함수 분석: `lockbit.0B4650` 
여기까지만 봐서는 딱히 뾰족한 수가 없는 것 같으니 처음으로 돌아가서 메인 함수부터 먼저 살펴보자. 메인 함수는 아래의 사진처럼 다양한 함수를 호출한다. (아래의 사진은 일부이다)
![[Pasted image 20251030231850.png]]

이 중에는 특히 가장 많이 다른 함수에 의해 호출되는 함수인 `lockbit.0B4650` 함수가 있다. 즉, 이 함수는 함수 실행 중에 발생하는 오류 처리를 담당하거나, 아니면 난독화된 암호화 기능 담당 함수일 수 있다. 

그러나, `lockbit.0B3570` 함수 쪽에서는 한 번도 해당 함수와 그로부터 갈라지는 함수가 이 의문의 함수를 호출하지 않았기 때문에 오류 처리일 가능성은 낮으며, 따라서 이 함수는 **암호화 기능을 담당하는 함수**라고 할 수 있다. (단, 여러 가지 기능을 담당하는지, 단일 기능을 담당하는지는 아직 잘 모르겠다.)

이에 관련된 함수는 `lockbit.0B3570`와 그로부터 호출되는 함수까지 총 6개로, 그 함수들을 먼저 분석해야 할 것 같다. `lockbit.0B2F00`에서 호출되는 함수들은 어느 정도 분석해 봤으니 `lockbit.0B2BB0`에서 호출되는 함수들을 분석해 보자. 

### 관련 함수 분석: `lockbit.0B2BB0`
`lockbit.0B2BB0` 함수의 실행이 끝나면 갑자기 `lockbit....`으로 되어 있던 것이 `LoadLibraryA` 함수로 변경된다. 그리고 이 변경된 함수를 덤프해 따라가 보면 다음 사진과 같다.
![[Pasted image 20251031023027.png]]

이는 지정된 모듈을 이 프로세스의 주소 공간에 로드하는 함수로, 로드할 모듈의 이름을 매개변수로 받아서 동작한다. 
이후, 계속 실행하다가 `lockbit.0B38D0` 함수를 수행하고 나서 그 다음 명령어를 실행해 보면 EAX 레지스터에 본 적 없던 DLL인 `advapi32.dll`이 Import된 것을 확인할 수 있으며,(왼쪽) 해당 DLL로 들어가 보면 암호화 관련 함수들이 Import된 것을 확인했다. (오른쪽)
![[Pasted image 20251031052626.png|350]]![[Pasted image 20251031052653.png|350]]

따라서, 상단의 함수 그래프?에서 `lockbit.0B38D0`까지는 난독화된 암호화 관련 DLL을 난독화 해제하고, `call rax` 명령을 통해 RAX 레지스터에 있는 함수인 `CryptoAcquireContextA` 함수를 호출한다. 

### `lockbit.0B4650` 함수 재분석
이후, `lockbit.0B4650` 함수를 호출하는데, 매개변수로 16, 55, `0x70D2C0E4`를 받아 동작한다. 
![[Pasted image 20251031053921.png]]
이 때 `mov dword ptr ss:[rsp+F0], eax`부터 해당 줄 포함 4줄은 데이터를 복호화하기 위한 AES Key BLOB의 정보를 구성하는 구조체 변수로, 첫 번째 숫자인 208은 BLOB 형식과 키가 사용하는 알고리즘을 나타내는 PUBLICKEYSTRUC 구조체, 두 번째 숫자인 6610은 사용할 암호 알고리즘, 세 번째 숫자인 20은 키의 길이인 0x20, 즉 32-byte를 나타낸다. 

따라서, 사진에서도 볼 수 있듯이, 이번의 `lockbit.0B4650`함수는 다른 용도인 `CryptImportKey` 함수의 용도로 사용됨이 드러났다. *(설명할 때는 이 실행 결과 먼저 보여주고, 그 다음 Key BLOB의 설명을 하자)*
![[Pasted image 20251031054808.png]]

그 다음도 다시 이 함수를 호출하며, 이번에는 16, 111, `0xA1F10DB0`를 받아 움직인다. 
![[Pasted image 20251031055056.png]]
이번에는 `CryptSetKeyParam` 함수를 사용하여 IV의 값을 설정한다. 이 때 암호화된 랜섬노트에 하드코딩된 상태로 저장된 IV 값을 고정된 IV로 사용하며, Crypto API의 Default 운영모드는 CBC이기 때문에 복호화 알고리즘은 자연스럽게 AES-256-CBC로 설정된다. 
![[Pasted image 20251031055818.png]]

이후, 또 다시 16, 112, `0xDC0D9528`을 인자로 받는 동일한 함수가 호출되며, 이 함수는 `CryptDecrypt` 함수를 사용하여 첫 번째와 두 번째 `lockbit.0B4650` 함수 호출의 결과를 바탕으로 해서 랜섬노트 데이터를 AES-256-CBC 알고리즘으로 복호화한다. 
![[Pasted image 20251031060653.png|350]]![[Pasted image 20251031060957.png|350]]

복호화된 랜섬노트 데이터는 다음과 같다. (RSI 레지스터가 가리키는 곳에 있다)
![[Pasted image 20251031061136.png]]

이후, 특정 주소에 저장되어 있는 배열을 반복문을 통해 순회하며 0x78과 XOR 연산해 LockBit 랜섬웨어에 감염된 파일의 확장자인 `.fb7c204e`를 획득한다.
![[Pasted image 20251031062848.png]]


---
## 더 자세하고 추가적인 분석
[[LockBit 3.0 파일 암호화 알고리즘 파악]]
[[LockBit 3.0 랜섬웨어 복호화]]