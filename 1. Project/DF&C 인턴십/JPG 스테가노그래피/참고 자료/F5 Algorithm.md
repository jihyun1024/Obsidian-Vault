F5 알고리즘은 JPEG 파일에 데이터를 은닉하는 스테가노그래피 기법으로, 2001년 **Andreas Westfeld**가 발표했다. 
발표한 논문은 [이 사이트](https://link.springer.com/chapter/10.1007/3-540-45496-9_21)에서 볼 수 있으며, PDF 파일은 [이 사이트](https://digitnet.github.io/assets/pdf/f5-a-steganographic-algorithm-high-capacity-despite-better-steganalysis.pdf)에서 확인할 수 있다.

### 동작 원리
JPG 파일을 열면 헤더와 압축된 비트스트림이 들어 있다. 이 상태에서는 바로 [[DCT]] 계수를 수정할 수 없기 때문에 먼저 비트스트림을 디코딩 해야 한다. 
이 과정에서 사용되는 것이 Huffman Decoding이며, 이로 인해 비트스트림을 [[DEFLATE 압축 알고리즘#2. Huffman Coding (통계적 부호화)|Huffman Decoding]]해서 [[양자화 (Quantization)|양자화]]된 DCT 계수들을 복원할 수 있다. 

JPG 파일에서 이미지는 DCT와 양자화를 거쳐 손실 압축을 구현하고 이를 Huffman Coding으로 압축해 최종적으로 비트스트림을 저장한다. 
![[Pasted image 20250911014527.png|400x400]]

이때 F5 알고리즘에서는 DCT와 양자화를 거친 결과에 특수한 조치를 추가해 스테가노그래피 알고리즘을 구현할 수 있다. 전체 과정을 요약하면 다음과 같다. 

1. JPEG 디코딩 과정에서 Huffman Decoding 과정 수행
2. 난수 생성기를 사용자 password에서 추출한 키로 초기화
3. 순열 생성 (parameter: 난수, zero coefficient를 포함한 coefficient의 개수)
4. 은닉할 메시지의 길이에서 매개변수 $k$ 결정
5. 코드 단어 길이 $n=2^k-1$ 계산
6. 행렬 인코딩으로 메시지 은닉
7. 1.Huffman Coding을 포함한 JPEG 재변환 수행

![[Pasted image 20250911014504.png]]
동작이 다 끝나면, 다시 JPG로 만들기 위해 Huffman Coding으로 새로운 JPG 파일을 만든다. 

### Permutative Stradding
스테가노그래피를 실행하는 과정에서 단순히 왼쪽 위부터 메시지를 은닉하면 통계적으로 다음 사진처럼 패턴이 남을 수 있기 때문에 무작위로 DCT 계수, 즉 원본 이미지의 부분부분을 섞어서 패턴을 보이지 않도록 하는 작업이다. 
![[Pasted image 20250911015201.png|500x300]]

1. 계수 선택
	- 원본 이미지에서 Huffman Decoding으로 양자화된 DCT 계수를 복원한다. 
	- 이후 해당 DCT 계수들 중 0인 계수들과 MCU에 중요한 영향을 주는 DC 계수를 제외한 AC 계수들을 선택한다. 
2. 사용자 지정 Password 기반 난수 초기화
	- 사용자가 입력한 password를 바탕으로 난수 발생기를 초기화한다. 
	- 같은 password에 대해 매번 같은 값이 나와야 하기 때문에 이 때 사용하는 난수 발생기는 Deterministic한 난수 발생기여야 한다. 
3. 계수 인덱스 순열 생성
	- 2번 과정의 난수발생기에서 나온 난수를 써서 AC 계수의 인덱스를 무작위로 재배열한다. 
4. 메시지 은닉용 계수 배열 재배치
	- 위의 무작위로 재배열된 계수의 인덱스 배열을 바탕으로 AC 계수들을 재배치한다. 

위의 과정에서 AC 계수들이 재배열되도 상관없는 이유는 AC 계수들의 값이 조금 바뀌어도 사람의 눈에는 그다지 큰 차이가 없기 때문이다. 

해당 과정들이 실행된 이후, 재배열된 DCT 계수들은 다음에 나올 과정을 거친다. 

### Matrix Encoding
메시지를 최소한의 계수 변경으로 삽입하기 위한 과정이며, 다음과 같은 순서로 실행된다. 
아래의 과정에서 $k$는 은닉할 메시지 크기와 사용 가능한 DCT 계수의 개수 비율에 따라 결정되며, 그 값에 따른 계수 변경 확률, 은닉 효율 비교표는 다음과 같다. 
![[Pasted image 20250911021622.png]]

1. 은닉할 메시지 비트 분할: 메시지의 비트를 k 비트 단위로 분할
	• 각 블록마다 k 비트를 은닉해야 함
2. 계수 그룹화
	• 재배치된 계수들을 $n=2^k-1$개씩 묶음
	• 이 그룹 하나 = 메시지 블록 ($k$ 비트)을 저장할 단위
3. 계수 LSB 추출
	• 그룹 내 각 계수의 LSB(부호 포함)를 추출해서 벡터를 제작
	• 예시 > 계수: [5, -3, 2], LSB: [1, 1, 0]
4. LSB 벡터를 Hamming Code 방식으로 처리
	--> $k$ 비트(현재 그룹이 표현하는 값)를 얻고, 이를 삽입할 메시지 $k$ 비트와 비교
5. 필요 시 계수 수정
	1. 다를 때: 특정 하나의 계수만 수정해서 맞춤 (수정: 계수 하나를 ±1 해서 LSB 반전)
	2. 같을 때: 변경 없음
6. 다음 그룹으로 이동: 2 ~ 5 과정을 메시지의 다음 $k$ 비트에 대해 반복

![[Pasted image 20250911020535.png|400x400]]
이 사진에서의 예시를 보면서 이해해 보면 이해가 더 빠를 것이다. 

이 때 LSB를 바꾼다는 것이 이해가 잘 안 될 수도 있는데, 설명하면 다음과 같다. 
먼저, 메시지 2비트를 넣으려면 $k = 2$이기 때문에 계수는 $2^2 - 1 = 3$개 필요하다. 따라서, 각 계수의 절댓값 LSB를 뽑아서 [c1, c2, c3]라는 벡터를 만든다. 

이 벡터가 현재 그룹이 표현하는 값이 되며, 우리가 넣고 싶은 메시지 값(2bit, 11이라 가정)과 비교해서 맞지 않으면 계수 하나의 LSB만 뒤집어서 맞춘다. 

이 때 F5는 Hamming Code 원리를 사용하는데, LSB 벡터 [c1, c2, c3]의 의미는 
`현재 값 = (c1 ⊕ c3, c2 ⊕ c3)`이며, 예시 사진에서도 현재 값이 01이 된 것을 볼 수 있다. 
이는 은닉하고자 하는 메시지인 11과 맞지 않기 때문에 c3의 LSB만 뒤집으면 된다. 
이 과정은 논문에서 다음 수식과 함께 볼 수 있다. 

(x1, x2: 은닉할 메시지 비트, a1, a2, a3: 각각의 계수)
![[Pasted image 20250911023459.png]]

LSB를 뒤집을 때는 1을 해당 계수에 더하거나 빼서 LSB를 뒤집을 수 있다. 
이 때 해당 계수가 1 또는 -1일 경우 LSB를 뒤집으면 0이 되는데, 0은 고려하지 않았기 때문에 문제가 된다. 이를 Shrinkage 문제라 한다. 

### Shrinkage 문제
위에서 언급한 것처럼 LSB 변경 과정에서 변경된 계수가 0이 될 경우, [[DCT#JPEG에서 이미지 압축 처리 과정|런-렝스 부호화]]에서 코드의 길이가 달라져 메시지를 제대로 추출할 수 없게 된다. 

이 문제를 해결하기 위해 다음 방법을 사용한다. 

1. 그냥 0으로 만들기
	- Shrinkage 현상이 발생하면 계수를 0으로 둔다. 
	- 이 경우, 해당 계수는 더 이상 메시지 은닉에 사용할 수 없다. 
2. 메시지 비트 재삽입
	- Shrinkage 때문에 은닉하려던 메시지 비트가 손실되었으므로 해당 메시지 비트를 다음 계수 그룹에 다시 삽입을 시도한다. 
	- 즉, 이번 계수 그룹에서 안 됐으니 다음 그룹에서 해당 메시지를 다시 삽입 시도한다. 