
- [[#Jadx를 사용한 메시지 추출 알고리즘 분석|Jadx를 사용한 메시지 추출 알고리즘 분석]]
	- [[#Jadx를 사용한 메시지 추출 알고리즘 분석#메시지 추출을 위한 파일 입력|메시지 추출을 위한 파일 입력]]
	- [[#Jadx를 사용한 메시지 추출 알고리즘 분석#메시지 추출 수행|메시지 추출 수행]]
		- [[#메시지 추출 수행#1. 픽셀 배열 설정|1. 픽셀 배열 설정]]
		- [[#메시지 추출 수행#2. 헤더 초기화 및 설정|2. 헤더 초기화 및 설정]]
		- [[#메시지 추출 수행#3. 루프를 따라서 숨겨진 데이터 읽고 추출하기|3. 루프를 따라서 숨겨진 데이터 읽고 추출하기]]
		- [[#메시지 추출 수행#4. CRC32 체크섬 검증|4. CRC32 체크섬 검증]]
		- [[#메시지 추출 수행#5. 하드코딩된 바이트 배열과 XOR (선택)|5. 하드코딩된 바이트 배열과 XOR (선택)]]
		- [[#메시지 추출 수행#6. GZIP 압축 해제 (선택)|6. GZIP 압축 해제 (선택)]]
		- [[#메시지 추출 수행#메시지 추출 알고리즘 단계 요약|메시지 추출 알고리즘 단계 요약]]
	- [[#Jadx를 사용한 메시지 추출 알고리즘 분석#추출된 메시지가 텍스트인지 판단 및 인코딩|추출된 메시지가 텍스트인지 판단 및 인코딩]]

---
메시지 추출 알고리즘은 메시지 은닉과 비슷한 레벨에서 동작하지만, 다른 동작을 수행하기 때문에 Jadx 분석 도구에서 동일한 클래스에 해당 알고리즘이 정의되어 있을 것이라 판단했다. 
### Jadx를 사용한 메시지 추출 알고리즘 분석
따라서 메시지 은닉 알고리즘이 처음으로 정의되어 있던 SteganographyMainActivity 클래스에서 맨 먼저 보이며, 백그라운드에서 동작하는 `doInBackground` 메서드로 들어가 분석을 진행하였다. 
![[Pasted image 20250713134409.png]]
이 코드를 살펴보면, 상당히 복잡해 보이지만 부분적으로 살펴보면 간단하게 분석할 수 있었다. 
또한, [[메시지 은닉 알고리즘 파악]]을 이미 완료했으니, 추출은 그 역과정일 것이다.
#### 메시지 추출을 위한 파일 입력
세 번째 if문까지는 메시지 은닉 알고리즘에서의 파일 입력과 크게 다르지 않으며, 아래와 같은 순서로 동작한다. 
1. `objArr[0]`에는 URI 객체가 있다고 판단하고, 이를 URI 타입으로 형변환
2. 사용자가 선택한 파일의 URI로부터 입력 스트림을 열어 이미지 파일을 읽기 위한 스트림을 생성

단, 중간에 `if (!e.a.a.b.a.d.e(openInputStream)`이 있는데, 이는 입력한 파일이 PNG인지 아닌지 검사하는 메서드로, 파일 탐색기에서는 JPG로 저장된 은닉 파일이 실제로는 PNG인 것을 이용한 것이다. 
![[Pasted image 20250717143546.png]]
#### 메시지 추출 수행
이후, 메시지 추출을 수행하는데, 이는 메시지 은닉의 반대 과정으로, LSB 추출 -> CRC 값 검증 -> 하드코딩된 바이트 배열과 XOR -> GZIP 압축 해제의 순서로 진행되며, 이때 검증하는 CRC 값은 추출된 메시지에 대한 CRC 값이다. 
이후 추출된 메시지가 없을 경우, 오류 메시지를 출력한다. 
![[Pasted image 20250717143830.png]]
메시지를 은닉하는 메서드인 `e.a.a.b.a.d.b`메서드에 대해 더 자세하게 분석해 보자.
##### 1. 픽셀 배열 설정
먼저 `width, height` 변수에 이미지의 가로와 세로 길이를 저장하고, `i3`변수에 `(width * height * 3) / 8`을 저장해서 `i3`가 8보다 작다면 `null`을 반환한다. 
이후 새롭게 만들어진 `iArr` 배열에 [[bitmap.getPixels]] 메서드를 사용해 이미지의 픽셀 데이터를 저장한다.
![[Pasted image 20250717163740.png]]
이 때 `i3 < 8`이면 `null`을 반환하도록 설계한 이유는 다음과 같다. 
1. `i2`: 전체 픽셀의 수
2. `* 3`: 픽셀 하나당 R, G, B 세 개의 채널에서 각각 1비트씩 3비트를 은닉에 사용
3. `/ 8`: 8비트 = 1바이트 이기 때문에 바이트 단위로 연산하기 위해
4. `< 8`: 최소로 필요한 8바이트보다 작으면 실패
	1. 시그니처 2바이트: `F6 D1`
	2. 압축 여부 또는 XOR 여부를 나타내는 flag 1바이트
	3. 메시지 길이 3바이트
	4. CRC 체크섬 길이 2바이트
	5. 헤더만 이렇게 8바이트인데, 이 8바이트도 숨기지 못하면 본문 데이터는 애초에 없다는 뜻이기 때문에 `null`을 반환한다. 
##### 2. 헤더 초기화 및 설정
이후 위에서 설명했던 것처럼 여러 메타데이터를 넣을 버퍼를 설정한다. 
![[Pasted image 20250717164220.png]]
##### 3. 루프를 따라서 숨겨진 데이터 읽고 추출하기
그 뒤 while 루프를 따라서 숨겨진 데이터를 읽고 LSB 형식으로 데이터를 추출한다. 
이번에는 메시지 은닉 알고리즘 설명과 다르게 짤막하게 요약할 것이다. 
```java 
while (true) {
	// 첫 번째 파트트
	if (i6 == i4 || i7 < i6 + 0x6 + 0x2) {
	    int i13 = 0x0;
		int i14 = 0x0;
		while (i13 < 0x8) {
			int i15 = 0x1 << (0x10 - ((i13 % 0x3) * 0x8));
			int i16 = (i13 == 0x2 || i13 == 0x5 || i13 == 0x7) ? 0x1 : 0x0;
			int i17 = iArr[i10];
			boolean z = (i17 & i15) != 0x0;
  
            i11 += i16;트  
        bArr2[i7] = (byte) i14;
        if ((i9 & 0x1) != ((bArr2[i7] ^ i7) & 0x1)) {
            break;
            }
        if (i7 != 0x5) {
            i5 = 0x0;
		    } else {
            if ((bArr2[0] & 0xff) != 0xf6 || (bArr2[1] & 0xff) != 0xd1) {
                break;
            }
            i8 = bArr2[2] & 0xff;
            i6 = ((bArr2[3] & 0xff) << 0x10) | ((bArr2[4] & 0xff) << 0x8) | (bArr2[5] & 0xff);
            byte[] bArr3 = new byte[i6 + 0x6 + 0x2];
            i5 = 0x0;
            System.arraycopy(bArr2, 0x0, bArr3, 0x0, 0x6);
            bArr2 = bArr3;
        }
        i7++;
        i4 = 0xffffffffffffffff;
     }
```
첫 번째 파트부터 분석해 보면 
1. R, G, B 순서대로 돌아가며 LSB를 추출해서 한 바이트를 모은다. 
2. 다음 픽셀로 넘어갈지 판단한다. (넘어가는 경우: 2, 5, 7번째 비트일 때)
3. 현재 픽셀에서 비트를 추출한다.
4. 가로줄 한 줄이 끝나면 다음 줄로 넘어가면서 LSB를 추출한다.
5. 비트 8개를 모아 1바이트로 조립하며, 이 과정에서 모아진 비트는 MSB에 있었다가 LSB쪽으로 시프트되어 이동하며 누적되는 식으로 조립된다.
6. 만들어진 바이트를 바이트 배열에 누적해서 저장한다.
7. 이미지의 세로, 즉 이미지의 끝에 도달하면 stop

두 번째 파트도 이와 같이 분석해 보자.
1. 메시지 은닉 과정에서 오류 체크를 위해 마지막 비트는 따로 연산을 했는데, 이의 역과정으로 오류 검사를 하며 오류가 있을 경우, break해서 끝낸다.
2. 이후 `bArr[]`배열에서 시그니처 `F6 D1`을 또 검사한다.
3. `i6` 변수는 `bArr`배열에서 파싱된 것으로, 은닉된 바이트의 길이를 나타낸다. 
4. 헤더와 추출된 데이터를 배열에 저장한다.
##### 4. CRC32 체크섬 검증
![[Pasted image 20250717170416.png]]
그 이후는 헤더를 읽은 것으로 판단해서 본문 차례이므로 은닉한 메시지에 대한 CRC 체크섬을 검증한다. 
##### 5. 하드코딩된 바이트 배열과 XOR (선택)
CRC 체크섬이 검증되면, 선택 사항으로 바이트 배열과 XOR을 수행한다. 
그 조건은 `i8(flag) & 0x10 != 0`인 경우이다. ![[Pasted image 20250717170724.png]]
##### 6. GZIP 압축 해제 (선택)
선택 사항으로 GZIP 압축을 해제하여 최종적으로 추출된 메시지를 반환한다. 
그 조건은 `i8 & 0x40 != 0`인 경우이다.
![[Pasted image 20250717170753.png]]
따라서 최종적으로 추출된 객체는 헤더 + 데이터 + CRC 체크섬으로 이루어진 객체가 반환된다.
##### 메시지 추출 알고리즘 단계 요약
1. 이미지 입력 (RGBA 형식)
2. LSB 방식으로 1바이트씩 메시지 추출
	1. 픽셀의 R, G, B 순서대로 LSB를 추출
	2. 2, 5, 7번째 비트에서 다음 픽셀로 이동하면서 추출
3. 새로운 바이트 배열 선언
	1. `F6 D1`: 검증을 위해 앱 개발자가 선언한 시그니처
	2. GZIP 압축 여부 또는 XOR 암호화 여부를 나타내는 flag
4. 픽셀을 순회하면서 은닉된 바이트의 길이 파싱
5. CRC32 검증
6. (선택 사항) XOR 복호화
7. (선택 사항) GZIP 압축 해제
8. 숨겨진 메시지 반환
#### 추출된 메시지가 텍스트인지 판단 및 인코딩
![[Pasted image 20250717143839.png]]
메시지 추출 수행 과정에서 반환된 `b2`값은 추출된 메시지 문자열이 아닌 Object(객체)로, 헤더 + flag + 은닉된 문자열 + CRC32 체크섬으로 이루어져 있다. 
이 과정은 추출된 메시지가 텍스트인지만 판단하기 때문에 코드 분석에는 큰 어려움이 없지만, 그래도 분석해 보면 `intValue`, 즉 `b2`의 첫 번째 원소가 2나 10이 아니라면 텍스트가 인코딩되지 않은 것으로 판단해 에러를 반환한다. 
이 과정은 메시지 추출 도구 제작에서는 굳이 넣지 않아도 되는 부분으로 판단해 넣지 않았다. 