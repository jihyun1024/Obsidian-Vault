
- [[#Retro Steganography 동작 파악|Retro Steganography 동작 파악]]
- [[#Jadx를 사용한 메시지 은닉 알고리즘 분석 (上)|Jadx를 사용한 메시지 은닉 알고리즘 분석 (上)]]
	- [[#Jadx를 사용한 메시지 은닉 알고리즘 분석 (上)#입력받은 이미지 파일을 읽을 수 있도록 준비|입력받은 이미지 파일을 읽을 수 있도록 준비]]
	- [[#Jadx를 사용한 메시지 은닉 알고리즘 분석 (上)#입력받은 파일이 JPG 또는 JPEG 포맷인지 검사|입력받은 파일이 JPG 또는 JPEG 포맷인지 검사]]
- [[#JPG 파일 형식을 따로 if문으로 체크한 이유|JPG 파일 형식을 따로 if문으로 체크한 이유]]
- [[#Jadx를 사용한 메시지 은닉 알고리즘 분석 (下)|Jadx를 사용한 메시지 은닉 알고리즘 분석 (下)]]
	- [[#Jadx를 사용한 메시지 은닉 알고리즘 분석 (下)#메시지 은닉|메시지 은닉]]
	- [[#Jadx를 사용한 메시지 은닉 알고리즘 분석 (下)#.JPG를 넣어 훼이크 및 저장|.JPG를 넣어 훼이크 및 저장]]

---
### Retro Steganography 동작 파악
애플리케이션에서 메시지를 은닉한 결과물의 파일 형식 등의 정보를 얻기 위해 다양한 이미지 파일을 넣고 메시지인 "I am Iron man"을 은닉해 보았음
![[Pasted image 20250710143052.png]]
그 결과, 원본 파일 형식에 상관없이 (메시지를 은닉한 시간을 Unix timestamp로 변환한 문자열).jpg의 형태로 저장하는 것을 확인할 수 있었음. 
그러나, Hex Editor로 열어 본 결과, 4개의 샘플 파일 모두 이름만 jpg로 표시되고 실제로는 [[PNG의 구조|png 파일 포맷]]으로 저장된 것을 확인할 수 있었음. 
![[Pasted image 20250710143300.png]]

### Jadx를 사용한 메시지 은닉 알고리즘 분석 (上)
결과물은 어쨌든 .jpg로 저장되었기 때문에 그와 관련 있는 코드를 검색하면 그 이전이나 이후의 코드가 메시지 은닉을 수행하는 알고리즘과 관련이 있을 것이라 생각했고,
Jadx 검색창에 코드(대소문자 구분 안 함)만 선택해서 jpg를 검색한 결과 다음과 같이 4개의 검색 결과를 도출하였음. 
![[Pasted image 20250710143702.png]]

이 중 첫 번째의 정규 표현식을 타고 들어가 보면 다음과 같은 코드를 살펴볼 수 있었음.
```java fold title=정규표현식코드 
if (!(TextUtils.isEmpty(lastPathSegment) ? false : lastPathSegment.matches("([^\\s]+(\\.(?i)(jpg|png|gif|bmp|webp))$)"))) {
  
            String valueOf2 = String.valueOf(lastPathSegment);
  
            d(valueOf2.length() != 0x0 ? "Image type not recognized: ".concat(valueOf2) : new String("Image type not recognized: "));
  
            return;
        }
```
그러나, 이 정규 표현식과 맞지 않는 파일인 DNG 파일을 넣어서 동작했음에도 메시지 은닉과 추출 모두 잘 동작하는 것으로 봐서 이 코드는 원본 이미지의 형식과는 상관없는 코드임을 알 수 있었음. 

그 다음은 2번째 검색 결과와 3번째 검색 결과로, 두 코드는 다음과 같이 서로 연결되어 있었음.
```java
if (!lastPathSegment.endswith(".jpg")) {
	lastPathSegment = lastPathSegment + ".jpg";
}
```
이 코드를 보면 파일의 확장자가 jpg가 아닐 경우, 강제로`.jpg`를 붙여 JPG 파일처럼 보이게 하는 코드이기 때문에 그 근처의 코드들에 답이 있을 것이라 생각했음. 
![[Pasted image 20250710145451.png]] -> 그 근처의 코드

따라서 그 근처의 코드인 `doInBackground`메서드를 집중적으로 분석했고, 부분적으로 나눠서 살펴보면 
#### 입력받은 이미지 파일을 읽을 수 있도록 준비
```java
Uri uri = (Uri) objArr[0];
String str = (String) objArr[1];
  
try {
    InputStream openInputStream = SteganographyMainActivity.this.getContentResolver().openInputStream(uri);
  
    if (openInputStream == null) {
        throw new IOException("Provider recently crashed.");}
  
    PushbackInputStream pushbackInputStream = new PushbackInputStream(new BufferedInputStream(openInputStream), 0x100);
```
* 받은 Object 배열의 0번째 원소에는 [[URI(Universal Resource Identifier)|URI]] 객체가 들어 있다 가정하고, 이를 URI 타입으로 형변환
* 1번째 원소에는 String이 들어 있다 가정하고, 이를 String으로 형변환
* 0번째 원소, 즉 [[URI(Universal Resource Identifier)|URI]] 경로에 해당하는 받은 이미지를 [[ContentResolver]]를 이용하여 가져와 `openInputStream`에 저장한다.  
* [[PushbackInputStream]]과 [[BufferedInputStream]]을 사용하여 내용물을 읽고 다시 되돌려 놓을 수 있는 기능인 Pushback과 버퍼링으로 파일을 읽을 수 있도록 준비한다. 
#### 입력받은 파일이 JPG 또는 JPEG 포맷인지 검사
이후 다음 코드를 실행한다. 
```java
boolean d2 = e.a.a.b.a.d.d(pushbackInputStream);

// d 메서드 코드
public static final boolean d(InputStream inputStream) {
	try {
		byte[] bArr = new byte[4];
		new DataInputStream(inputStream).readfully(bArr);
		((PushbackInputStream) inputStream).unread(bArr, 0, 4);

		if ((bArr[0] & 255) == 255 && (bArr[1] & 255) == 216) {
			if ((bArr[2] & 255) == 255) {
				return true;
			}
		}
		return false;
	} catch (Exception e2) {
		Log.w(a, e2.getMessage(), e2);
		return false;
	}
}
```
해당 코드가 실행되면 `pushbackInputStream`을 인자로 받으며, 새로운 4칸짜리 바이트 배열 `bArr`에 `pushbackInputStream`을 읽은 후 첫 4개의 문자를 담아 16진수 값 `FF D8 FF`와 비교한다. 

이 경우는 이미지 파일 포맷과 관련이 있는 것으로, 파일의 시그니처를 검사한다.
* JPG: `FF D8 FF E0`로 시작한다. 
* JPEG: `FF D8 FF E1`으로 시작한다. 
따라서, 둘의 공통적인 시그니처인 `FF D8 FF`를 검사하여 `true` 또는 `false`를 반환한다.

다시 `doInBackground`로 돌아와서, Input으로 넣은 파일이 JPG가 맞을 경우, 다음 코드를 실행한다. 
```java
Bitmap decodeStream = BitmapFactory.decodeStream(pushbackInputStream);
  
if (decodeStream == null) {
	  throw new IOException("Can not load bitmap file."); 
}
if (d2) {
	decodeStream = e.a.a.b.a.d.c(decodeStream, (byte) 10, 3.0f);
}

// c 메서드 코드
public static final Bitmap c(Bitmap bitmap, byte b2, float... fArr) {
	int width = bitmap.getWidth();
	int height = bitmap.getHeight();
	int i = width * height;
	int[] iArr = new int[i];
	bitmap.getPixels(iArr, 0x0, width, 0x0, 0x0, width, height);
	int i2 = 0x0;

	switch (b2) {
		case 10:
			int i3 = (int) fArr[0];
			int i4 = 0;
			for (int i5 = 0; i5 < i3; i5++) {
				i4 |= 1 << i5;
			}
			int i6 = i4 ^ (-1);
			int i7 = i6 & 255;
			int i8 = (i4 + 1) >>> 1;
			
			// 특히 해석이 어려웠던 코드
			while (i2 < i) {
				int i9 = iArr[i2];
				iArr[i2] = Math.min(i7, ((i9 & 0xff) + i8) & i6) | (((i9 >>> 0x18) & 0xff) << 0x18) | (Math.min(i7, (((i9 >>> 0x10) & 0xff) + i8) & i6) << 0x10) | (Math.min(i7, (((i9 >>> 0x8) & 0xff) + i8) & i6) << 0x8);
				i2++;
			}
		// 나머지 case 11, 12, 13은 생략함.
	}
	return Bitmap.createBitmap(iArr, width, height, Bitmap.Config.ARGB_8888);
}
```
많이 복잡하긴 한데, 차근차근 해석하면 다음과 같은 역할을 수행한다. 
* 이미지 데이터가 들어 있는 `pushbackInputStream`을 [[Bitmap]] 객체로 디코딩 하여 `decodeStream`에 저장한다. 
* 이미지가 JPG 포맷일 경우, C 메서드를 수행한다. (여기서는 수행하는 경우만 설명하겠다)
* 인자로 `decodeStream`과 바이트 0x0a, 부동소수점 숫자 3.0을 받는다. 
* 받은 [[Bitmap]] 객체인 `decodeStream`에서 가로와 세로의 길이를 받는다. 
* [[bitmap.getPixels]] 메서드를 이용해 비트맵의 여러 픽셀들을 하나의 배열인`iArr`로 전부 가져온다. 
* `b2`가 0x0a이므로 `case 10`을 수행한다. 
* `i3` = 3
* `i4`= 0 -> for 반복문을 돌면서 `i4`를 계속 1씩 왼쪽으로 비트 시프트하여 7로 설정한다. 
* `i6`= -8
* `i7`= 248
* `i8`= 4 (`i4`와 1을 더한 뒤 1만큼 오른쪽으로 비트 시프트한 결과)
* while 반복문을 `i2`= 0일 때부터 시작하여 `iArr`의 각각의 원소, 즉 각각의 픽셀에 대하여 전처리를 수행한다. 
* 이후 전처리를 수행한 픽셀들의 배열인 `iArr`과 이전에 구해 놓았던 가로,세로의 길이, 그리고 **ARGB**로 구성된 새로운 비트맵을 반환한다.

### JPG 파일 형식을 따로 if문으로 체크한 이유
위의 코드에서 JPG만 따로 전처리를 수행하는 것을 확인할 수 있었다. 이렇게 전처리를 수행하고 ARGB 색 공간으로 구성된 새로운 비트맵을 설정하는 이유는 JPG와 다른 파일 포맷 간의 차이에 있다. 

![[Pasted image 20250710164924.png]]
색 공간에는 여러 가지가 존재한다. 
* **RGB** (Red, Green, Blue) - 필요에 따라 투명도를 나타내는 Alpha 채널도 포함될 수 있다
* **HSV** (Hue-색상, Saturation-채도, Value-명도)
* **YCbCr** (Y-휘도=밝기, Cb-파란색에서의 색차, Cr-빨간색에서의 색차)
 
![[Pasted image 20250710164403.png]]
그러나 위의 표에서 보듯 JPG만 기본 색공간으로 YCbCr을 사용하기 때문에 LSB 은닉을 사용하기 위해서는 PNG나 기타 다른 포맷처럼 RGB로 색상 공간을 변환하여야 한다. 
==**LSB를 YCbCr 이미지에 사용할 수는 있지만, Y 성분은 밝기 정보이기 때문에 RGB에서의 LSB와 달리 조작 시 시각적으로 더 눈에 띌 수 있기 때문이다.**==

### Jadx를 사용한 메시지 은닉 알고리즘 분석 (下)
JPG를 넣어 이미지 전처리가 실행되었거나 다른 포맷의 파일을 넣은 경우, 이후 메시지 은닉을 수행한다. 
#### 메시지 은닉
다음 코드를 실행하여 메시지를 은닉한다. 
```java fold-메시지_은닉_수행_코드
// d2 = 입력받은 파일이 JPG인지의 여부
Bitmap a = e.a.a.b.a.d.a(decodeStream, (d2 ? 0x8: 0x0) | 0x2, str);

// a 메서드 코드
public static final Bitmap a(Bitmap bitmap, int i, String str) {
  
        boolean z;
  
        try {
            byte[] bytes = str.getBytes("UTF-8");
            int i2 = (i & 0xfffffffffffffff8) | 0x2;
            if (bytes.length > 0xffffff) {
                throw new IllegalArgumentException("Text too long. Max length for package is 16777215");
            }

            int width = bitmap.getWidth();  
            int height = bitmap.getHeight();
            int i3 = width * height;
            if ((bytes.length * 0x3) + 0x18 > i3) {
                StringBuilder g = d.a.a.a.a.g("Text too long. Max length for image is ");
                g.append((i3 - 0x18) / 0x3);
                throw new IllegalArgumentException(g.toString());
            }
  
            int[] iArr = new int[i3];
            int[] iArr2 = iArr;
            bitmap.getPixels(iArr, 0x0, width, 0x0, 0x0, width, height);

            if (bytes.length > 0xffffff) {
                throw new IllegalArgumentException("Text too long. Max length for package is 16777215");
            }
  
            if ((i2 & 0x7) != 0x3 && bytes.length > 0x100) {
                int length = bytes.length;
                ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(length);
                GZIPOutputStream gZIPOutputStream = new GZIPOutputStream(byteArrayOutputStream);
                gZIPOutputStream.write(bytes, 0x0, length);
                gZIPOutputStream.finish();
                gZIPOutputStream.close();
                
                byte[] byteArray = byteArrayOutputStream.toByteArray();
                if (byteArray.length < bytes.length * 0.9f) {
                    bytes = byteArray;
                    z = true;

                    if ((bytes.length * 0x3) + 0x18 <= i3) {  
                        StringBuilder g2 = d.a.a.a.a.g("Text too long. Max length for image is ");
                        g2.append((i3 - 0x18) / 0x3);
                        throw new IllegalArgumentException(g2.toString());
                    }
  
                    int length2 = bytes.length + 0x6 + 0x2;
                    byte[] bArr = new byte[length2];
                    bArr[0] = 0xfffffffffffffff6;
                    bArr[1] = 0xffffffffffffffd1;
                    bArr[2] = (byte) (i2 | (z ? 0x40 : 0x0) | 0x10 | 0x0);
                    bArr[3] = (byte) (bytes.length >>> 0x10);
                    int i4 = 0x8;
                    bArr[4] = (byte) (bytes.length >>> 0x8);  
                    int i5 = 0x5;
                    bArr[5] = (byte) bytes.length; 
                    System.arraycopy(bytes, 0x0, bArr, 0x6, bytes.length);
                    f(bArr, 0x6, bytes.length, f6245a);
                    
                    CRC32 crc32 = new CRC32();
                    int i6 = length2 - 0x2;
                    crc32.update(bArr, 0x0, i6);
                    long value = crc32.getValue();
                    bArr[i6] = (byte) (r11 >>> 0x8);
                    bArr[length2 - 0x1] = (byte) ((value ^ (value >>> 0x10)) & 0xffff);
  
                    int i7 = 0x0;
                    int i8 = 0x0;
                    int i9 = 0x0;
                    int i10 = 0x0;

					//메시지 은닉 수행 시작
                    while (i7 < length2) {  // 전체 바이트를 순회
                        int i11 = bArr[i7] & 0xff; // bArr[i7]을 부호 없는 정수로 변환, 현재 바이트를 8비트로 꺼냄
                        int i12 = 0x0; 
                        while (i12 < i4) { // 바이트의 8비트를 하나하나 꺼내서 처리, 즉 바이트를 비트 단위로 이미지에 삽입 

							// RGB 색상의 특정 비트 위치를 계산 (i12 % 3 == 0이면 Red, i12 % 3 == 1이면 Green, i12 % 3 == 2이면 Blue)
                            int i13 = 0x1 << (0x10 - ((i12 % 0x3) * 0x8));
	                        // 다음 픽셀로 넘어갈지 결정 (1픽셀에서 RGB를 하나씩 썼으니, 원본 메시지의 3번째 비트마다 증가, 즉 매 3비트마다 다음 픽셀로 이동)
                            int i14 = (i12 == 0x2 || i12 == i5 || i12 == 0x7) ? 0x1 : 0x0;
                            // 현재 바이트의 LSB가 1인지 확인 
                            boolean z2 = (i11 & 0x1) != 0x0;
                            int[] iArr3 = iArr2;
                            int i15 = iArr3[i9] & (i13 ^ 0xffffffffffffffff);
  
                            if (!z2) {
                                i13 = 0x0;
                            }
  
                            int i16 = i15 | i13;
                            if (i12 == 0x7) {
                                i16 = (i16 & 0xfffffffffffffffe) | ((bArr[i7] ^ i7) & 0x1);
                            }
                            iArr3[i9] = i16;
                            i8 += i14;
                            i9 += i14;
                            if (i8 >= width) {
                                i10++;
                                if (i10 >= height) {
                                    throw new InternalError();
                                }
                                i8 = 0x0;
                            }
                            i11 >>>= 0x1;
                            i12++;
                            i5 = 0x5;
                            iArr2 = iArr3;
                            i4 = 0x8;
                        }
                        i7++;
                        i5 = 0x5;
                        i4 = 0x8;
                    }
                    return Bitmap.createBitmap(iArr2, width, height, Bitmap.Config.ARGB_8888);
                }
            }
            z = false;
            if ((bytes.length * 0x3) + 0x18 <= i3) {
            }
        } catch (UnsupportedEncodingException unused) {
            throw new InternalError("UTF-8");
        }
    }
```
두려워 하지 말고, 차근차근 분석해 보자. 
1. 먼저, 인자로 받은 `str`, 즉 처음에 String 타입으로 강제 형변환한 문자열을 유니코드 문자열에서 바이트 코드로 인코딩한다. (출처: [String과 getBytes 메소드](https://blog.naver.com/writer0713/220921933255)
2. `d2`, 즉 입력받은 이미지가 JPG인지 아닌지에 따라 `i2`의 값이 결정된다. 
	1. `d2 = true`일 경우, `i2 = 10`
	2. `d2 = false`일 경우, `i2 = 2`
3. 만약 입력받은 문자열(여기부터는 인코딩된 결과인 `bytes`로 표기)이 너무 길다면 오류를 반환한다.
4. 입력받은 비트맵의 가로와 세로를 각각 `width`와 `height`에 저장한다. 
5. `i3`는 `width`와 `height`를 곱한 결과값인 넒이로 계산된다. 
6. 만약 입력받은 문자열에 3을 곱하고 24를 더한 값이 `i3`보다 크다면 메시지가 너무 길다는 오류를 반환한다. (각 바이트는 픽셀에 3비트씩 저장되므로, 총 `bytes.length*3 + 24`비트가 필요하다.)
7. 새로운 int형 배열인 `iArr`을 `i3`만큼 선언하고, `iArr`배열을 `iArr2`라는 이름으로 레퍼런스 복사하여 동일한 배열 객체를 참조하게 한다. 
8. [[bitmap.getPixels]] 메서드를 사용해 `iArr` 배열에 입력받은 비트맵의 여러 픽셀을 한 번에 저장한다. 
	1. `i2 & 7 != 3`이고, 바이트 길이 > 256이면 [[GZIP Algorithm]]으로 받은 메시지를 압축한다. 
	2. 압축된 데이터를 담기 위한 공간인 `byteArrayOutputStream`을 `length`만큼 선언한다. 
	3. GZIP 압축 스트림 `GZIPOutputStream`을 생성하고, 압축 결과를 `byteArrayOutputStream`에 쓰도록 설정한다.
	4. 원본 바이트 배열 `bytes`의 0번 인덱스부터 `length`만큼 GZIP 압축 스트림에 기록하고, 이때 실제 압축 작업이 이루어진다. 
	5. 이후 압축 스트림을 마무리하고, 스트림을 닫아 GZIP 압축을 종료한다. 
	6. `byteArray`배열에 `byteArrayOutputStream`배열을 바이트 배열로 변환한 결과를 담는다.
10. 압축된 결과물인 `byteArray`배열의 길이가 원래 배열인 `bytes`의 길이의 90%보다 작다면, 압축이 잘 된 것으로 판단하고, 그 다음으로 넘어간다. 
11. `bytes` 배열에 압축된 결과 버전으로 결과물을 교체한다. 
12. `z = true`로 설정하여 압축 여부를 표시한다. 
13. 메시지를 압축한 이후에도 여전히 이미지의 전체 픽셀 수보다 크다면, 오류를 반환한다.
14. `length2`를 (압축된 메시지의 바이트 길이) + 8로 설정해 추가적인 정보를 담을 수 있게 한다. 
15. `bArr`배열을 `length2`만큼의 바이트 배열로 설정하고, 다음과 같은 정보를 담는다. 
	1. `bArr[0]`: -10
	2. `bArr[1]`: -47
	3. `bArr[2]`: 0
	4. `bArr[3]`: `bytes.length >>> 16`을 바이트로 저장한 값
	5. `bArr[4]`: `bytes.length >>> 8`을 바이트로 저장한 값
	6. `bArr[5]`: `bytes.length`를 바이트로 저장한 값
	7. `System.arraycopy` 메서드를 사용하여 `bArr[6]`에 `bytes.length`만큼의 데이터를 대입
	8. `bArr[i6]`: `i6 = length2 - 2`로, `bytes.length + 6` , 즉 `bArr[7]`에 해당하며, `(byte) (r11 >> 8)`의 값을 저장한다. (단, `r11`은 어디서 나온 것인지??)
	9. `bArr[length2 - 1]`: `bArr[]`배열의 마지막 원소로, `bArr[8]`에 해당하며, `(byte) ((value ^ (value >>> 16)) & 65535)`의 값을 저장한다.
16. `System.arraycopy` 메서드를 호출한 직후, f 메서드를 사용해서 `f6245a` 배열과 `bArr[]`배열의 헤더 뒤의 압축된 데이터를 XOR로 암호화한다. 
17. CRC32 체크섬을 통해 `bArr[7], bArr[8]`에는 CRC 검사용 값을 저장한다. 
18. 바이트 `bArr[]`을 8비트 단위로 읽고, 각 비트를 `iArr2[]`의 픽셀에 숨긴다.
	1. RGB 순서로 숨긴다는 증거: ARGB의 포맷에 있음
		1. A: 비트 24~31, R: 비트 16~23, G: 비트 8~15, B: 비트 0~7
	2. 따라서 `16 - ((i12 % 3) * 8)`이 Red에서 Blue까지 비트 위치를 계산한 구조가 됨.
>[!list]- 메시지 은닉 과정
>`while (i7 < length2)`: 전체 바이트를 순회하며 숨길 메시지의 각 바이트에 대해 처리
19. 최종적으로 새로운 비트맵 객체를 생성하여 이미지를 생성한다.

#### .JPG를 넣어 훼이크 및 저장
메시지 은닉이 다 끝나면, 다음과 같은 코드를 실행한다. 
```java
String lastPathSegment = uri.getLastPathSegment();
if (!lastPathSegment.endswith(".jpg")) {
	lastPathSegment = lastPathSegment + ".jpg";
}

int lastIndexOf = lastPathSegment.lastIndexOf(0x2e);
return new Object[]{null, a, SteganographyMainActivity.t(SteganographyMainActivity.this, a, lastPathSegment.substring(0x0, lastIndexOf) + "_" + ((System.currentTimeMillis() ^ System.nanoTime()) & 0xffffffffffL) + "." + lastPathSegment.substring(lastIndexOf + 0x1), str != null ? SteganographyMainActivity.this.getString(R.string.stg_msg_description_hidden_message_fmt, new Object[]{str}) : SteganographyMainActivity.this.getString(R.string.stg_msg_description_hidden_message))};
```
다루고 있는 파일의 확장자를 판단하여 jpg 파일이 아닌 경우, 이번에는 아까와 달리 그렇지 않은 모든 파일에 `.jpg`문구를 붙여 파일 탐색기에서 jpg 파일로 착각하도록 한다. 
더 정확하게 설명하면
1. URI 객체에서 마지막 경로 세그먼트를 가져온다.
2. 예: `content://example.com/images/photo -> photo`
3. 그 세그먼트가 jpg로 끝나지 않으면, `.jpg`를 붙인다.

이후, 파일의 이름을 변경한다. 
* `int lastIndexOf = lastPathSegment.lastIndexOf(0x2e);`: 기존 파일 이름에서 마지막 점의 위치를 찾는다.
* `lastPathSegment.substring(0x0, lastIndexOf)`: 파일 이름에서 확장자 앞까지 잘라낸다. 
* `System.currentTimeMillis() ^ System.nanoTime()`: 현재 시간(밀리초)과 현재 시간(나노초)을 XOR 연산한다. 
* `& 0xffffffffffL`: 위에서 만든 숫자의 하위 40비트만 사용한다. 
* `lastPathSegment.substring(lastIndexOf + 0x1)`: 확장자만 잘라낸다
* 최종적으로, 리턴한 파일의 이름은 (17로 시작하는 고유한 숫자).jpg가 된다.