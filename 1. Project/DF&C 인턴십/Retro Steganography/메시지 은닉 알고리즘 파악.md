
- [[#Retro Steganography 동작 파악|Retro Steganography 동작 파악]]
- [[#Jadx를 사용한 메시지 은닉 알고리즘 분석 (上)|Jadx를 사용한 메시지 은닉 알고리즘 분석 (上)]]
	- [[#Jadx를 사용한 메시지 은닉 알고리즘 분석 (上)#입력받은 이미지 파일을 읽을 수 있도록 준비|입력받은 이미지 파일을 읽을 수 있도록 준비]]
	- [[#Jadx를 사용한 메시지 은닉 알고리즘 분석 (上)#입력받은 파일이 JPG 또는 JPEG 포맷인지 검사|입력받은 파일이 JPG 또는 JPEG 포맷인지 검사]]
- [[#JPG 파일 형식을 따로 if문으로 체크한 이유|JPG 파일 형식을 따로 if문으로 체크한 이유]]
- [[#Jadx를 사용한 메시지 은닉 알고리즘 분석 (下)|Jadx를 사용한 메시지 은닉 알고리즘 분석 (下)]]
	- [[#Jadx를 사용한 메시지 은닉 알고리즘 분석 (下)#메시지 은닉|메시지 은닉]]
	- [[#Jadx를 사용한 메시지 은닉 알고리즘 분석 (下)#.JPG를 넣어 훼이크 및 저장|.JPG를 넣어 훼이크 및 저장]]

---
### Retro Steganography 동작 파악
애플리케이션에서 메시지를 은닉한 결과물의 파일 형식 등의 정보를 얻기 위해 다양한 이미지 파일을 넣고 메시지인 "I am Iron man"을 은닉해 보았음
![[Pasted image 20250710143052.png]]
그 결과, 원본 파일 형식에 상관없이 (메시지를 은닉한 시간을 Unix timestamp로 변환한 문자열).jpg의 형태로 저장하는 것을 확인할 수 있었음. 
그러나, Hex Editor로 열어 본 결과, 4개의 샘플 파일 모두 이름만 jpg로 표시되고 실제로는 [[PNG의 구조|png 파일 포맷]]으로 저장된 것을 확인할 수 있었음. 
![[Pasted image 20250710143300.png]]

### Jadx를 사용한 메시지 은닉 알고리즘 분석 (上)
결과물은 어쨌든 .jpg로 저장되었기 때문에 그와 관련 있는 코드를 검색하면 그 이전이나 이후의 코드가 메시지 은닉을 수행하는 알고리즘과 관련이 있을 것이라 생각했고,
Jadx 검색창에 코드(대소문자 구분 안 함)만 선택해서 jpg를 검색한 결과 다음과 같이 4개의 검색 결과를 도출하였음. 
![[Pasted image 20250710143702.png]]

이 중 첫 번째의 정규 표현식을 타고 들어가 보면 다음과 같은 코드를 살펴볼 수 있었음.
```java fold title=정규표현식코드 
if (!(TextUtils.isEmpty(lastPathSegment) ? false : lastPathSegment.matches("([^\\s]+(\\.(?i)(jpg|png|gif|bmp|webp))$)"))) {
  
            String valueOf2 = String.valueOf(lastPathSegment);
  
            d(valueOf2.length() != 0x0 ? "Image type not recognized: ".concat(valueOf2) : new String("Image type not recognized: "));
  
            return;
        }
```
그러나, 이 정규 표현식과 맞지 않는 파일인 DNG 파일을 넣어서 동작했음에도 메시지 은닉과 추출 모두 잘 동작하는 것으로 봐서 이 코드는 원본 이미지의 형식과는 상관없는 코드임을 알 수 있었음. 

그 다음은 2번째 검색 결과와 3번째 검색 결과로, 두 코드는 다음과 같이 서로 연결되어 있었음.
```java
if (!lastPathSegment.endswith(".jpg")) {
	lastPathSegment = lastPathSegment + ".jpg";
}
```
이 코드를 보면 파일의 확장자가 jpg가 아닐 경우, 강제로`.jpg`를 붙여 JPG 파일처럼 보이게 하는 코드이기 때문에 그 근처의 코드들에 답이 있을 것이라 생각했음. 
![[Pasted image 20250710145451.png]] -> 그 근처의 코드

따라서 그 근처의 코드인 `doInBackground`메서드를 집중적으로 분석했고, 부분적으로 나눠서 살펴보면 
#### 입력받은 이미지 파일을 읽을 수 있도록 준비
```java
Uri uri = (Uri) objArr[0];
String str = (String) objArr[1];
  
try {
    InputStream openInputStream = SteganographyMainActivity.this.getContentResolver().openInputStream(uri);
  
    if (openInputStream == null) {
        throw new IOException("Provider recently crashed.");}
  
    PushbackInputStream pushbackInputStream = new PushbackInputStream(new BufferedInputStream(openInputStream), 0x100);
```
* 받은 Object 배열의 0번째 원소에는 [[URI(Universal Resource Identifier)|URI]] 객체가 들어 있다 가정하고, 이를 URI 타입으로 형변환
* 1번째 원소에는 String이 들어 있다 가정하고, 이를 String으로 형변환
* 0번째 원소, 즉 [[URI(Universal Resource Identifier)|URI]] 경로에 해당하는 받은 이미지를 [[ContentResolver]]를 이용하여 가져와 `openInputStream`에 저장한다.  
* [[PushbackInputStream]]과 [[BufferedInputStream]]을 사용하여 내용물을 읽고 다시 되돌려 놓을 수 있는 기능인 Pushback과 버퍼링으로 파일을 읽을 수 있도록 준비한다. 
#### 입력받은 파일이 JPG 또는 JPEG 포맷인지 검사
이후 다음 코드를 실행한다. 
```java
boolean d2 = e.a.a.b.a.d.d(pushbackInputStream);

// d 메서드 코드
public static final boolean d(InputStream inputStream) {
	try {
		byte[] bArr = new byte[4];
		new DataInputStream(inputStream).readfully(bArr);
		((PushbackInputStream) inputStream).unread(bArr, 0, 4);

		if ((bArr[0] & 255) == 255 && (bArr[1] & 255) == 216) {
			if ((bArr[2] & 255) == 255) {
				return true;
			}
		}
		return false;
	} catch (Exception e2) {
		Log.w(a, e2.getMessage(), e2);
		return false;
	}
}
```
해당 코드가 실행되면 `pushbackInputStream`을 인자로 받으며, 새로운 4칸짜리 바이트 배열 `bArr`에 `pushbackInputStream`을 읽은 후 첫 4개의 문자를 담아 16진수 값 `FF D8 FF`와 비교한다. 

이 경우는 이미지 파일 포맷과 관련이 있는 것으로, 파일의 시그니처를 검사한다.
* JPG: `FF D8 FF E0`로 시작한다. 
* JPEG: `FF D8 FF E1`으로 시작한다. 
따라서, 둘의 공통적인 시그니처인 `FF D8 FF`를 검사하여 `true` 또는 `false`를 반환한다.

다시 `doInBackground`로 돌아와서, Input으로 넣은 파일이 JPG가 맞을 경우, 다음 코드를 실행한다. 
```java
Bitmap decodeStream = BitmapFactory.decodeStream(pushbackInputStream);
  
if (decodeStream == null) {
	  throw new IOException("Can not load bitmap file."); 
}
if (d2) {
	decodeStream = e.a.a.b.a.d.c(decodeStream, (byte) 10, 3.0f);
}

// c 메서드 코드
public static final Bitmap c(Bitmap bitmap, byte b2, float... fArr) {
	int width = bitmap.getWidth();
	int height = bitmap.getHeight();
	int i = width * height;
	int[] iArr = new int[i];
	bitmap.getPixels(iArr, 0x0, width, 0x0, 0x0, width, height);
	int i2 = 0x0;

	switch (b2) {
		case 10:
			int i3 = (int) fArr[0];
			int i4 = 0;
			for (int i5 = 0; i5 < i3; i5++) {
				i4 |= 1 << i5;
			}
			int i6 = i4 ^ (-1);
			int i7 = i6 & 255;
			int i8 = (i4 + 1) >>> 1;
			
			// 특히 해석이 어려웠던 코드
			while (i2 < i) {
				int i9 = iArr[i2];
				iArr[i2] = Math.min(i7, ((i9 & 0xff) + i8) & i6) | (((i9 >>> 0x18) & 0xff) << 0x18) | (Math.min(i7, (((i9 >>> 0x10) & 0xff) + i8) & i6) << 0x10) | (Math.min(i7, (((i9 >>> 0x8) & 0xff) + i8) & i6) << 0x8);
				i2++;
			}
		// 나머지 case 11, 12, 13은 생략함.
	}
	return Bitmap.createBitmap(iArr, width, height, Bitmap.Config.ARGB_8888);
}
```
많이 복잡하긴 한데, 차근차근 해석하면 다음과 같은 역할을 수행한다. 
* 이미지 데이터가 들어 있는 `pushbackInputStream`을 [[Bitmap]] 객체로 디코딩 하여 `decodeStream`에 저장한다. 
* 이미지가 JPG 포맷일 경우, C 메서드를 수행한다. (여기서는 수행하는 경우만 설명하겠다)
* 인자로 `decodeStream`과 바이트 0x0a, 부동소수점 숫자 3.0을 받는다. 
* 받은 [[Bitmap]] 객체인 `decodeStream`에서 가로와 세로의 길이를 받는다. 
* [[bitmap.getPixels]] 메서드를 이용해 비트맵의 여러 픽셀들을 하나의 배열인`iArr`로 전부 가져온다. 
* `b2`가 0x0a이므로 `case 10`을 수행한다. 
* `i3` = 3
* `i4`= 0 -> for 반복문을 돌면서 `i4`를 계속 1씩 왼쪽으로 비트 시프트하여 7로 설정한다. 
* `i6`= -8
* `i7`= 248
* `i8`= 4 (`i4`와 1을 더한 뒤 1만큼 오른쪽으로 비트 시프트한 결과)
* while 반복문을 `i2`= 0일 때부터 시작하여 `iArr`의 각각의 원소, 즉 각각의 픽셀에 대하여 전처리를 수행한다. 
* 이후 전처리를 수행한 픽셀들의 배열인 `iArr`과 이전에 구해 놓았던 가로,세로의 길이, 그리고 **ARGB**로 구성된 새로운 비트맵을 반환한다.

### JPG 파일 형식을 따로 if문으로 체크한 이유
위의 코드에서 JPG만 따로 전처리를 수행하는 것을 확인할 수 있었다. 이렇게 전처리를 수행하고 ARGB 색 공간으로 구성된 새로운 비트맵을 설정하는 이유는 JPG와 다른 파일 포맷 간의 차이에 있다. 

![[Pasted image 20250710164924.png]]
색 공간에는 여러 가지가 존재한다. 
* **RGB** (Red, Green, Blue) - 필요에 따라 투명도를 나타내는 Alpha 채널도 포함될 수 있다
* **HSV** (Hue-색상, Saturation-채도, Value-명도)
* **YCbCr** (Y-휘도, Cb-파란색에서의 색차, Cr-빨간색에서의 색차)
 
![[Pasted image 20250710164403.png]]
그러나 위의 표에서 보듯 JPG만 기본 색공간으로 YCbCr을 사용하기 때문에 LSB 은닉을 사용하기 위해서는 PNG나 기타 다른 포맷처럼 RGB로 색상 공간을 변환하여야 한다. 
==**LSB를 YCbCr 이미지에 사용할 수는 있지만, Y 성분은 밝기 정보이기 때문에 RGB에서의 LSB와 달리 조작 시 시각적으로 더 눈에 띌 수 있기 때문이다.**==

### Jadx를 사용한 메시지 은닉 알고리즘 분석 (下)
JPG를 넣어 이미지 전처리가 실행되었거나 다른 포맷의 파일을 넣은 경우, 이후 메시지 은닉을 수행한다. 
#### 메시지 은닉

#### .JPG를 넣어 훼이크 및 저장
메시지 은닉이 다 끝나면, 다음과 같은 코드를 실행한다. 
```java
String lastPathSegment = uri.getLastPathSegment();
if (!lastPathSegment.endswith(".jpg")) {
	lastPathSegment = lastPathSegment + ".jpg";
}

int lastIndexOf = lastPathSegment.lastIndexOf(0x2e);
return new Object[]{null, a, SteganographyMainActivity.t(SteganographyMainActivity.this, a, lastPathSegment.substring(0x0, lastIndexOf) + "_" + ((System.currentTimeMillis() ^ System.nanoTime()) & 0xffffffffffL) + "." + lastPathSegment.substring(lastIndexOf + 0x1), str != null ? SteganographyMainActivity.this.getString(R.string.stg_msg_description_hidden_message_fmt, new Object[]{str}) : SteganographyMainActivity.this.getString(R.string.stg_msg_description_hidden_message))};
```
다루고 있는 파일의 확장자를 판단하여 jpg 파일이 아닌 경우, 이번에는 아까와 달리 그렇지 않은 모든 파일에 `.jpg`문구를 붙여 파일 탐색기에서 jpg 파일로 착각하도록 한다. 
더 정확하게 설명하면
1. URI 객체에서 마지막 경로 세그먼트를 가져온다.
2. 예: `content://example.com/images/photo -> photo`
3. 그 세그먼트가 jpg로 끝나지 않으면, `.jpg`를 붙인다.

이후, 파일의 이름을 변경한다. 
* `int lastIndexOf = lastPathSegment.lastIndexOf(0x2e);`: 기존 파일 이름에서 마지막 점의 위치를 찾는다.
* `lastPathSegment.substring(0x0, lastIndexOf)`: 파일 이름에서 확장자 앞까지 잘라낸다. 
* `System.currentTimeMillis() ^ System.nanoTime()`: 현재 시간(밀리초)과 현재 시간(나노초)을 XOR 연산한다. 
* `& 0xffffffffffL`: 위에서 만든 숫자의 하위 40비트만 사용한다. 
* `lastPathSegment.substring(lastIndexOf + 0x1)`: 확장자만 잘라낸다
* 최종적으로, 리턴한 파일의 이름은 (17로 시작하는 고유한 숫자).jpg가 된다.