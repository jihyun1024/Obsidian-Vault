미국의 프로그래머 필 캐츠가 만든 무손실 압축 알고리즘으로, 32KB 윈도우 크기를 가지는 LZ77 압축 알고리즘으로 1차 압축한 후, 2차로 허프만 코드 알고리즘을 사용한다. 
[DEFLATE Compression Data Format Specification](https://datatracker.ietf.org/doc/html/rfc1951)

---
### 1. LZ77 (사전 기반 압축)
문자열에서 반복되는 패턴을 찾아서 참조로 변환한다. 

```
원본: ABABCABAB
검색 버퍼: [AB]
참조 가능: YES
결과 토큰: (2, 2, 'C') 
```
이 예시에서 보듯, 같은 문자열이 반복되면 "현재 위치에서 `거리`만큼 가면 `길이`만큼의 문자들과 일치하며, 그 다음 문자는 `다음 문자`이다"로 표현되는 (거리, 길이, 다음 문자) 토큰으로 변환한다. 
* 거리(offset): 현재 위치에서 이전에 동일한 문자열이 몇 글자 떨어져 있었는지
* 길이(length): 얼마나 긴 문자열이 반복되는지
* 다음 문자(literal): 반복 뒤에 오는 새로운 문자
##### 작동 방식
LZ77은 슬라이딩 윈도우 방식으로 동작한다. 
* 검색 버퍼: 과거의 데이터 (이미 본 데이터)
* look-ahead buffer: 현재 살펴 볼 데이터 (앞에 놓인 데이터)
둘 다 고정된 크기를 가지며, 윈도우처럼 왼쪽에서 오른쪽으로 이동한다. 

예제에서는 다음과 같이 동작한다: 
1. 첫 글자 A
	* 검색 버퍼는 비어 있으니 A는 반복하지 않는다.
	* 따라서 압축 결과는 (0, 0, 'A')가 되어 반복 없이 그냥 A를 저장한다. 
2. 두 번째 글자 B
	* 검색 버퍼: A
	* look-ahead buffer: BABCABAB
	* B 또한 검색 버퍼에 없으므로 (0, 0, 'B')가 되어 다음으로 넘어간다. 
3. 세 번째 글자 A
	* 검색 버퍼: AB
	* look-ahead buffer: ABCABAB
	* A가 검색 버퍼에 존재하고, 그 다음 character인 B 또한 검색 버퍼에 있으므로 일치하는 길이(length)는 2가 되며, 가장 가까운 위치(offset) 또한 2가 된다. 
	* 따라서 압축 결과는 (2, 2, 'C')가 되어 저장된다. 
##### 장점
1. 구현이 상대적으로 간단하고 실시간으로 데이터를 처리할 수 있다. 
2. 중복되는 문자열에 매우 강력하다. 
3. 스트리밍되는 데이터에도 사용할 수 있다. 
##### 단점
1. 압축률은 Huffman 알고리즘보다 낮을 수 있다. 
2. 이진 데이터나 난수에는 비효율적이다.
3. 슬라이딩 윈도우 알고리즘에서 버퍼 크기의 제한이 존재한다. 

---
### 2. Huffman Coding (통계적 부호화)
자주 나오는 문자에는 짧은 비트를, 드물게 나오는 문자에는 긴 비트를 할당하여 전체 데이터를 줄인다. 
```
A(빈도 10) -> 0
B(빈도 2) -> 11
C(빈도 1) -> 10
```
일반적으로 모든 문자는 고정된 길이의 비트로 표현된다. 하지만, 문자의 등장 빈도가 다르다면 자주 나오는 문자를 더 짧게 표현하여 같은 문자열이라도 더 작은 비트로 표현할 수 있게 되어 압축이 가능하다는 아이디어를 바탕으로 하는 알고리즘이다. 
##### 작동 방식
`A A A A B B C C D`라는 문자열이 있다고 가정하자.
이때 각각의 알파벳의 등장 빈도는 다음과 같다:
* A: 4번
* B: 2번
* C: 2번
* D: 1번

이 예제에서는 빈도표를 만들고, 최소 힙(Min Heap)으로 트리를 만들어 빈도가 낮은 문자부터 노드를 만들어 병합한다. 
```
Step 1:
D(1) + B(2) → 노드1(3)

Step 2:
C(2) + 노드1(3) → 노드2(5)

Step 3:
A(4) + 노드2(5) → 루트 노드(9)
```

이후 트리에 따라 왼쪽은 항상 0, 오른쪽은 1을 부여하고, 이에 맞춰 각 알파벳에 따라 인코딩한다. 
```
        [9]
       /   \
    A(4)   [5]
          /   \
        C(2)  [3]
              / \
           D(1) B(2)       
```

최종적으로, 인코딩된 결과는 다음과 같다. 
* 원본: `A A A A B B C C D`
* 인코딩된 결과: `0 0 0 0 111 111 10 10 110`
이 경우, 압축 전에는 9문자 x 8비트 = 72비트로 문자열을 표현하지만, 압축 후에는 17비트로 문자열을 표현할 수 있어 76.4%의 압축률을 확인할 수 있다. 
##### 중요한 특징
* 전치 코드: 어떤 코드도 다른 코드의 접두어가 아니기 때문에 디코딩이 가능하다. 즉, 인코딩한 문자열에서 원본 문자열로 완벽하게 복원할 수 있다. 
* 가변 길이 파싱: 전치 코드로 이진트리를 만들면 뒷부분을 고려할 필요 없이 트리를 참고하여 디코딩 할 수 있다.
* 최적성: 문자 단위에서 가능한 한 가장 짧은 평균 비트 길이를 제공하여 최적화를 수행한다. 
##### 장점
1. 특히 텍스트에 대하여 압축률이 좋다. 
2. 구현이 비교적 단순하다. 
3. 다양한 포맷에서 재사용이 가능하다.
##### 단점
1. 빈도표와 트리를 함께 저장해야 한다. 
2. 실시간 압축에는 느릴 수 있어 LZ77 등의 알고리즘을 같이 사용하여 보완이 필요하다. 
3. 빈도가 급격하게 변하는 경우, 빈도표 자체를 재생성해야 한다. 
