## 들어가며
---
### Web - 들어가며
---
우리는 일상 속에서 수많은 사람들과 의사소통을 하면서 살아간다. 가까운 상대와 통신할 때는 오프라인으로 대화를 한다. 가족과 아침을 먹으면서, 학교에서 친구들과 우리는 많은 시간을 이런 오프라인 방식의 의사소통에 사용한다. 

그러나, 물리적으로 멀리 떨어진 상대와 통신할 때는 말과 행동만으로는 의사소통이 원활하게 이루어지지 않는다. 그래서 과거에는 비둘기나 말을 사용하거나 봉화 또는 연 등으로 통신을 했지만, 시간과 거리의 제약을 근본적으로 해소하지는 못했다. 

현대에는 기술이 매우 발전해서 전 세계에 걸쳐 있는 통신망을 사용해 다양한 나라의 사람들과 시공간의 제약 없이 통신할 수 있게 되었다. 

이 강의에서 소개할 웹(World Wide Web, W3, Web)은 현대 정보 통신을 대표하는 통신 수단 중 하나이다. 웹이란, 인터넷이라는 통신망을 사용해 구현된 전 지구적 정보 공간으로, 인터넷에 접속할 수만 있다면 웹에서 정보를 구하거나 공유할 수 있다. 웹으로 연결된 사람들 사이에 형성되는 정보의 흐름이 마치 거미줄과 비슷하다고 해서 웹으로 이름이 붙여졌다. 

이번 강의에서는 웹의 정의와 웹을 구현하는 여러 요소에 대하여 살펴본다. 

![[Pasted image 20251226184206.png]]


## Web
---
### 웹
---
인터넷을 기반으로 구현된 서비스 중 <u>HTTP를 이용하여 정보를 공유하는 서비스를 웹</u>이라 한다. 여기서 정보를 제공하는 주체를 **웹 서버(Web Server)**, 정보를 받는 이용자를 **웹 클라이언트(Web Client)** 라 한다. 

식당으로 비유하면, 식당에서 음식을 서빙하는 사람(Server)과 음식을 주문하는 고객(Client)의 관계로 생각하면 이해가 쏙쏙 될 것이다. 

![[이해가 쏙쏙.gif]]

**웹의 발전과 웹 보안의 중요성**
초기의 웹 서비스는 저장된 문서의 내용을 출력해 사용자에게 제공하는 간단한 서비스였다. 그런데 웹과 관련한 기술이 발전하면서 이제는 금융, 쇼핑, 협업, 메이플 인벤 등 다양한 분야에서 사용자에게 편의를 주는 복잡한 서비스로 진화했다. 과거에는 단순히 정보를 보여주는 것에서 그쳤다면, 현재는 정보를 검색하고 직접 제품을 구매할 수도 있도록 변화했다. 

이러한 웹의 발전은 우리의 일상을 많은 부분에서 바꿔놓았으며, 오프라인에서 이뤄지던 많은 상호작용들이 현재는 디지털 형태로 변환되어 웹 서비스로 구현되고 있다. 

한편, 웹에서 처리되는 정보들이 많아짐에 따라 동시에 이 정보들을 안전하게 보관하고 처리해야 할 필요성도 함께 증가하였다. 예를 들어, 고객이 물건을 구매하는 과정에서는 고객의 주소, 카드 번호 등의 정보들이 웹을 통해 서버로 전달된다. 만약 이 정보들이 보호되지 않는다면 고객에게 심각한 피해를 줄 수 있다. 그래서 웹을 통한 정보의 교환 과정에서 이러한 민감한 정보들이 유출되거나 악용되지 않도록 보호하는 웹 보안의 중요성이 커지고 있다. 

**웹 서비스, 프론트엔드와 백엔드**
Google, Firefox 등의 검색 서비스는 사용자가 "검색어"라는 형태로 자신이 원하는 정보를 추상화해서 전달하면, 검색 서비스가 이를 해석하고 가공해 필요한 정보를 제시한다. 

이런 서비스 구조에서, 사용자의 요청을 받는 부분은 **프론트엔드(Front-end)**, 요청을 처리하는 부분은 **백엔드(Back-end)** 라고 부른다. 호텔 프론트에 이런저런 서비스를 요청하면 뒤의 공간에서 고객 모르게 복잡한 일들이 벌어지는 것과 비슷하다. 

프론트엔드는 사용자에게 직접 보여지는 부분으로, **웹 리소스(Web Resource)** 라는 것으로 구성된다. 페이지가 보여주고 있는 정보들은 모두 웹 리소스에 명시되어 있다. 페이지에 담기는 글, 글자들의 색과 모양, 배경 색상, 이미지의 크기나 투명도 등이 관련 언어로 적혀 있다. 


### 웹 리소스
---
앞에서 소개한 웹 리소스란, 웹에 갖춰진 정보 자산을 의미한다. 웹 브라우저의 주소창에 `https://kookmin.ac.kr/index.html` 주소를 입력하면 `kookmin.ac.kr`에 존재하는 `/index.html` 경로의 리소스를 가져오라는 의미이다. 

모든 웹 리소스는 고유의 **Uniform Resource Identifier(URI)** 를 가지며, 이를 이용하여 식별된다. 웹의 프론트엔드를 구성하는 대표적인 웹 리소스들은 다음과 같다. 

- **Hyper Text Markup Language (HTML)**
	- 웹 문서의 뼈와 살을 담당
	- 태그와 속성을 통한 구조화된 문서 작성을 지원한다. 
- **Cascading Style Sheets (CSS)**
	- 웹 문서의 생김새를 담당, 웹 리소스들의 시각화 방법을 기재한 스타일 시트
	- 글자의 색깔이나 모양, 배경 색상, 이미지의 크기나 위치 등을 CSS로 지정 가능
	- 브라우저는 이를 참고해서 웹 문서를 시각화
- **JavaScript (JS)**
	- 웹 문서의 동작을 정의
	- 사용자가 버튼을 클릭했을 때 어떻게 반응할지, 사용자가 데이터를 입력하면 어디로 전송할지 등을 JS로 구현할 수 있음
	- 사용자의 브라우저에서 실행, 클라이언트에서 실행하여 Client-Side Script라고도 부름
- 그 외
	- 문서
	- 이미지
	- 동영상
	- 폰트
	- 등등

자세한 내용은 [[URI(Universal Resource Identifier)|URI]] 문서를 참고해도 괜찮을 것 같다...

![[Pasted image 20251226192837.png]]


### 웹 클라이언트와 서버의 통신
---
이번 강의에서 배운 내용을 정리하면 다음과 같다. 

1. (클라이언트) 사용자가 브라우저를 사용해 웹 브라우저에 접속한다. 
2. (클라이언트) 브라우저는 요청을 해석해 HTTP 형식으로 웹 서버에 리소스를 요청한다. 
3. (서버) HTTP로 전달된 사용자의 요청을 해석한다. 
4. (서버) 해석한 요청에 따라 적절한 동작을 수행한다. 리소스를 요청하는 것이라면, 이를 탐색하며 계좌 송금, 입금 등의 복잡한 동작을 요구할 때는 내부적으로 필요한 연산을 처리한다.
5. (서버) 사용자에게 전달할 리소스를 HTTP 형식으로 사용자에게 전달한다. 
6. (클라이언트) 브라우저는 서버에게 응답받은 HTML, CSS, JS 등의 웹 리소스를 시각화하여 사용자에게 보여준다. 

이를 그림으로 시각화하면 다음과 같다. 

![[Pasted image 20251226202919.png]]


## 들어가며
---
### HTTP/HTTPS - 들어가며
---
언어에서 문장의 의미는 문장을 구성하는 단어의 의미, 문법 구조, 맥락, 독자의 배경 지식 등으로 결정된다. 이 중 단어의 의미와 문법의 구조는 사회적으로 합의되어 있다. 

ㅅ, ㅏ, ㄱ, ㅗ, ㅏ를 결합한 "사과"가 과일 사과를 가리키는 것은 그렇게 하기로 약속했기 때문이다. 영어로 banana가 바나나를 가리키는 것도 마찬가지이다. 만약, 사람들이 "사과"로 쌀숭이를 가리키기로 약속했다면 우리는 쌀숭이를 가리켜 "사과"라고 부를 것이다. 

한편, 문법은 단어에 문장의 요소로서의 의미를 더해준다. 국어의 문법을 이해하고 있는 사람은 "드디어 신창섭이 메이플을 정상화하네"라는 문장을 읽고, 자연스럽게 "신창섭"이라는 주체가 "메이플"이라는 대상을 "정상화한다"고 이해한다. 이는 머릿속에서 자연스럽게 이뤄지는 것으로, 만약 "드디어 메이플이 신창섭을 정상화하네"라고 서술하면 문장의 의미는 완전히 달라진다. 

이처럼 언어에서 약속이란, 문장의 의미를 결정하는 매우 중요한 요소이다. 이는 컴퓨터에서도 마찬가지로 적용된다. 


### 인코딩
---
컴퓨터의 모든 데이터는 0과 1로 구성된다. 지금 보고 있는 글도 사실은 0과 1의 집합으로 컴퓨터에 저장된 것을 보기 좋게 구성한 것이다. 이때, 이렇게 구성하는 약속을 특별히 **인코딩(Encoding)** 표준이라고 부르는데, 대표적으로 **아스키(Ascii)** 와 **유니코드(Unicode)** 가 있다. 실습은 [여기](https://gchq.github.io/CyberChef/)서 진행할 수 있다. 

Ascii는 7비트 데이터에 대한 인코딩 표준이다. 이를 이용하면 알파벳과 특수 문자 들을 표현할 수 있다. 예를 들어, Ascii에서 1 한 개, 0 다섯 개, 1 한 개를 이어 붙여 1000001을 표현하면 "A"로 해석된다. 

컴퓨터가 개발된 초기에는 각 문자권마다 고유의 인코딩 표준을 사용해 호환성 측면에서 국제 소프트웨어를 개발하려는 회사에게 큰 부담이 되었다. 가끔 소프트웨어를 실행했을 때 글자가 이상하게 출력되는 것도 인코딩이 호환되지 않아 발생하는 문제이다. 

이러한 어려움을 해결하고자 Unicode라는 새로운 표준이 지정되었으며, "Uni", 즉 "하나의"라는 접두사가 나타내듯, 알파벳, 한글, 한자, 가타가나, 심지어는 이모지까지 최대 32개의 비트를 사용해 $2^{32}$개, 대략 42억 개의 정보를 표현할 수 있다. 


### 통신 프로토콜
---
웹 서버에 있는 리소스를 클라이언트가 받아서 보려면, 클라이언트는 웹에게 특정 리소스를 지정하여 제공해달라고 요청해야 한다. 그러면 서버가 해당 요청을 받아 이해하고, 대응되는 동작을 통해 클라이언트에게 리소스를 반환한다. 여기서 클라이언트의 행위를 요청(Request), 서버의 행위를 응답(Response)이라 한다. 

**프로토콜(Protocol)** 은 <u>이런 요청과 응답을 규격화해서 적용하는 약속</u>을 말한다. 일상생활에서 교수님과 대화할 때는 "안녕하십니까"로 시작해서 본론을 말하고, "안녕히 계십시오"로 끝낸다. 그런데 친구들과 대화할 때는 가끔 인삿말을 생략하거나, 맥락을 아는 사람만 이해하는 애매한 표현을 사용할 수도 있다. 

그러나, 컴퓨터와 통신할 때는 비교적 엄격한 프로토콜을 사용해야 한다. 왜냐하면, 컴퓨터가 해석의 융통성을 발휘하게 하는 것은 매우 어렵고, 이 과정에서 오히려 통신 오류가 발생할 수도 있기 때문이다. 그래서 많은 컴퓨터 통신 프로토콜은 각 통신 주체가 교환하는 데이터 = 메시지를 명확히 해석할 수 있도록 **문법(Syntax)** 을 포함하며, 이 문법에 어긋나는 메시지는 무시된다.

현재 제정된 표준 통신 프로토콜에는 네트워크 통신의 기초가 되는 TCP/IP, 웹 애플리케이션이 사용하는 HTTP, 파일을 주고받을 때 사용하는 FTP 등 매우 많은 종류가 있지만, 이번 강의에서는 그 중에서도 HTTP에 대해 배운다. 

![[Pasted image 20251226212822.png]]


## HTTP
---
### HTTP
---
**HTTP(Hyper Text Transfer Protocol)** 란 서버와 클라이언트의 데이터 교환을 **요청(Request)과 응답(Response)** 형식으로 정의한 프로토콜로, 팀 버너스 리(Team Berners-Lee)와 그의 팀이 제정한 이후, 현대 웹 서비스의 바탕이 되는 프로토콜이 되었다. 

HTTP의 기본 메커니즘은 <u>클라이언트가 서버에게 요청하면, 서버가 응답</u>하는 것이다. 웹 서버는 HTTP 서버를 *HTTP 서비스 포트*에 대기시킨다. 이는 일반적으로 TCP/80 또는 TCP/8080이다. 클라이언트가 서비스 포트에 HTTP 요청을 전송하면, 이를 해석하여 적절한 응답을 반환한다. 

>[!example] 네트워크 포트와 서비스 포트
>**네트워크 포트(Network Port)** 란 네트워크에서 서버와 클라이언트가 정보를 교환하는 추상화된 장소를 의미한다. 포트에는 항구라는 의미가 있는데, 클라이언트가 서버의 포트에 접근해서 데이터를 내려놓고, 서버가 클라이언트에 보낼 데이터를 실어 올려보내는 장면을 생각하면 포트의 기능을 이해할 수 있다. 편의상, 네트워크를 설명하는 맥락에서는 네트워크 포트 = 포트이다.
> 
>**서비스 포트(Service Port)** 는 네트워크 포트 중에서 특정 서비스가 미리 사용하기로 예약한 포트를 말한다. 예를 들어, HTTP가 80번 포트를 점유하고 있다면 HTTP의 서비스 포트는 80번 포트가 된다. 
>
>포트로 데이터를 교환하는 것은 **전송 계층(Transfer Layer)** 의 프로토콜을 따른다. 대표적으로는 TCP와 UDP가 있다. TCP로 데이터를 전송하려는 서비스에 UDP 클라이언트가 접근하면, 데이터가 교환되지 않는다(반대의 경우도 마찬가지). 그래서 서비스 포트를 표기할 때는 서비스가 사용하는 전송 계층 프로토콜 또한 같이 표기하기도 한다. 예를 들어, HTTP의 서비스 포트가 TCP/80이라면, HTTP 서비스를 80번 포트에서 TCP 프로토콜로 제공하고 있다는 의미이다. 
>
>포트의 개수는 운영체제에서 정의하기 나름이다. 그러나, 현대의 Windows나 Linux, Mac 운영체제에서는 0번부터 65535까지, 총 65536개의 같은 수의 네트워크 포트를 사용한다. 
>
>포트 중 0번부터 1023번까지의 포트는 잘 알려진 포트(Well-known port) 또는 특권 포트(Privileged port)라고 하며, 이는 문자 그대로 각 포트 번호에 유명한 서비스가 등록되어 있다. 대표적으로 22번 포트에는 SSH가, 80에는 HTTP, 443에는 HTTPS가 할당되어 있다. 특권 포트에 서비스를 실행하려면 관리자 권한이 필요하다. 따라서 클라이언트는 이 대역에서 실행 중인 서비스들은 관리자의 것이라고 신뢰할 수 있다. 


### HTTP 메시지
---
HTTP 메시지에는 클라이언트가 전송하는 HTTP 요청, 서버가 반환하는 HTTP 응답이 있다. 기능과 세부 구조에서는 차이가 있지만, 크게 보면 이들은 HTTP 헤더와 HTTP 바디로 구성된다. 

**HTTP 헤더**
HTTP 헤더(Headers) 각 줄은 CRLF로 구분되며, 첫 줄은 시작 줄(Start Line), 나머지 줄은 헤더(Header)라고 부른다. 영문 표기에서는 Headers와 Header이지만, 한국어에서는 모두 헤더로 부른다. <u>헤더의 끝은 빈 줄로</u> 나타낸다. 

시작 줄의 역할은 요청과 응답에서 큰 차이가 있다. 그러므로 이에 대해서는 조금 뒤에서 각각을 서술하면서 자세히 설명한다. 한편, 헤더는 **필드**와 **값**으로 구성되며, HTTP 메시지 또는 바디의 속성을 나타낸다. 하나의 HTTP 메시지에서는 0개 이상의 헤더가 있을 수 있다. 

**HTTPS 바디**
HTTP 바디(Body)는 헤더의 끝을 나타내는 CRLF 뒤의 모든 줄을 말하며, 클라이언트나 서버에게 전송하려는 데이터가 담긴다. 

>[!example] CRLF란?
>**CRLF**는 *Carriage Return (CR)* 과 *Line Feed (LF)* 의 조합을 나타낸다. Carriage Return은 커서를 현재 줄의 맨 앞으로 이동시키며, Line Feed는 커서를 다음 줄로 이동시킨다. 이것들은 주로 텍스트 파일에서 줄 바꿈을 나타내는 데 사용하는 제어 문자열로, Windows 운영체제에서는 줄을 종결하기 위해 CRLF를 사용하고, Linux 등의 Unix 기반 운영체제에서는 LF만을 사용한다. 

![[Pasted image 20251226230332.png]]


### HTTP 요청
---
**HTTP 요청**은 서버에게 특정 동작을 요구하는 메시지이다. 서버는 해당 동작이 실현 가능한지, 클라이언트가 그런 동작을 요청할 권한이 있는지 등을 검토하고, 적절할 때만 이를 처리한다. 

**시작 줄**
HTTP 요청의 시작 줄은 <u>메소드(Method), 요청 대상(Request target), HTTP 버전</u>으로 구성되며, 각각은 띄어쓰기로 구분한다. 

**메소드**는 요청 대상에 대해 서버가 수행하길 바라는 동작을 나타낸다. HTTP 표준에 정의된 메소드는 8개가 있으나, 여기서는 비교적 자주 사용되는 GET, POST 메소드만 설명한다. 

- GET
	- 리소스를 가져와달라 요청하는 메소드
	- 사용자가 브라우저에 웹 서버의 주소를 입력하거나 하이퍼링크를 클릭하면, 새로운 페이지를 렌더링하기 위해 리소스가 필요
	- 이때 브라우저는 GET 요청을 서버에 전송해 리소스를 받아 옴
- POST
	- 반대로 요청 대상에게 데이터를 보내는 메소드
	- 전송할 데이터는 보통 HTTP 바디에 포함
	- 로그인할 때 입력하는 ID, PW, 게시판에 작성하는 글 등이 POST로 서버에 전송

이 외에 **요청 URI**는 메소드의 대상을, **HTTP 버전**은 클라이언트가 사용하는 HTTP 프로토콜의 버전을 나타낸다.

**헤더와 바디**
시작 줄을 제외한 헤더와 바디는 [[Background - Web & HTTPS#HTTP 메시지|HTTP 메시지]]에서 설명한 것과 동일하다. HTTP 요청의 메소드 및 URI에 대해 더 자세하게 알고 싶다면, [여기](https://www.rfc-editor.org/rfc/rfc2616.html#section-5)에서 표준 문서를 볼 것을 권장한다. 


### HTTP 응답
---
**HTTP 응답**은 HTTP 요청에 대한 결과를 반환하는 메시지로, 요청을 수행했는지, 수행하지 않았는지, 안 했다면 이유는 무엇인지와 같은 상태 정보(Status), 그리고 클라이언트에게 전송할 리소스가 응답에 포함된다. 

**시작 줄**
HTTP 응답의 시작 줄은 <u>HTTP 버전, 상태 코드(Status Code), 처리 사유(Reason Phrase)</u>로 구성되며, 각각은 띄어쓰기로 구분한다. 

- HTTP 버전
	- 서버에서 사용하는 HTTP 프로토콜의 버전
- 상태 코드
	- 요청에 대한 처리 결과를 세 자릿수로 나타냄
	- HTTP 표준인 [RFC 2616](https://www.rfc-editor.org/rfc/rfc2616.html#section-6)은 대략 40여개의 상태 코드를 정의, 각각은 첫 번째 자릿수에 따라 5개의 클래스로 구분
- 처리 사유
	- 상태 코드가 발생한 이유를 짧게 기술

![[Pasted image 20251226234240.png]]


## HTTPS
---
### HTTPS
---
HTTP의 요청과 응답은 평문으로 전달된다. 이는 중간에 누군가 이 통신을 가로챘을 때, 중요한 정보가 유출될 수 있다. 예를 들어, 로그인할 때 전송한 POST 요청에는 대개 ID, PW가 포함된다. 공격자가 중간에 이를 가로채면 사용자의 계정이 탈취당할 수 있다. 

**HTTPS(HTTP over Secure socket layer)** 는 TLS(Transport Layer Security) 프로토콜을 도입하여 이런 문제점을 보완하였다. TLS는 서버와 클라이언트 사이에 오가는 모든 HTTP 메시지를 암호화하여 공격자가 중간에 메시지를 탈취하더라도 이를 해석하는 것은 불가능하며, 결과적으로 HTTP 통신이 도청과 변조로부터 보호된다. 

HTTPS가 제정된 초기에는 금융, 정부 서비스와 같이 민감한 데이터를 취급하는 웹 서비스 위주로 사용되었다면, 지금 개발되는 서비스들은 규모에 상관없이 HTTPS를 사용하는 추세이다. 

웹 서버의 URL이 `http://`로 시작하면 HTTP, `https://`로 시작하면 HTTPS 프로토콜을 쓴다. 

>[!example] TLS 표준
>TLS를 잘 이해하려면 TLS의 기반이 되는 공개키 암호 시스템 및 대칭키 암호 시스템을 알아야 한다. 별도로 공부해야 하지만, 나는 전공 지식이니 상관없고, 표준 RFC 문서를 읽으면 이해에 도움이 될 것이다. 

아래 사진은 HTTP와 HTTPS의 웹 서버, 오가는 메시지를 Wireshark로 확인한 것으로, 빨간 글자는 요청, 파란 글자는 응답이다. HTTP 메시지는 쉽게 읽을 수 있지만, HTTPS 메시지는 암호화되어 있어 복호화 키가 없다면 읽을 수 없다. 

**HTTP 통신**
![[Pasted image 20251227001722.png|]]

**HTTPS 통신**
![[Pasted image 20251227001848.png]]
