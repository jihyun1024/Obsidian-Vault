이런 상황을 생각해 보자. 자원에 대해 읽기와 쓰기 작업을 수행하는 어플리케이션이 있다. 그런데, 쓰기 작업은 읽기 작업보다 덜 사용된다. 또한 두 스레드가 동일한 자원에 대해 읽기 작업을 수행해도 서로에게는 어떤 문제도 발생하지 않기 때문에 다수의 스레드가 동시에 자원을 읽는 작업에는 아무 제한이 없다. 
하지만, 한 스레드가 자원에 대해 쓰기 작업을 수행하려 한다면, 이 때는 다른 어떤 스레드도 이 자원에 읽기 또는 쓰기 작업을 수행 중이어서는 안 된다. 이를 위해 읽기/쓰기 락이 필요하다. 
`java.util.concurrent.locks` 패키지에 정의되어 있으며, 주로 `ReentrantReadWriteLock` 클래스를 사용한다. 

---
### 사용 예제
```java
import java.util.concurrent.locks.*;

public class SharedData {
    private final ReadWriteLock rwLock = new ReentrantReadWriteLock();
    private final Lock readLock = rwLock.readLock();
    private final Lock writeLock = rwLock.writeLock();

    private int value = 0;

    public int readValue() {
        readLock.lock();
        try {
            return value;
        } finally {
            readLock.unlock();
        }
    }

    public void writeValue(int newValue) {
        writeLock.lock();
        try {
            value = newValue;
        } finally {
            writeLock.unlock();
        }
    }
}

```
#### 위 예제 설명
- `readValue()`는 `readLock`을 사용하여 다중 스레드가 동시에 읽을 수 있도록 허용
- `writeValue()`는 `writeLock`을 사용하여 하나의 스레드만 데이터를 수정 가능

### 특징 및 주의사항
#### ✔️ 장점

- 읽기 작업이 빈번하고 쓰기 작업이 드문 환경에서 효과적
- 읽기 락은 동시에 여러 스레드에게 허용되므로 **병렬성 향상**

#### ❗ 단점 / 주의점

- 쓰기 락이 자주 발생하면 읽기 락이 지연될 수 있음
- **공정성(fairness)** 설정이 없으면 쓰기 기아 상태(write starvation) 가능성 존재
- `ReentrantReadWriteLock` 생성 시 공정성 설정 가능:
```java
new ReentrantReadWriteLock(true); // fair policy
```

---

### 🔁 재진입성 (Reentrancy)
`ReentrantReadWriteLock`은 이름처럼 **재진입 가능**하다.
- 같은 스레드가 여러 번 읽기 락/쓰기 락을 획득 가능
- 단, 읽기 락을 가진 스레드가 **쓰기 락으로 승격(upgrade)** 하려는 건 **불가능** (데드락 위험 때문)