## 들어가며
---
이번 강의는 게시판 기능을 구현하면서 웹 서버가 어떤 원리로 구현되어 동작하는지를 더 깊이 이해할 수 있도록 할 것이다. 강의에서는 다음 기능들을 단계적으로 구현한다. 

1. 게시글 목록을 조회하는 기능
2. 게시글을 작성하는 기능
3. 게시글을 조회하는 기능
4. 게시글을 수정하는 기능
5. 게시글을 삭제하는 기능

위의 각 기능들을 [[실습 - 깔끔한 코드 패턴 만들기]] 강의에서 구현한 로그인 기능이 존재하는 Flask 웹 서버에 추가해볼 것이다. 각 기능을 하나하나 구현하며 진행하는 강의는 아니며, 각 기능이 추가될 때마다 발생하는 **변경사항과 코드의 작동 방식을 하나씩 자세히 살펴보는 방식으로 강의를 진행할 것이다.** 

![[Pasted image 20260116205257.png]]

한편, 웹 개발이나 웹 해킹을 공부하다 보면 **CRUD**라는 단어를 반드시 접하게 되는데, 이는 **Create(생성), Read(조회), Update(수정), Delete(삭제)** 의 약자로, 데이터를 다루는 네 가지 기본적인 작업을 의미하며 대부분의 웹 서비스와 데이터베이스 시스템이 동작하는 기본적인 원리이다.

CRUD는 많은 웹 서비스의 동작에 내재된 기본 원리로, 이를 이해하면 웹 서비스를 분석하고 공격 시나리오를 설계하는 데 큰 도움이 된다. 특히, <u>CRUD의 각 작업(Create, Read, Update, Delete)은 웹 해커들이 주로 공격 지점으로 삼는 부분이기도 하다.</u>


## 게시판 기능 구현하기
---
### 게시판 기능 구상하기
---
구현에 앞서, 게시판 기능을 구상해보도록 하자. 다음 다섯 가지의 기능을 추가할 것이다. 

- 게시글 목록 조회 기능
	- `GET /posts` - 게시글 목록을 보여 주는 페이지를 반환한다. 
- 게시글 작성 기능
	- `GET /posts/new` - 게시글을 작성할 수 있는 페이지를 반환한다. 
	- `POST /posts/new` - 게시글 작성을 실제 처리한다.
- 게시글 조회 기능
	- `GET /posts/<post_id>` - `post_id`에 해당하는 게시글을 보여주는 페이지를 반환한다. 
	- 게시글을 보여 주는 페이지에서는 <u>게시글을 수정/삭제할 수 있는 버튼을 보여 준다.</u>
- 게시글 수정 기능
	- `GET /posts/<post_id>/edit` - `post_id`에 해당하는 게시글을 수정할수 있는 페이지를 반환한다. 
	- 게시글 제목과 게시글 내용을 수정할 수 있도록 <u>입력폼을 보여주어야 하며, 수정하기 버튼도 필요하다.</u>
	- `POST /posts/<post_id>/edit` - `post_id`에 해당하는 게시글 수정을 실제 처리한다.
- 게시글 삭제 기능
	- `GET /posts/<post_id>/delete` - `post_id`에 해당하는 게시글을 삭제할 수 있는 페이지를 반환한다. 이때, <u>정말로 삭제할 것인지를 묻는 문구를 예/아니요 버튼과 함께 표시한다.</u>
	- `POST /posts/<post_id>/delete` - `post_id`에 해당하는 게시글 삭제를 실제 처리한다. 


## 게시글 데이터 구조 정의
---
이번 장에서는 게시글 데이터를 생각해보고 **게시글을 담는 테이블을 생성하는 코드를 *db.py*에 추가한다**. 

웹 사이트에 새로운 기능을 추가하거나 새로운 데이터를 다룰 때는 데이터의 구조를 사전에 구상해보고 이를 기반으로 데이터베이스의 설계를 진행하는 작업이 중요하다. 

- 여러 게시글 중 특정 게시글을 조회, 수정, 삭제할 수 있어야 한다.
	- 각 게시글을 구분할 수 있는 식별자가 존재해야 한다. 
- 게시글의 제목이 존재해야 한다. 
- 게시글의 내용이 존재해야 한다.
- 게시글을 수정하거나 삭제하는 작업은 해당 글의 작성자만 할 수 있도록 해야 한다. 
	- 수정하거나 삭제하려는 사용자가 작성자와 동일한 사람인지 검증하기 위해, 작성자의 정보도 게시글 데이터에 포함되어야 한다. 

위 요소들을 바탕으로 데이터베이스에 테이블을 만드는 코드를 *db.py*에 추가해야 하며, *db.py* 파일의 변경된 코드는 다음과 같다. 

```python
import sqlite3


def init_db():
	conn = sqlite3.connect('webserver.db')
	cursor = conn.cursor()
	cursor.execute('''
		CREATE TABLE IF NOT EXISTS accounts (
			id        INTEGER PRIMARY KEY AUTOINCREMENT,
			username  TEXT UNIQUE NOT NULL,
			password  TEXT NOT NULL
		)
	''')
	cursor.execute('''
		CREATE TABLE IF NOT EXISTS posts (
			id        INTEGER PRIMARY KEY AUTOINCREMENT,
			title     TEXT NOT NULL,
			content   TEXT NOT NULL,
			author    INTEGER NOT NULL,
			FOREIGN KEY (author) REFERENCES accounts(id)
		)
	''')
	conn.commit()
	conn.close()


def add_account(username, password):
	conn = sqlite3.connect('webserver.db')
	cursor = conn.cursor()
	try:
		cursor.execute('INSERT INTO accounts (username, password) VALUES (?, ?)', (username, password))
		conn.commit()
		conn.close()
		return True
	except sqlite3.IntegrityError:
		conn.close()
		return False


def check_account(username, password):
	conn = sqlite3.connect('webserver.db')
	cursor = conn.cursor()
	cursor.execute('SELECT * FROM accounts WHERE username = ? AND password = ?', (username, password))
	user = cursor.fetchone()
	conn.close()
	return user
```

여기서 `init_db()` 함수의 SQL 명령 부분만 살펴보자. 

```sqlite
CREATE TABLE IF NOT EXISTS posts (
    id          INTEGER PRIMARY KEY AUTOINCREMENT,
    title       TEXT NOT NULL,
    content     TEXT NOT NULL,
    author      INTEGER NOT NULL,
    FOREIGN KEY (author) REFERENCES accounts(id)
)
```

위 query로 생성된 테이블에는 게시글 데이터가 여러 개 저장될 수 있으며, 하나의 게시글 데이터는 다음의 정보들을 가진다. 

- `id` - 테이블의 기본 키(`PRIMARY KEY`)로, 각 게시글을 고유하게 식별하는 데 사용하는 키이다. 정수 형태를 띄며 1부터 시작해 자동으로 증가한다.
- `title` - 게시글의 제목으로, 빈 내용이 아닌 텍스트를 담는다.
- `content` - 게시글의 내용으로, 빈 내용이 아닌 텍스트를 담는다. 
- `author` - 게시글의 작성자로, 정수 형태의 데이터이며 **사용자의 고유 번호**를 담는다.
- `FOREIGN KEY (author) REFERENCES accounts(id)` - `author` 부분을 **외래 키(`FOREIGN KEY`)로 설정하는 구문** 이다. 
	- 외래 키는 한 테이블이 다른 테이블과 연결되도록 만들어 주는 역할로, 쉽게 말해 *"이 데이터가 다른 테이블의 어느 데이터와 관계가 있다"* 라고 하는 역할을 한다. 
	- 이 구문에서는 `author` 필드가 `accounts` 테이블의 `id` 필드에 있는 값을 참조하도록 설정하여 "이 게시글의 작성자는 실제로 `accounts` 테이블에 존재하는 사용자여야 함"을 데이터베이스가 자동으로 확인하고 보장하도록 만들기 위한 목적으로 사용되었다.


## 게시글 목록 조회 기능
---
이번에는 게시글 목록을 조회하는 기능을 구현해볼 것이다. 

이를 위해 `GET /posts` 엔드포인트를 만든 후 게시글 목록을 보여주는 페이지를 반환하도록 할 것이다. 이때, 반환되는 HTML 문서의 이름은 *posts.html*로 한다. 또한, 사용자가 매번 URL 바에 `/posts`를 입력해서 접근하기에는 매우 불편하고 번거로우니 메인 페이지(`/`)에 게시글 목록 페이지(`/posts`)로 이동할 수 있는 버튼을 만들 것이다. 


### 게시글 목록을 반환하는 함수 추가하기
---
먼저, *db.py*에 게시글 목록을 반환하는 함수를 추가하자. 게시글 데이터를 담고 있는 `posts` 테이블로부터 게시글의 고유 번호를 나타내는 `id`, 제목을 나타내는 `title`, 작성자를 나타내는 `author` 필드를 가지고 온다. 

```python
import sqlite3

def init_db():
	conn = sqlite3.connect('webserver.db')
	cursor = conn.cursor()
	cursor.execute('''
		CREATE TABLE IF NOT EXISTS accounts (
			id        INTEGER PRIMARY KEY AUTOINCREMENT,
			username  TEXT UNIQUE NOT NULL,
			password  TEXT NOT NULL
		)
	''')
	cursor.execute('''
		CREATE TABLE IF NOT EXISTS posts (
			id        INTEGER PRIMARY KEY AUTOINCREMENT,
			title     TEXT NOT NULL,
			content   TEXT NOT NULL,
			author    INTEGER NOT NULL,
			FOREIGN KEY (author) REFERENCES accounts(id)
		)
	''')
	conn.commit()
	conn.close()


def add_account(username, password):
	conn = sqlite3.connect('webserver.db')
	cursor = conn.cursor()
	try:
		cursor.execute('INSERT INTO accounts (username, password) VALUES (?, ?)', (username, password))
		conn.commit()
		conn.close()
		return True
	except sqlite3.IntegrityError:
		conn.close()
		return False


def check_account(username, password):
	conn = sqlite3.connect('webserver.db')
	cursor = conn.cursor()
	cursor.execute('SELECT * FROM accounts WHERE username = ? AND password = ?', (username, password))
	user = cursor.fetchone()
	conn.close()
	return user


def get_all_posts():
	conn = sqlite3.connect('webserver.db')
	cursor = conn.cursor()
	cursor.execute('''
		SELECT posts.id, posts.title, accounts.username
		FROM posts JOIN accounts 
		ON posts.author = accounts.id
	''')
	posts = cursor.fetchall()
	conn.close()
	return posts
```

여기서 아래의 코드에 대해서만 알아보자. (나머지는 굳이 말 안 해도 알 것이다)

```python
cursor.execute('''
		SELECT posts.id, posts.title, accounts.username
		FROM posts JOIN accounts 
		ON posts.author = accounts.id
	''')
posts = cursor.fetchall()
```

- `SELECT posts.id, posts.title, accounts.username`
	- `SELECT`는 가져올 데이터를 지정하는 명령어로, 해당 구문은 3개의 데이터 `posts.id`, `posts.title`, `accounts.username`을 가져오려고 하는 명령이다.
- `FROM posts JOIN accounts`
	- 앞서 `SELECT` 명령어로 가져올 데이터를 지정했는데, 해당 데이터를 어느 테이블로부터 가져올지를 `FROM` 명령어가 지정한다. 또한, `JOIN`은 두 개의 테이블을 합치는 명령어로, 해당 구문의 경우 `SELECT`로 `posts`와 `accounts` 두 테이블에서 데이터를 가져온다.
- `ON posts.author = accounts.id`
	- `ON`은 두 테이블을 연결할 조건을 제시한다. 해당 구문의 경우 `posts` 테이블의 `author` 필드와 `accounts` 테이블의 `id` 필드의 값이 같은 행 데이터만 서로 연결한다. 
- `posts = cursor.fetchall()`
	- 게시글 목록 데이터가 변경되며, 이를 `posts` 변수에 대입한다. 


### 게시글 목록을 출력하는 엔드포인트 추가하기
---
앞서 *db.py*에 게시글 목록을 반환하는 함수를 추가했다면, 이번에는 그 반환된 게시글 목록을 출력하는 엔드포인트를 *app.py*에 추가한다. (*이번에는 설명 없이 그냥 넘어간다.*)

```python
from flask import Flask, render_template, request, redirect, url_for, session
import os
from db import init_db, add_account, check_account, get_all_posts


app = Flask(__name__)
app.secret_key = os.urandom(32)


@app.route('/', methods=['GET'])
def get_index():
	if 'username' not in session:
		return redirect(url_for('get_login'))
	return render_template('index.html', username=session['username'])


@app.route('/posts', methods=['GET'])
def get_posts():
	if 'username' not in session:
		return redirect(url_for('get_login'))
	posts = get_all_posts()
	return render_template('posts.html', posts=posts)


@app.route('/register', methods=['GET'])
def get_register():
	if 'username' in session:
		return redirect(url_for('get_index'))
	return render_template('register.html')


@app.route('/register', methods=['POST'])
def post_register():
	if 'username' in session:
		return redirect(url_for('get_index')
	username = request.form.get('username')
	password = request.form.get('password')
	if add_account(username, password):
		return redirect(url_for('get_login'))
	else:
		return render_template('register_failure.html')


@app.route('/login', methods=['GET'])
def get_login():
	if 'username' in session:
		return redirect(url_for('get_index'))
	return render_template('login.html')


@app.route('/login', methods=['POST'])
def post_login():
	if 'username' in session:
		return redirect(url_for('get_index'))
	username = request.form.get('username')
	password = request.form.get('password')
	if check_account(username, password):
		session['username'] = username
		return redirect(url_for('get_index'))
	else:
		return render_template('login_failure.html')


@app.route('/logout', methods=['GET'])
def get_logout():
	session.clear()
	return redirect(url_for('get_login'))


if __name__ == '__main__':
	init_db()
	app.run(host='0.0.0.0', port=31337)
```


### 게시글 목록을 출력하는 HTML 문서 작성하기
---
이제 *posts.html*을 작성해 본다. *posts.html*은 `GET /posts` 엔드포인트에서 반환되는 페이지이며, `render_template()`를 통해 게시글 목록인 `posts`를 전달받아서 게시글 목록을 출력한다. 

**페이지 형태**
기대하는 페이지 형태는 다음 사진과 같다. **Posts**라는 헤딩 문구가 상단에 위치하고, 그 아래에 게시글 목록이 존재하며 맨 아래에는 메인 페이지로 이동할 수 있는 버튼이 존재한다. 

![[Pasted image 20260117150816.png]]
위 사진에서 게시글 목록 부분을 자세히 살펴보면, 테이블 형태로 되어 있으며 테이블 가장 상단 행에는 순서대로 ID, Title, Author라는 헤더가 존재한다. 그리고 나서 다음 행부터 게시글들이 차례대로 출력되며 제목을 클릭해 게시글 페이지로 이동할 수 있다. 

**사용할 HTML 태그 학습하기**
*posts.html*을 만들기 위해 지금까지 사용해 본 적 없는 새로운 HTML 태그를 사용해 볼 것이다. 바로, **표(Table)를 만드는 `<table>` 태그이다.**

표는 행(Row), 열(Column)로 구성되어 데이터를 표시한다. 아래는 일반적인 표의 예시로, 4 x 3 표로 12개의 칸(Cell)이 존재한다. 

![[Pasted image 20260117151223.png]]

아래 사진에서 볼 수 있듯, 행은 가로 방향으로 배치된 데이터를 말하며, 열은 세로 방향으로 배치된 데이터를 말한다. 

![[Pasted image 20260117151316.png]]

이제 `<table>` 태그로 넘어가서, `<table>` 태그는 웹 페이지에 표를 만들 때 사용하는 태그로 `<thead>` 태그, `<tbody>` 태그, `<tr>` 태그, `<td>` 태그, `<th>` 태그와 함께 사용된다. 

많은 태그와 함께 사용되기 때문에 어려워 보일 수 있지만 예시를 보면 이해하기 쉽다. 

```html
<!DOCTYPE html>
<html>
<head>
  <title>Table Example</title>
</head>
<body>
  <table>
    <thead>
      <tr>
        <th>No.</th>
        <th>StudentName</th>
        <th>Grade</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>1</td>
        <td>Alice</td>
        <td>A</td>
      </tr>
      <tr>
        <td>2</td>
        <td>Bob</td>
        <td>B</td>
      </tr>
    </tbody>
  </table>
</body>
</html>
```

- `<thead>`
	- 표의 각 열이 무엇인지 설명하는 헤더 문구를 정의할 때 사용
	- `<tr>` 태그로 행을 정의, 행에 들어갈 헤더 문구를 `<th>` 태그로 순서대로 정의
	- 헤더 문구: 아래 사진의 표에서 빨간 네모로 표시된 부분
		![[Pasted image 20260117151939.png|400]]
- `<tbody>`
	- 표의 본문 영역으로, 실제 데이터를 포함하고 있는 부분
	- `<tr>` 태그로 행을 정의, `<td>` 태그로 행에 들어갈 데이터를 순서대로 정의

즉, `<thead>`, `<tbody>`태그는 HTML에서 `<head>`, `<body>`에 해당하며, `<tr>`, `<td>`, `<th>` 태그는 각각 **r**ow, **d**ata, **h**eader의 앞 철자를 딴 것이라고 생각하면 된다.

***posts.html*** 작성하기
*posts.html*은 다음과 같다. 이때, 템플릿 렌더링의 반복문을 사용해 전달받은 게시글 목록인 `posts`를 행 데이터로 출력한다. 

```html
{% extends 'base.html' %}

{% block content %}
	<h2>Posts</h2>
	<table>
		<thead>
			<tr>
				<th>ID</th>
				<th>Title</th>
				<th>Author</th>
			</tr>
		</thead>
		<tbody>
			{% for post in posts %}
				<tr>
					<td>{{ post[0] }}</td>
					<td><a href="/posts/{{ post[0] }}">{{ post[1] }}</a></td>
					<td>{{ post[2] }}</td>
				</tr>
			{% endfor %}
		</tbody>
	</table>
	<br>
	<form action="/">
		<button>Go to Main Page</button>
	</form>
{% endblock %}
```

그 중 `<tbody>` 부분만 자세하게 살펴보자. 2번 라인과 8번 라인에 걸쳐 템플릿 렌더링의 반복문을 활용해 게시글 목록을 담고 있는 `posts`를 순회하며, 각 반복의 대상 요소는 `post`가 된다. 

`get_all_posts()`로부터 반환된 게시글 목록에서, 하나의 게시글은 <u>게시글 ID, 게시글 제목, 게시글 작성자</u>로 이루어져 있다. 따라서 `post[0]`이 게시글 ID, `post[1]`이 게시글 제목, `post[2]`가 게시글 작성자가 된다. 

```html
    <tbody>
      {% for post in posts %}
        <tr>
          <td>{{ post[0] }}</td>
          <td><a href="/posts/{{ post[0] }}">{{ post[1] }}</a></td>
          <td>{{ post[2] }}</td>
        </tr>
      {% endfor %}
    </tbody>
```

이 때 5번 라인에서 두 번째 `<td>` 요소는 `<a>` 태그를 사용해 하이퍼링크를 생성하며, 하이퍼링크의 문구는 게시글의 제목인 `post[1]`로, 링크 클릭 시 `/posts/{{ post[0] }}`, 즉 해당 게시글 ID에 해당하는 페이지로 이동한다. 


### 게시글 목록 페이지로 이동하는 버튼 추가하기
---
마지막으로, 메인 페이지인 *index.html*에 게시글 목록 페이지로 이동하는 버튼을 추가한다. 아래 *index.html*의 변경사항을 살펴보면 `/posts` 경로로 이동하는 **Go to Posts** 버튼을 추가했다. 

```html
{ % extends 'base.html' %}

{% block content %}
	<h1>Hello, {{ username }}!</h1>
	<form action="/posts">
		<button>Go to Posts</button>
	</form>
	<br>
	<form action="/logout">
		<button>Log Out</button>
	</form>
{% endblock %}
```


## 게시글 작성 기능
---
이번에는 게시글을 생성할 수 있는 기능을 구현해볼 것이다. 이를 위해 새로운 게시글을 작성할 수 있는 `GET /posts/new` 엔드포인트와 게시글 작성을 실제 처리하는 `POST /posts/new` 엔드포인트를 만들 것이다. 

사용자가 게시글을 작성하기 위해 매번 URL 바에 링크를 입력할 수는 없으니, 게시판 목록 페이지(`/posts`) 에 이동할 수 있는 버튼을 만들 것이다. 

이때, 게시글을 작성할 수 있는 `GET /posts/new`가 반환하는 HTML 문서의 이름은 *posts_new.html*로 한다. 


### 게시글 생성하는 함수 추가하기
---
먼저, *db.py*에 게시글 데이터를 데이터베이스에 생성하는 함수를 추가한다. 

```python
import sqlite3

def init_db():
	conn = sqlite3.connect('webserver.db')
	cursor = conn.cursor()
	cursor.execute('''
		CREATE TABLE IF NOT EXISTS accounts (
			id        INTEGER PRIMARY KEY AUTOINCREMENT,
			username  TEXT UNIQUE NOT NULL,
			password  TEXT NOT NULL
		)
	''')
	cursor.execute('''
		CREATE TABLE IF NOT EXISTS posts (
			id        INTEGER PRIMARY KEY AUTOINCREMENT,
			title     TEXT NOT NULL,
			content   TEXT NOT NULL,
			author    INTEGER NOT NULL,
			FOREIGN KEY (author) REFERENCES accounts(id)
		)
	''')
	conn.commit()
	conn.close()


def add_account():
	conn = sqlite3.connect('webserver.db')
	cursor = conn.cursor()
	try:
		cursor.execute('INSERT INTO accounts (username, password) VALUES (?, ?)', (username, password))
		conn.commit()
		conn.close()
		return True
	except sqlite3.IntegrityError:
		conn.close()
		return False


def check_account():
	conn = sqlite3.connect('webserver.db')
	cursor = conn.cursor()
	cursor.execute('SELECT * FROM accounts WHERE username = ? AND password = ?', (username, password))
	user = cursor.fetchone()
	conn.close()
	return user


def get_all_posts():
	conn = sqlite3.connect('webserver.db')
	cursor = conn.cursor()
	cursor.execute('''
		SELECT posts.id, posts.title, accounts.username
		FROM posts JOIN accounts
		ON posts.author = accounts.id
	''')
	posts = cursor.fetchall()
	conn.close()
	return posts


def create_post(title, content, author_id):
	conn = sqlite3.connect('webserver.db')
	cursor = conn.cursor()
	cursor.execute('INSERT INTO posts (title, content, author) VALUES (?, ?, ?', (title, content, author_id))
	conn.commit()
	conn.close()	
```


### 게시글 작성 엔드포인트 추가하기
---
앞서 *db.py*를 수정했다면, 이번에는 사용자가 게시글을 작성할 수 있는 엔드포인트를 *app.py* 파일을 수정하여 구현할 것이다. 

다음 두 엔드포인트를 만든다. 이번에도 설명은 생략한다. 

- `GET /posts/new` - 제목, 내용을 입력해서 버튼을 눌러 게시글을 작성할 수 있는 페이지 반환
	- 페이지 이름: *posts_new.html*
- `POST /posts/new` - `GET /posts/new`에서 전달받은 데이터로 실제 게시글 데이터 생성

```python
from flask import Flask, render_template, redirect, request, url_for, session
import os
from db import init_db, add_account, check_account, get_all_posts, create_post


app = Flask(__name__)
app.secret_key = os.urandom(32)


@app.route('/', methods=['GET'])
def get_index():
	if 'username' not in session:
		return redirect(url_for('get_login'))
	return render_template('index.html', username=session['username'])


@app.route('/posts', methods=['GET'])
def get_posts():
	if 'username' not in session:
		return redirect(url_for('get_login'))
	posts = get_all_posts()
	return render_template('posts.html', posts=posts)


@app.route('/posts/new', methods=['GET'])
def get_posts_new():
	if 'username' not in session:
		return redirect(url_for('get_login'))
	return render_template('posts_new.html')


@app.route('/posts/new', methods=['POST'])
def post_posts_new():
	if 'username' not in session:
		return redirect(url_for('get_login'))
	title = request.form.get('title')
	content = request.form.get('content')
	author_id = session['user_id']
	create_post(title, content, author_id)
	return redirect(url_for('get_posts'))


@app.route('/register', methods=['GET'])
def get_register():
	if 'username' in session:
		return redirect(url_for('get_index'))
	return render_template('register.html')


@app.route('/register', methods=['POST'])
def post_register():
	if 'username' in session:
		return redirect(url_for('get_index'))
	username = request.form.get('username')
	password = request.form.get('password')
	if add_account(username, password):
		return redirect(url_for('get_login'))
	else:
		return render_template('register_failure.html')


@app.route('/login', methods=['GET'])
def get_login():
	if 'username' in session:
		return redirect(url_for('get_index'))
	return render_template('login.html')


@app.route('/login', methods=['POST'])
def post_login():
	if 'username' in session:
		return redirect(url_for('get_index'))
	username = request.form.get('username')
	password = request.form.get('password')
	user = check_account(username, password)
	if user:
		session['user_id'] = user[0]
		session['username'] = user[1]
		return redirect(url_for('get_index'))
	else:
		return render_template('login_failure.html')


@app.route('/logout', methods=['GET'])
def get_logout():
	session.clear()
	return redirect(url_for('get_login'))


if __name__ == '__main)__':
	init_db()
	app.run(host='0.0.0.0', port=31337)
```


### 게시글을 작성할 수 있는 HTML 문서 만들기
---
이제 *posts_new.html*을 작성해보자. *posts_new.html*은 `GET /posts_new` 엔드포인트에서 반환되는 페이지로, 제목과 내용을 입력할 수 있어야 하고, 게시글을 업로드할 수 있는 버튼도 필요하다. 

기대하는 페이지 형태는 다음 사진과 같다. 

![[Pasted image 20260117192834.png]]
**사용할 HTML 태그 학습하기**
`<textarea>`라는 태그를 새로 사용하는데, 이 태그는 **여러 줄의 텍스트를 입력받을 수 있는 입력 폼**을 만드는 데 사용한다. 기존의 `<input>` 태그로 만든 입력 폼은 한 줄의 텍스트만 입력할 수 있었지만, 일반적으로 게시글 내용은 여러 줄로 이루어지기 때문에 `<input>` 대신 `<textarea>`가 더 적합하다. 

***posts_new.html***
*posts_new.html*은 다음과 같다. 

```html
{% extends 'base.html' %}

{% block content %}
  <h2>New Post</h2>
  <form action="/posts/new" method="post">
    Title:
    <br>
    <input type="text" id="title" name="title">
    <br>
    <br>
    Content:
    <br>
    <textarea type="text" id="content" name="content"></textarea>
    <br>
    <button type="submit">Post</button>
  </form>
  <br>
  <form action="/posts">
    <button>Go to Posts</button>
  </form>
{% endblock %}
```

5 ~ 16번 라인에 `<form>` 태그가 있으며, 5번 라인을 살펴보면 `<form>` 태그의 `action` 속성이 `/posts/new`이고 `method` 속성이 `post`이므로 폼 데이터는 `/posts/new` 경로에 POST 메서드를 통해 전달된다. 

8번 라인은 게시글의 제목을 `<input>` 태그를 통해 입력받으며, 13번 라인에서는 게시글의 내용을 여러 줄에 걸쳐 입력받을 수 있는 입력 폼을 `<textarea>` 태그로 만든다. 


## 게시글 조회 기능
---
이번에는 특정한 게시글을 조회할 수 있는 기능을 개발해볼 것이다. 이를 위해, **게시글의 고유번호**인 `post_id`로 특정 게시글을 조회할 수 있는 `GET /posts/<post_id>` 엔드포인트를 만들 것이며, 해당 엔드포인트가 반환하는 HTML 문서의 이름은 *post.html*로 한다. 

참고로, 이제부터는 알 만한 내용은 전부 Skip하고, 처음 나오는 내용만 다룬다. 


### 게시글 조회하는 함수 추가하기
---
먼저, 데이터베이스로부터 게시글을 조회하는 함수를 *db.py*에 추가한다. 

```python
 import sqlite3

 def init_db():
     conn = sqlite3.connect('webserver.db')
     cursor = conn.cursor()
     cursor.execute('''
         CREATE TABLE IF NOT EXISTS accounts (
             id          INTEGER PRIMARY KEY AUTOINCREMENT,
             username    TEXT UNIQUE NOT NULL,
             password    TEXT NOT NULL
         )
     ''')
     cursor.execute('''
         CREATE TABLE IF NOT EXISTS posts (
             id          INTEGER PRIMARY KEY AUTOINCREMENT,
             title       TEXT NOT NULL,
             content     TEXT NOT NULL,
             author      INTEGER NOT NULL,
             FOREIGN KEY (author) REFERENCES accounts(id)
         )
     ''')
     conn.commit()
     conn.close()


 def add_account(username, password):
     conn = sqlite3.connect('webserver.db')
     cursor = conn.cursor()
     try:
         cursor.execute('INSERT INTO accounts (username, password) VALUES (?, ?)',
                        (username, password))
         conn.commit()
         conn.close()
         return True # success
     except sqlite3.IntegrityError:
         conn.close()
         return False # failure


 def check_account(username, password):
     conn = sqlite3.connect('webserver.db')
     cursor = conn.cursor()
     cursor.execute('SELECT * FROM accounts WHERE username = ? AND password = ?',
                    (username, password))
     user = cursor.fetchone()
     conn.close()
     return user


 def get_all_posts():
     conn = sqlite3.connect('webserver.db')
     cursor = conn.cursor()
     cursor.execute('SELECT posts.id, posts.title, accounts.username FROM posts JOIN accounts ON posts.author = accounts.id')
     posts = cursor.fetchall()
     conn.close()
     return posts


 def create_post(title, content, author_id):
     conn = sqlite3.connect('webserver.db')
     cursor = conn.cursor()
     cursor.execute('INSERT INTO posts (title, content, author) VALUES (?, ?, ?)',
                    (title, content, author_id))
     conn.commit()
     conn.close()


def get_post_by_post_id(post_id):
    conn = sqlite3.connect('webserver.db')
    cursor = conn.cursor()
    cursor.execute('''
        SELECT posts.id, posts.title, posts.content, accounts.username
        FROM posts JOIN accounts
        ON posts.author = accounts.id
        WHERE posts.id = ?
    ''', (post_id))
    post = cursor.fetchone()
    conn.close()
    return post
```


### 게시글 조회 엔드포인트 추가하기
---
이제, 사용자가 게시글을 조회할수 있도록 `GET /posts/<post_id>` 엔드포인트를 만든다. 

```python
from flask import Flask, render_template, request, redirect, url_for, session
import os
from db import init_db, add_account, check_account, get_all_posts, create_post, get_post_by_post_id


 app = Flask(__name__)
 app.secret_key = os.urandom(32)


 @app.route('/', methods=['GET'])
 def get_index():
     if 'username' not in session:
         return redirect(url_for('get_login'))
     return render_template('index.html', username=session['username'])


 @app.route('/posts', methods=['GET'])
 def get_posts():
     if 'username' not in session:
         return redirect(url_for('get_login'))
     posts = get_all_posts()
     return render_template('posts.html', posts=posts)


 @app.route('/posts/new', methods=['GET'])
 def get_posts_new():
     if 'username' not in session:
         return redirect(url_for('get_login'))
     return render_template('posts_new.html')


 @app.route('/posts/new', methods=['POST'])
 def post_posts_new():
     if 'username' not in session:
         return redirect(url_for('get_login'))
     title = request.form.get('title')
     content = request.form.get('content')
     author_id = session['user_id']
     create_post(title, content, author_id)
     return redirect(url_for('get_posts'))


@app.route('/posts/<post_id>', methods=['GET'])
def get_posts_post_id(post_id):
    if 'username' not in session:
        return redirect(url_for('get_login'))
    post = get_post_by_post_id(post_id)
    if post:
        return render_template('post.html', post=post)
    else:
        return redirect(url_for('get_posts'))


 @app.route('/register', methods=['GET'])
 def get_register():
     if 'username' in session:
         return redirect(url_for('get_index'))

     return render_template('register.html')


 @app.route('/register', methods=['POST'])
 def post_register():
     if 'username' in session:
         return redirect(url_for('get_index'))

     username = request.form.get('username')
     password = request.form.get('password')
     if add_account(username, password):
         return redirect(url_for('get_login'))
     else:
         return render_template('register_failure.html')


 @app.route('/login', methods=['GET'])
 def get_login():
     if 'username' in session:
         return redirect(url_for('get_index'))

     return render_template('login.html')


 @app.route('/login', methods=['POST'])
 def post_login():
     if 'username' in session:
         return redirect(url_for('get_index'))

     username = request.form.get('username')
     password = request.form.get('password')
     user = check_account(username, password)
     if user:
         session['user_id'] = user[0]
         session['username'] = user[1]
         return redirect(url_for('get_index'))
     else:
         return render_template('login_failure.html')


 @app.route('/logout', methods=['GET'])
 def get_logout():
     session.clear()
     return redirect(url_for('get_login'))


 if __name__ == '__main__':
     init_db()
     app.run(host='0.0.0.0', port=31337)
```
### 게시글을 조회할 수 있는 HTML 문서 만들기
---
기대하는 페이지의 형태는 다음 사진과 같다. 

![[Pasted image 20260118201057.png]]
**사용할 HTML 태그 학습하기**
`<pre>` 태그는 텍스트를 표시하는 데 사용하는 태그로, `<pre>` 태그로 감싸진 텍스트는 고정 너비 글꼴로 표시되며 공백이나 줄 바꿈도 모두 유지된 채로 웹 페이지에 표시된다. 사용자가 작성한 게시글에는 줄바꿈이나 공백이 여럿 포함되어 있을 수 있는데, 그런 문자들을 포함해서 게시글의 내용을 웹 페이지에 정확하게 표시할 목적으로 사용한다. 

우리가 출력하고 싶은 텍스트가 아래와 같다고 가정하자. 

```
Here is an example text that includes newline and whitespace characters.

1. Newlines and Indentation:
   - This text is
       written across
           multiple lines.

2. Preserving Spaces:
   - Three   spaces
   - Six       spaces
```

이 텍스트를 `<pre>` 태그를 사용해서 출력하는 HTML 문서는 다음과 같다. 7 ~ 16번 라인을 살펴보면, 출력할 텍스트를 `<pre>`와 `</pre>` 태그로 감싸 출력하는 것을 볼 수 있다. 

```html
<!DOCTYPE html>
<html>
	<head>
		<title>Pre Tag Example</title>
	</head>
	<body>
		<pre>Here is an example text that includes newline and whitespace characters.
	1. Newlines and Indentation:
		- This text is 
			  written across
				  multiple lines.
	2. Preserving Spaces:
		- Three   Spaces
		- Six      Spaces</pre>
	</body>
</html>
```

이 `<pre>` 태그를 사용하지 않으면 줄바꿈이나 공백 문자들이 전부 깨져서 출력된다. 

한편, *post.html*은 다음과 같이 작성할 수 있다. 

```html
{% extends 'base.html' %}

{% block content %}
	<h2>{{ post[1] }}</h2>
	<p>Written by: {{ post[3] }}</p>
	<pre>{{ post[2] }}</pre>
	<a href="/posts">Go to Posts</a>
{% endblock %}
```

이때, `post`는 튜플 형태의 데이터로, **0번째 원소는 게시글 고유 번호, 1번째 원소는 게시글 제목, 2번째 원소는 게시글 내용, 3번째 원소는 게시글 작성자의 `username`을 담고 있다.**


## 게시글 수정 기능
---

### 게시글 수정하는 함수 추가하기
----

### 게시글 수정 엔드포인트 추가하기
---

### 게시글을 수정할 수 있는 HTML 문서 만들기
---

## 게시글 삭제 기능
---

### 게시글 삭제하는 함수 추가하기
---

### 게시글 삭제 엔드포인트 추가하기
---

### 게시글을 삭제할 수 있는 HTML 문서 만들기
---

## 웹 서비스 테스트하기
---

## 마치며
---
지금까지 게시판 기능을 구현해보면서 웹 서버가 어떤 방식으로 구현되는지 더 깊게 이해하고, CRUD의 개념을 실제 구현해봄으로 체득할 수 있었다. 

강의에서는 게시글 목록 조회 기능, 게시글 작성 기능, 조회 기능, 게시글 수정 기능, 삭제 기능을 순차적으로 추가해보았고, 각 기능이 추가될 때마다 발생한 코드의 변경사항을 자세히 살펴봤다.

웹 해킹은 웹이라는 세상을 기반으로 이루어지기 때문에 고통스럽더라도 웹의 작동 방식을 깊이 이해하지 못한다면, 단순히 취약점을 "이용하는 기술"을 익히는 수준에 그칠 수 밖에 없다. 하지만, 좋은 해커가 되기 위해서는 근본적으로 **"왜" 취약한지, 어떤 구조적인 이유로 문제가 생겼는지**를 이해할 수 있어야 한다. 

이런 이해를 위해 가장 효과적인 방법 중 하나가 바로 웹 서버를 직접 만들어보는 것으로, 지금까지는 웹 서버를 직접 구축해보며 웹이라는 세상의 작동 원리를 더 깊게 이해하는 경험을 했다. 