### 서론
---
함수 호출 규약은 함수의 호출 및 반환에 대한 약속이다. 한 함수에서 다른 함수를 호출할 때, 프로그램의 실행 흐름은 다른 함수로 이동한다. 그리고 호출된 함수가 반환되면, 다시 원래의 함수로 돌아와서 기존의 실행 흐름을 이어 나간다. 그러므로 함수를 호출할 때는 반환된 이후를 위해 **호출자(Caller)** 의 상태(Stack frame) 및 반환 주소(Return address)를 저장해야 한다. 또한, 호출자는 **피호출자(Callee)** 가 요구하는 인자를 전달해 주어야 하며, 피호출자의 실행이 종료될 때는 반환 값을 전달받아야 한다. 

함수 호출 규약을 적용하는 것은 일반적으로 컴파일러의 몫이다. 프로그래머가 고수준 언어로 코드를 작성하면, 컴파일러에 의해 함수들이 호출 규약에 맞게 컴파일된다. 호출 규약은 여러 가지가 있는데, 프로그래머가 코드에 명시하지 않는다면 컴파일러는 지원하는 호출 규약들 중에서 CPU의 아키텍처에 적합한 것을 선택한다. 따라서 대부분의 프로그래머는 함수 호출 규약을 알지 않아도 코드를 작성하는 데 문제가 되지 않는다. 

그러나, 만약 컴파일러의 도움 없이 직접 어셈블리 코드를 작성하려 하거나, 어셈블리어로 작성된 코드를 읽고자 한다면 함수 호출 규약을 알아야 할 필요가 있다. 특히 아키텍처나 컴파일러에 따라 함수 호출 규약도 달라지기 때문에, 시스템 해킹 분야에서는 필수적인 지식이다. 

[[리버스 엔지니어링 입문#호출 규약|리버스 엔지니어링 입문]] 문서에 어느 정도 설명하기는 했지만, 이번 강의에서는 함수의 호출 규약에 대해서 더 자세하게 살펴 보도록 한다. 

### 함수 호출 규약이란?
---
컴파일러는 CPU 아키텍처에 가장 적합한 호출 규약을 사용한다. 예를 들어, x86(32bit) 아키텍처에서는 레지스터를 통해 피호출자의 인자를 전달하기에는 레지스터의 개수가 너무 적으므로, 스택으로 인자를 전달한다. 반면 x86-64 아키텍처에서는 레지스터의 수가 충분히 많으므로 적은 개수의 인자는 레지스터를 사용해 전달하고, 인자가 너무 많을 때만 스택을 사용한다. 

CPU의 아키텍처가 같아도, 컴파일러가 다르면 적용하는 호출 규약이 다를 수 있다. C 언어를 컴파일할 때, Windows에서는 MSVC를, Linux에서는 gcc를 많이 사용한다. 이 둘은 같은 아키텍처에 대해서도 다른 호출 규약을 적용한다. x86-64 아키텍처에서 MSVC는 MS x64 호출 규약을 적용하지만, gcc는 SYSTEM V 호출 규약을 적용한다. 이 외에도 같은 호출 규약을 컴파일러마다 다르게 구현하기도 한다. 

### 함수 호출 규약의 종류
---
**x86**
- cdecl
- stdcall
- fastcall
- thiscall

**x64**
- System V AMD64 ABI의 Calling Convention
- MS ABI의 Calling Convention

#### x86 호출 규약 - cdecl, fastcall, stdcall, thiscall
---
전통적으로 매개변수는 스택을 통해 전달되나, x86에서 x86-64로 확장됨에 따라 스택에 비해서 속도가 빠른 레지스터를 적극적으로 활용하게 되었다. 모든 매개변수를 레지스터로 넘길 수 있다면 가장 좋지만, 레지스터의 개수는 정해져 있기 때문에 현대의 함수 호출 규약에서는 **대개 레지스터와 스택을 함께 사용한다.** 

아래의 C 코드를 기반으로, 본격적으로 x86 아키텍처에서 사용하는 호출 규약을 하나씩 살펴본다.

```cpp
void callee(int a1, int a2, int a3) {
}

void caller() {
	callee(1, 2, 3);
}
```

##### cdecl
---
**cdecl**은 Linux의 gcc가 x86 바이너리를 컴파일할 때 일반적으로 사용하는 호출 규약으로, 레지스터 없이 스택만으로 인자를 전달한다. 또한, 인자를 전달하기 위해 사용한 스택을 **호출자가** 정리하는 특징이 있다. 스택을 통해 인자를 전달할 때는, **마지막 인자부터 첫 번째 인자까지 거꾸로** 스택에 push한다. 

아래 코드를 어셈블리어로 컴파일한 후 확인해 보자. 컴파일 옵션 중 처음 보는 옵션은 gcc 컴파일에 사용하는 옵션이다. 
```cpp
// Name: cdecl.c
// Compile: gcc -fno-asynchronous-unwind-tables -nostdlib -masm=intel
//          -fomit-frame-pointer cdecl.c -w -m32 -fno-pic -00

void __attribute__((cdecl)) callee(int a1, int a2, int a3) {
}

void caller() {
	callee(1, 2, 3);
}
```

>[!example] 컴파일의 정확한 의미
>
>**컴파일(Compilation)** 의 정확한 의미는 어떤 언어로 작성된 소스 코드를 다른 언어의 목적 코드(Object Code)로 번역하는 것이다. 소스 코드를 어셈블리어로, 또는 소스 코드를 기계어로 번역하는 행위 모두 컴파일에 해당한다. 
>
>C 언어를 실행 가능한 바이너리로 만드는 과정을 보통 전처리, 컴파일, 어셈블, 링크의 4단계로 구분하며, 이를 합해서 '컴파일'이라 부를 수 있는 것도 위와 같은 맥락이다. 
>
>Dreamhack에서는 부가적인 설명이 없는 한 후자의 의미로 컴파일이라는 단어를 사용한다. 

```assembly
; Name: cdecl.s
		.file     "cdecl.c"
		.intel_syntax noprefix
		.text
		.globl    callee
		.type     callee, @function
callee:
		nop
		ret
		.size     callee, .-callee
		.globl    caller
		.type     caller, @function
caller:
		push      3 ; 3을 스택에 저장해 callee의 인자로 전달한다. 
		push      2 ; 2를 스택에 저장해 callee의 인자로 전달한다. 
		push      1 ; 1을 스택에 저장해 callee의 인자로 전달한다. 
		call      callee
		add       esp, 12 ; 호출자가 총 12바이트 만큼의 스택을 정리한다. (push를 3번 했기 때문에 12바이트 만큼 esp가 증가되어 있다)
		nop
		ret
		.size     caller, .-caller
		.ident    "GCC: (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0"
		.section  .note.GNU-stack,"",@progbits
```

##### stdcall
---
**stdcall (standard call)** 은 Windows API (Application Programming Interface)에서 기본적으로 사용하는 함수 호출 규약이다. Windows 운영체제에서 시스템 호출(API 호출)의 효율을 높이기 위해 cdecl 호출 규약을 변경해서 stdcall 호출 규약을 만들었으며, 인자 전달을 위해 확장된 스택 정리를 **호출자가 아닌 피호출자가 한다는 것이 가장 큰 차이점**이다. 

stdcall 호출 규약은 스택 정리 방법을 제외하면 cdecl과 큰 차이가 없기 때문에 간단하게 언급하고 넘어간다. 

아래는 stdcall을 통해 `callee()`를 호출하는 어셈블리 코드로, 마찬가지로 마지막 인자부터 첫 번째 인자까지 거꾸로 스택에 push한다. 
```assembly
callee:
	push ebp
	mov ebp, esp
	leave
	retn 12 ; 피호출자가 총 12바이트 만큼 스택을 정리한다. 
caller:
	push ebp
	mov ebp, esp
	push 3 ; 3을 스택에 저장하여 callee의 인자로 전달한다. 
	push 2 ; 2를 스택에 저장하여 callee의 인자로 전달한다. 
	push 1 ; 1을 스택에 저장하여 callee의 인자로 전달한다. 
	call callee
	leave
	ret
```

>[!example] `retn` 명령어는?
>
>복귀 명령어인 `ret`은 같은 코드 세그먼트로 복귀하는 `retn`(near return)과 다른 코드 세그먼트로 복귀하는 `retf`(far return)으로 구분할 수 있다. 
>
>사용 시 `retn 8`과 같이 사용하면 **복귀와 동시에 스택도 함께 정리**할 수 있으며, 이 기능은 주로 **피호출자가 스택을 정리할 때** 많이 사용한다. 

##### fastcall
---
**fastcall**은 함수 호출 시 **일부 인자를 레지스터로 전달**하여 속도를 향상시키기 위해서 도입된 규약이다. Windows 운영체제에서 성능 최적화를 위해 도입되었으며, 이후 다양한 컴파일러에서 지원되고 있다. 

**처음 두 개의 인자를 각각 `ecx`, `edx`에 전달 후 나머지 인자는 마지막부터 스택으로 전달**한다.

```assembly
callee:
	push ebp
	mov ebp, esp
	leave
	retn 4 ; 피호출자가 총 4바이트 만큼 스택을 정리한다. 
caller:
	push ebp
	mov ebp, esp
	mov ecx, 1 ; ecx를 통해 1을 callee의 인자로 전달한다. 
	mov edx, 2 ; edx를 통해 2를 callee의 인자로 전달한다. 
	push 3 ; 3을 스택에 저장하여 callee의 인자로 전달한다.
	call callee
	leave
	ret
```

##### thiscall
---
**thiscall**은 x86에서 사용되는 **C++ 클래스 멤버 함수를 위한 함수 호출 규약**이다. 멤버 함수에서 사용하는 `this` 포인터는 `ecx`로 넘기고, 나머지 인자들은 모두 스택으로 전달한다. 

thiscall은 C++ 클래스에 주로 사용되기에, 아래의 코드를 기반으로 살펴본다. 
```cpp
class C
{
	public:
		int c;
		int foo(int a, int b)
		{
			return c + a + b;
		}
};
```

`C::foo()`를 어셈블리 코드로 변환하면 다음과 같다. 
```assembly
foo:                            ; __thiscall C::foo(int a, int b)
	...
	mov eax, [ebp+8] ; eax에 스택에 있는 a의 값을 대입
	add eax, [ebp+12] ; eax에 스택에 있는 b의 값을 더함
	add eax, [ecx] ; eax에 this->c의 값을 더한다.
	
	leave
	retn 8 ; 피호출자가 총 8바이트 만큼 스택을 정리한다.
```

`ecx` 레지스터는 `this` 포인터를 가리킨다. 해당 포인터를 이용해 클래스의 멤버 변수에 접근할 수 있는데, 일반적으로 `[ecx + offset]` 형태로 멤버 변수에 접근하게 된다. 위 코드에서는 `c`는 오프셋 0에 위치한 멤버 변수이다. 

만약 멤버 변수가 한 개가 아닌 여러 개라면, **일정한 오프셋을 더해 `ecx`만 이용하여 모든 멤버 변수에 접근**할 수 있다. 아래 코드를 어셈블리 코드로 변환한 뒤 코드를 살펴보자. 
```cpp
class C
{
	public:
		int c;
		int d;
		unsigned long e;
		int foo(int a, int b) 
		{
			return c + d + e + a + b;
		}
};
```

`C::foo()`를 어셈블리 코드로 변환하면 다음과 같다. 
```assembly
foo:                     ; __thiscall C::foo(int a, int b)
	...
	mov eax, [ebp+8] ; eax에 스택에 있는 a의 값을 대입
	add eax, [ebp+12] ; eax에 스택에 있는 b의 값을 대입
	add eax, [ecx] ; this->c
	add eax, [ecx+4] ; this->b
	add eax, [ecx+8] ; this->e
	
	leave
	retn 8
```


#### x86-64 호출 규약 - SYSV
---
Linux는 **System V(SYSV) Application Binary Interface(ABI)** 를 기반으로 만들어졌다. SYSV ABI는 ELF 포맷, 링킹 방법, 함수 호출 규약 등의 내용을 담고 있다. `file` 명령어를 사용해 바이너리의 정보를 살펴보면, 아래와 같이 *SYSV* 문자열이 포함된 것을 확인할 수 있다. 

```
$ file /bin/ls
/bin/ls: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV) ...
```

SYSV에서 정의한 함수 호출 규약은 다음의 특징을 가진다. 

1. 6개의 인자를 `rdi`, `rsi`, `rdx`, `rcx`, `r8`, `r9`에 순서대로 저장하여 전달한다.
2. 더 많은 인자를 사용할 때는 스택을 추가로 이용한다. 
3. Caller에서 인자 전달에 사용된 스택을 정리한다. 
4. 함수의 반환 값은 `rax`로 전달한다. 

아래 코드를 컴파일하고, [[GDB]]로 동적 분석하여 자세히 살펴보자. 

```cpp
// Name: sysv.c
// Compile: gcc -fno-asynchronous-unwind-tables -masm=intel
//         -fno-omit-frame-pointer -o sysv sysv.c -fno-pic -00

#define ull unsigned long long

ull callee(ull a1, int a2, int a3, int a4, int a5, int a6, int a7) {
	ull ret = a1 + a2 + a3 + a4 + a5 + a6 + a7;
	return ret;
}

void caller() { callee(123456789123456789, 2, 3, 4, 5, 6, 7); }

int main() { caller(); }
```

##### SYSV 상세 분석
---
SYSV는 앞으로 자주 접할 호출 규약이므로, 실행하며 gdb로 자세히 분석해 보자. 먼저, 아래 명령어를 실행해 앞에서 소개한 *sysv.c*를 컴파일한다. 

```
$ gcc -fno-asynchronous-unwind-tables -masm=intel -fno-omit-frame-pointer -o sysv sysv.c -fno-pic -00
```

**1. 인자 전달**
gdb로 *sysv*를 로드한 뒤 중단점을 설정하여 `caller()`까지 실행한다. 아래의 DISASM, 즉 디스어셈블 된 결과를 보면, `caller+10`부터 `caller+37`까지 6개의 인자를 각각의 레지스터에 설정하고 있으며, `caller+8`에서는 7번째 인자인 7을 스택으로 전달하고 있다. 

```
$ gdb -q sysv
pwndbg: loaded 139 pwndbg commands and 49 shell commands. Type pwndbg [--shell | --all] [filter] for a list.
pwndbg: created $rebase, $ida GDB functions (can be used with print/break)
Reading symbols from sysv...
...
pwndbg> b *caller
Breakpoint 1 at 0x1185
pwndbg> r
Starting program: /home/dreamhack/sysv

Breakpoint 1, 0x0000555555555185 in caller ()
...
──────────────[ DISASM / x86-64 / set emulate on ]──────────────
 ► 0x555555555185 <caller>       endbr64
   0x555555555189 <caller+4>     push   rbp
   0x55555555518a <caller+5>     mov    rbp, rsp
   0x55555555518d <caller+8>     push   7
   0x55555555518f <caller+10>    mov    r9d, 6
   0x555555555195 <caller+16>    mov    r8d, 5
   0x55555555519b <caller+22>    mov    ecx, 4
   0x5555555551a0 <caller+27>    mov    edx, 3
   0x5555555551a5 <caller+32>    mov    esi, 2
   0x5555555551aa <caller+37>    movabs rax, 0x1b69b4bacd05f15 ; 그 긴 숫자
   0x5555555551b4 <caller+47>    mov    rdi, rax
   0x5555555551b7 <caller+50>    call   0x555555555129 <callee>
   0x5555555551bc <caller+55>    add    rsp,0x8
...
```

`callee()`를 호출하기 전까지 실행하고, 레지스터와 스택을 확인해 보자. 

우선, 아래와 같이 `disass` 명령어로 `caller()`의 디스어셈블된 코드를 보고 `callee()`를 호출하는 부분을 파악한 후 해당 부분에 중단점을 설정한다. 

```
pwndbg> disass caller
...
   0x00005555555551b7 <+50>:  call   0x555555555129 <callee>
...
pwndbg> b *caller+50
Breakpoint 2 at 0x5555555551b7
```

`c` 명령어를 사용해서 프로그램을 실행하면 `callee()`를 호출하기 직전에 멈춘다. 

```
pwndbg> c
Continuing.

Breakpoint 2, 0x00005555555551b7 in caller ()
...
──────────[ REGISTERS / show-flags off / show-compact-regs off ]──────────
*RAX  0x1b69b4bacd05f15
 RBX  0x0
*RCX  0x4
*RDX  0x3
*RDI  0x1b69b4bacd05f15
*RSI  0x2
*R8   0x5
*R9   0x6
 R10  0x7ffff7fc3908 ◂— 0xd00120000000e
 R11  0x7ffff7fde680 (_dl_audit_preinit) ◂— endbr64
...

pwndbg> x/4gx $rsp
0x7fffffffe2f8: 0x0000000000000007  0x00007fffffffe310
0x7fffffffe308: 0x00005555555551d5  0x0000000000000001
```

소스 코드에 `callee(123456789123456789, 2, 3, 4, 5, 6, 7)`로 함수를 호출했는데, 인자가 순서대로 `rdi`, `rsi`, `rdx`, `rcx`, `r8`, `r9`, 그리고 `[rsp]`에 설정되어 있는 것을 확인할 수 있다. 


**2. 반환 주소 저장**
`si` 명령어로 한 단계 더 실행한다. `call`이 실행되고 스택을 확인해 보면 `0x555555554682`가 반환 주소로 저장되어 있다. gdb로 확인해보면 `0x555555554682`는 `callee()` 호출 다음 명령어의 주소이다. `callee()`에서 반환됐을 때, 이 주소를 꺼내 원래의 실행 흐름으로 돌아간다. 

```
pwndbg> si
0x00005555555545fa in callee ()
...
pwndbg> x/4gx $rsp
0x7fffffffdf70:	0x0000555555554682	0x0000000000000007
0x7fffffffdf80:	0x00007fffffffdf90	0x0000555555554697
pwndbg> x/10i 0x0000555555554682 - 5
   0x55555555467d <caller+43>:	call   0x5555555545fa <callee>
   0x555555554682 <caller+48>:	add    rsp,0x8
```


**3. 스택 프레임 저장**
`x/9i $rip` 명령어로 `callee()`의 함수 프롤로그를 살펴보면, 가장 먼저 `push rbp`를 통해 호출자(`caller()`)의 `rbp`를 저장하고 있다. `rbp`가 스택 프레임에서의 최하위 주소를 가리키는 포인터이므로, 이를 **Stack Frame Pointer (SFP)** 라고도 부른다. `callee()`에서 반환될 때, SFP를 꺼내 `caller()`의 스택 프레임으로 돌아갈 수 있다. 

`si`로 `push rbp`를 실행하고, 스택을 확인해보면 `rbp`값인 `0x00007fffffffe300`이 저장되었다. 

```
pwndbg> x/9i $rip
=> 0x555555555129 <callee>:	endbr64
   0x55555555512d <callee+4>:	push   rbp
   0x55555555512e <callee+5>:	mov    rbp,rsp
   0x555555555131 <callee+8>:	mov    QWORD PTR [rbp-0x18],rdi
   0x555555555135 <callee+12>:	mov    DWORD PTR [rbp-0x1c],esi
   0x555555555138 <callee+15>:	mov    DWORD PTR [rbp-0x20],edx
   0x55555555513b <callee+18>:	mov    DWORD PTR [rbp-0x24],ecx
   0x55555555513e <callee+21>:	mov    DWORD PTR [rbp-0x28],r8d
   0x555555555142 <callee+25>:	mov    DWORD PTR [rbp-0x2c],r9d
pwndbg> si
pwndbg> si
0x000055555555512e in callee ()
──────────────────[ DISASM / x86-64 / set emulate on ]──────────────────
   0x555555555129 <callee>       endbr64
   0x55555555512d <callee+4>     push   rbp
 ► 0x55555555512e <callee+5>     mov    rbp, rsp
   0x555555555131 <callee+8>     mov    qword ptr [rbp - 0x18], rdi
...
pwndbg> x/4gx $rsp
0x7fffffffe2e8: 0x00007fffffffe300  0x00005555555551bc
0x7fffffffe2f8: 0x0000000000000007  0x00007fffffffe310
pwndbg> print $rbp
$1 = (void *) 0x7fffffffe300
```


**4. 스택 프레임 할당**
이제 `mov rbp, rsp`로 `rbp`와 `rsp`가 같은 주소를 가리키게 한다. 바로 다음에 `rsp`의 값을 빼게 되면, `rbp`와 `rsp` 사이 공간을 새로운 스택 프레임으로 설정하는 것이지만, `callee()`는 지역 변수를 사용하지 않으므로, 새로운 스택 프레임을 만들지 않는다. 

`si`로 실행하고, 레지스터를 보면서 이 둘이 같은 주소를 가리키는 모습을 확인할 수 있다. 

```
pwndbg> x/5i $rip
=> 0x55555555512e <callee+5>: mov    rbp,rsp
   0x555555555131 <callee+8>: mov    QWORD PTR [rbp-0x18],rdi
   0x555555555135 <callee+12>:  mov    DWORD PTR [rbp-0x1c],esi
   0x555555555138 <callee+15>:  mov    DWORD PTR [rbp-0x20],edx
   0x55555555513b <callee+18>:  mov    DWORD PTR [rbp-0x24],ecx

pwndbg> print $rbp
$2 = (void *) 0x7fffffffe300
pwndbg> print $rsp
$3 = (void *) 0x7fffffffe2e8

pwndbg> si

pwndbg> print $rbp
$4 = (void *) 0x7fffffffe2e8
pwndbg> print $rsp
$5 = (void *) 0x7fffffffe2e8
```


**5. 반환값 전달**
덧셈 연산을 모두 마치고, 함수 에필로그에 도달하면, 반환값을 `rax`에 옮긴다. 반환 직전에 `rax`를 출력하면 전달한 7개 인자의 합인 123456789123456816을 확인할 수 있다. 

```
pwndbg> b *callee+79
Breakpoint 3 at 0x555555555178
pwndbg> c
...
───────────────────[ DISASM / x86-64 / set emulate on ]───────────────────
 ► 0x555555555178 <callee+79>    add    rax, rdx
   0x55555555517b <callee+82>    mov    qword ptr [rbp - 8], rax
   0x55555555517f <callee+86>    mov    rax, qword ptr [rbp - 8]
   0x555555555183 <callee+90>    pop    rbp
   0x555555555184 <callee+91>    ret

pwndbg> b *callee+91
Breakpoint 4 at 0x555555555184
pwndbg> c
...
───────────────────[ DISASM / x86-64 / set emulate on ]───────────────────
   0x555555555178 <callee+79>    add    rax, rdx
   0x55555555517b <callee+82>    mov    qword ptr [rbp - 8], rax
   0x55555555517f <callee+86>    mov    rax, qword ptr [rbp - 8]
   0x555555555183 <callee+90>    pop    rbp
 ► 0x555555555184 <callee+91>    ret              <0x5555555551bc; caller+55>
    ↓
...

pwndbg> print $rax
$1 = 123456789123456816
```


**6. 반환**
반환은 저장해뒀던 스택 프레임과 반환 주소를 스택에서 꺼내며 이루어진다. 여기서는 `callee()`가 스택 프레임을 만들지 않았기 때문에, `pop rbp`로 스택 프레임을 꺼낼 수 있지만, 일반적으로 `leave`로 스택 프레임을 꺼낸다. 

스택 프레임을 꺼낸 뒤에는 `ret`으로 호출자로 복귀한다. 앞에서 저장해뒀던 SFP로 `rbp`가, 반환 주소로 `rip`가 설정된 것을 확인할 수 있다. 

```
pwndbg> d
pwndbg> b *callee+90
Breakpoint 1 at 0x1183
pwndbg> r
...
───────────────────[ DISASM / x86-64 / set emulate on ]───────────────────
 ► 0x555555555183 <callee+90>                     pop    rbp
   0x555555555184 <callee+91>                     ret
    ↓
...

pwndbg> si
pwndbg> si
...
───────────────────[ DISASM / x86-64 / set emulate on ]───────────────────
   0x555555555183 <callee+90>                     pop    rbp
   0x555555555184 <callee+91>                     ret
    ↓
 ► 0x5555555551bc <caller+55>                     add    rsp, 8
   0x5555555551c0 <caller+59>                     nop
   0x5555555551c1 <caller+60>                     leave
   0x5555555551c2 <caller+61>                     ret
    ↓
...
pwndbg> print $rbp
$1 = (void *) 0x7fffffffe300
pwndbg> print $rip
$2 = (void (*)()) 0x5555555551bc <caller+55>
```


### 강의 요약
---
**x86 함수 호출 규약**

| 함수호출규약   | 사용 컴파일러   | 인자 전달 방식               | 스택 정리  | 적용      |
| -------- | --------- | ---------------------- | ------ | ------- |
| cdecl    | GCC, MSVC | Stack                  | Caller | 일반 함수   |
| stdcall  | MSVC      | Stack                  | Callee | WINAPI  |
| fastcall | MSVC      | `ecx`, `edx`           | Callee | 최적화된 함수 |
| thiscall | MSVC      | `ecx`(인스턴스), Stack(인자) | Callee | 클래스의 함수 |


**x86-64 함수 호출 규약**

| 함수호출규약     | 사용 컴파일러 | 인자 전달 방식                                         | 스택 정리  | 적용                     |
| ---------- | ------- | ------------------------------------------------ | ------ | ---------------------- |
| System ABI | GCC     | `rdi`, `rsi`, `rdx`, `rcx`, `r8`, `r9`, `xmm0-7` | Caller | 일반 함수                  |
| MS ABI     | MSVC    | `rcx`, `rdx`, `r8`, `r9`                         | Caller | 일반 함수, Windows Syscall |
