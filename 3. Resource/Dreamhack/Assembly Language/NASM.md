기계어는 사람이 읽고 이해하기 어렵기 때문에 보다 직관적인 방식으로 프로그래밍할 수 있도록 어셈블리어가 만들어 졌으며, 어셈블리어를 기계어로 변환하는 역할을 하는 프로그램이 어셈블러이다. 

사용자의 운영체제에 따라 사용되는 어셈블리어는 다를 수 있으며, 본 강의의 환경인 Linux에서는 NASM과 GAS가 주로 사용된다. 
NASM은 x86 및 x86-64용으로 ELF 바이너리 포맷을 지원하고, 
GAS는 GCC 컴파일러와 함께 AT&T 문법을 사용한다. 
본 강의에서는 Linux 환경에서 많이 사용하는 NASM 어셈블러를 사용해 프로그램을 작성하는 방법과 다양한 옵션들을 알아 볼 것이다. 

---
### NASM 사용법
일반적으로 어셈블러를 사용해 어셈블리 코드를 실행 가능한 프로그램으로 만들기 위해서는 아래의 작업을 거쳐야 한다.
1. 어셈블리 코드 작성
2. 어셈블러를 사용해 어셈블리 코드를 목적 파일(Object file)로 변환
3. 링커(Linker)를 사용해 실행 파일 생성

>[!example]- 목적 파일과 링커
> **목적 파일(Object file)** 이란 컴파일이나 어셈블 과정에서 소스 코드로부터 생성된 기계 코드를 포함하고 있는 파일을 뜻한다. 목적 파일에는 각 함수나 전역 변수에 해당하는 기계어, 명령어, 그리고 아직 연결되지 않은 외부 심볼 등이 포함되어 있다. 파일 별로 목적 파일을 만들어 두면 병렬로 컴파일 할 수 있어 전체 빌드 시간을 크게 단축할 수 있으며, 재사용성과 효율성이 크게 향상된다. 
> 
> ---
> **링커(Linker)** 는 여러 목적 파일들을 하나로 결합해 최종적으로 실행 가능한 파일을 생성한다. 이 과정에서 각 목적 파일 사이의 함수 호출이나 변수 참조 같은 것을 서로 연결하고, 각 목적 파일에서 사용하던 상대 주소를 실제 메모리 주소로 재배치한다. 이렇게 완성된 실행 파일은 운영체제가 직접 로드해 실행한다.

#### 어셈블리 코드 작성
어셈블리 코드는 아래와 같이 작성할 수 있다. 
```asm
section .data
    message db "Hello, Dreamhack!", 0xA
    msg_len equ $ - message

section .text
    global _start

_start:
    mov rax, 1
    mov rdi, 1
    mov rsi, message
    mov rdx, msg_len
    syscall

    mov rax, 60
    xor rdi, rdi
    syscall
```
#### 어셈블러를 사용해 코드를 목적 파일로 변환
어셈블리 코드를 원하는 형태의 목적 파일로 만들기 위해 `-f` 옵션을 사용할 수 있다. 
또한, 생성할 파일의 이름을 `-o` 옵션으로 지정할 수 있다. 
아래 명령어를 터미널에 입력하면 어셈블러를 사용해 어셈블리 코드를 목적 파일로 변환한다. 

`nasm -f elf64 example.asm -o example.o`
* `-f elf64`: 64bit ELF 포맷을 지정해 해당 형태로 목적 파일 생성
* `-o example.o`: 생성할 목적 파일의 이름 지정

>[!example]- NASM 옵션
>`-f <format>`: 어셈블리 코드를 변환할 양식을 지정해 준다. 운영체제마다 실행 가능한 프로그램의 형식이 다르며, 리눅스는 ELF 또는 ELF64를 사용하고 Windows는 win32 또는 win64를 사용한다. 형식을 지정해 주어야 어셈블리 코드를 운영체제에서 실행할 수 있는 파일로 바꾸어 준다. ![[Pasted image 20250729201025.png]]
>
>---
>`-o <filename>`: 생성될 목적 파일의 이름을 지정한다. 
>
>---
>`-g`: 목적 파일에 디버깅을 위한 심볼 정보를 저장한다. 해당 옵션을 사용하면 GDB와 같은 디버거를 사용할 때 프로그램을 조금 더 쉽게 분석할 수 있다. 
>
>---
>`-I <path>`
: 헤더 파일 등의 외부 파일을 포함할 때 사용하며, 포함할 외부 파일의 경로를 지정한다. NASM에서는 `%include`를 이용해 외부 파일을 포함할 수 있으며, 이는 C언어의 `#include`와 비슷하다. ![[Pasted image 20250729201737.png]]![[Pasted image 20250729201759.png]] 이 명령어를 실행하면 `constants.inc`를 `example.asm`에 포함시켜 목적 파일인 `example.o`를 생성한다. ![[Pasted image 20250729201905.png]]
>
>---
>`-0<level>`: 최적화 수준을 설정할 때 사용한다. 
>`<level>`의 값에 따라 최적화 수준을 조절할 수 있으며, 일반적으로 높아질수록 최적화 수준도 높다. 
>
>---
>기타 옵션
>![[Pasted image 20250729202227.png]]

#### 링커를 사용해 실행 파일 생성
어셈블리 코드를 목적 파일로 변환한 후, 링커를 사용해 실행 파일을 생성할 수 있다. 어셈블러 사용과 마찬가지로 `-o` 옵션을 통해 생성할 파일의 이름을 지정할 수 있다. 
아래 명령어를 터미널에 입력하면 링커를 사용해 목적 파일을 실행 파일로 변환한다. 

`ld example.o -o example`
* `ld`: ld는 유닉스에서 사용할 수 있는 동적 링커(Dynamic Linker)의 일종으로, 목적 파일들을 합쳐 실행 파일로 변환하는 기능을 한다. 

위의 두 명령어를 실행한 후, 생성된 실행 파일인 `example`을 실행하면 아래와 같이 `Hello, Dreamhack!`이 출력된다. 
![[Pasted image 20250729200621.png]]

---
### NASM 설치
NASM이 설치되어 있지 않다면, 다음의 명령어를 이용해 설치 가능하다. 
```
sudo apt-get install nasm
```
