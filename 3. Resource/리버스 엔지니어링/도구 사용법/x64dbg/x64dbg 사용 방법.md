
### 🧭x64dbg 둘러보기

- x64dbg를 실행하면 시작 화면에서 다음과 같은 작업창을 볼 수 있다.
    
    ![[image 4 1.png]]
    
    1. 프로그램 코드: 어셈블리어 코드와 명령어코드를 나타내고 있는 목적 코드 부분
    2. 레지스터: CPU의 레지스터 값을 보여주는 창으로, 실행 단계에서 값의 변화를 실시간으로 볼 수 있음
    3. 메모리: 메모리 공간의 값을 16진수 값과 ASCII 코드로 보여주며, 관심 있는 주소를 설정하여 데이터 값의 변화를 확인할 수 있음
    4. 스택: 함수에서 사용하는 스택 내용을 보여 주며, 원하는 주소의 스택 영역의 값을 확인할 수 있음
    5. 실행 상태 값: 프로그램 코드 부분에서 실행하고 있는 위치의 오프셋 값과 변경된 메모리 주소, 레지스터의 내용 등의 정보를 확인할 수 있음
    6. 함수스택 변수: 프로그램 코드 부분에서 사용하는 매개변수와 지역변수의 위치를 레지스터 변위 값으로 표현함

### 🔧x64dbg 주요 기능

**x64dbg의 실행 기능 (자주 사용하는 명령어와 단축키)**

|명령어|단축키|설명|
|---|---|---|
|파일 불러오기|F3|실행 파일을 디버거에 적재|
|프로세스 불러오기|Alt + A|실행 프로세스를 디버거에 적재|
|실행|F9|프로그램을 실행 (중단점이 있으면 그곳까지)|
|반환할 때까지 실행|Ctrl + F9|함수에서 함수의 끝에 있는 ret 명령을 실행하기 전까지 실행|
|중단점 설정|F2|Break point를 설정 또는 해제|
|선택까지 실행|F4|마우스나 화살표로 선택한 부분까지 실행|
|다시 시작|Ctrl + F2|프로그램을 처음부터 다시 시작|
|닫기|Alt + F2|프로그램을 종료 (종료한 후 다시 시작 가능)|
|안으로 단계진행|F7|call의 안으로 들어가서 실행|
|건너서 단계진행|F8|안으로 들어가지 않고 실행|
|안으로 자동진행|Ctrl + F7|F7을 사용하여 자동 코드 실행, F12로 멈춤|
|건너서 자동진행|Ctrl + F8|F8을 사용하여 자동 코드 실행, F12로 멈춤|
|닫기|F12|자동 실행 중 일시정지|
따라서 원하는 코드의 위치로 찾아가기 위해서는 다음과 같은 과정을 반복하면 된다. 
1. F8: 한 줄씩 코드 진행
2. F2: Call 함수 위치에 중단점 설정
3. Ctrl+F2: 재시작
4. F9: 중단점까지 실행
5. F2: 이전 중단점 해제
6. F7: Call 함수 위치로 이동

따라서, 디버깅을 진행하다가 어떤 함수의 내부가 궁금할 때는 F7을, 그렇지 않을 때는 F8을 눌러서 디버깅을 진행할 수 있다. 

**x64dbg의 보조 기능 (디버깅 과정의 편의성)**

| 명령어      | 단축키      | 설명                                                                                                                         |
| -------- | -------- | -------------------------------------------------------------------------------------------------------------------------- |
| 코드 미리 보기 | Enter    | Call이나 Jmp 명령어 코드 위에서 사용하였을 때, Call/Jmp 목적 주소로 옮겨서 그 곳의 코드를 실행하지 않고 보여주며, x64dbg에서는 마우스를 해당 명령어 위로 이동하면 팝업창으로 그 곳의 코드를 보여줌 |
| 주소 이동    | Ctrl + G | 원하는 주소로 실행하지 않고 이동                                                                                                         |
| 데이터 편집   | Ctrl + E | 해당 위치의 코드 또는 데이터 수정                                                                                                        |
| 주석       | ;        | 주석 달기                                                                                                                      |
| 레이블      | :        | 레이블 추가 (해당되는 주소에 이름이 주어짐)                                                                                                  |
| 뒤로 진행    | -        | 현재 명령어 전의 명령어 위치로 실행 취소하지 않고 이동                                                                                            |
| 앞으로 진행   | +        | 현재 명령어의 다음 명령어 위치로 실행하지 않고 이동                                                                                              |

---

### 💻디버거를 사용하여 예시 프로그램 디버깅

- 예시 프로그램 C언어 코드 
    ```c
    #include <stdio.h>
    
    int main() 
    {
    	int n;
    	printf("Input Number: ");
    	scanf_s("%d", &n); 
    	
    	printf("Before switch statement\\n");
    	switch (n) {
    	case 0: printf("[zero]"); break;
    	case 1: printf("[one]"); break;
    	case 2: printf("[two]"); break;
    	case 3: printf("[three]"); break;
    	case 4: printf("[four]"); break;
    	default: printf("[error]"); break;
    	}
    	printf("After switch statement\\n");
    	
    	return 0;
    }
    ```

    
- 컴파일된 실행 파일이 64bit 프로그램이기 때문에, x64dbg를 사용하여 실행 파일을 불러온다. 프로그램을 구동시키고 [파일] → [열기]를 수행하여 분석할 실행 파일을 로드한다.
    
    ![[image 5 1.png]]
    
- 처음에 나오는 DLL파일은 ntdll.dll로, 시스템의 핵심 API를 호출하고 프로그램과 하드웨어 간의 연결을 지원하는 역할을 하며, 이 파일이 손상되거나 누락되면 프로그램 실행 오류 또는 시스템 충돌이 발생할 수 있다.
    
- 하지만, 우리는 Programming2.exe만 분석할 것이므로, 원하는 위치까지 직접 찾아가야 한다.
    
- 원하는 위치를 찾기 위해 문자열 검색을 사용하기 위해서는 프로그램 코드 창에서 마우스 오른쪽 버튼을 클릭하고, 메뉴가 나타나면 `다음을 찾기 -> 모든 유저 모듈 -> 문자열 참조`를 선택한다.
    
    ![[image 6 1.png]]
    
- 아래의 화면에서 원하는 문자열을 찾아 해당 내용을 클릭하면 관련된 코드 위치로 이동하게 된다. 이렇게 하면 특정 코드까지 실행하며 진행하지 않아도 바로 원하는 곳까지 찾아갈 수 있다.
    
    ![[image 7 1.png]]
    
- 원하는 위치에 도착했다면, 디버깅을 시작할 준비가 되었다. 디버깅을 하다 보면 분석하는 데 오랜 시간이 걸리는 경우가 많아 디버깅 도중에 휴식을 취하고 다시 이어서 할 필요가 있다.
    
- 따라서 디버깅을 다시 시작하는 지점을 기억할 필요가 있는데, 이 지점을 베이스캠프(base camp)라 한다. 보통, 중단점을 설정하여 베이스캠프를 지정한다.
    
- **중단점은 실행 도중에 멈추게 되므로 프로그램을 다시 분석하더라도 해당 지점에서 멈추게 할 수 있다.** 중단점의 설정과 해제는 F2키를 사용하며, 설정된 중단점은 중단점 탭에서 확인이 가능하고 Del키를 사용해서 중단점을 해제할 수 있다.
    
    ![[image 8.png]]
    
    ![[image 9.png]]

### 👨‍🔧스택을 활용한 함수의 Parameter 확인 방법
- x64dbg를 제대로 활용하기 위해서는 스택에 대한 이해가 필수적이다. 
- [[함수 프롤로그 & 에필로그]] 문서에서도 볼 수 있듯이 어떤 함수 하나가 호출되면, 그 함수는 자기만의 스택 공간을 가지게 되며, 이를 스택 프레임이라 한다. 

- 예시로 하나의 덧셈을 구현하는 함수를 생각해 보자. 
```c
int add(const int a, const int b) // Example Function
{
	int res = a + b;
	return res;
}

int main(void) // Main Function
{
	int a = 1;
	int b = 2;
	return add(a, b);
}
```
이 코드의 `main`함수를 어셈블리어로 바꾸면 다음과 같다. ![[Pasted image 20250814144506.png]]

- 먼저, 함수 프롤로그를 통해 `main`함수가 쓸 수 있는 스택 프레임을 할당한다. 
- 이후, 변수 `a`, `b`를 스택의 메모리에 집어 넣는다. 
	- `mov dword ptr [ebp-8], 1`: EBP, 즉 스택의 베이스에서 8만큼 뺀 주소에 1을 넣는다. 
	- `mov dword ptr [ebp-0ch], 2`: EBP에서 12만큼 뺀 주소에 2를 넣는다.
	- 이를 그림으로 표현하면 다음과 같다.
		![[Pasted image 20250814144905.png]]

- `add`함수의 매개변수의 값을 복사한다. 
	- `add`함수의 인자에 값을 전달할 때는 값을 복사해서 움직인다.
	- `mov eax,dword ptr [ebp-0ch]`: EAX에 2번째 인자인 2를 복사한다.
	- `mov ecx,dword ptr [ebp-8]`: ECX에 1번째 인자인 1을 복사한다. 
	- 이를 그림으로 표현하면 다음과 같다. 
		![[Pasted image 20250814145349.png]]

- `add`함수를 호출한다.
	- `call (주소)`: 해당 주소로 점프하라는 의미로, `push`와 `jmp`두 개를 합한 명령어다.
		- `push`: ESP 포인터가 가리키는 메모리 위치 다음에 있는 스택 메모리에 값을 집어넣는다.
		- `jmp`: 해당 주소로 이동한다.
	- 따라서, ESP를 늘린 메모리에 함수를 호출하고, 다음으로 갈 명령어인 `0001102D`를 대입하고 `add`함수로 `jmp`한다. 
	- 이를 그림으로 표현하면 다음과 같다. 
		![[Pasted image 20250814145712.png]]

- **따라서, 악성코드 등의 복잡한 프로그램을 분석할 때도 위와 같은 순서대로 분석하면 특정한 함수가 어떤 인자를 받고 있는지를 매우 간단하게(?) 알아볼 수 있다.**