### 🧭x64dbg 둘러보기

- x64dbg를 실행하면 시작 화면에서 다음과 같은 작업창을 볼 수 있다.
    
    ![[image 4 1.png]]
    
    1. 프로그램 코드: 어셈블리어 코드와 명령어코드를 나타내고 있는 목적 코드 부분
    2. 레지스터: CPU의 레지스터 값을 보여주는 창으로, 실행 단계에서 값의 변화를 실시간으로 볼 수 있음
    3. 메모리: 메모리 공간의 값을 16진수 값과 ASCII 코드로 보여주며, 관심 있는 주소를 설정하여 데이터 값의 변화를 확인할 수 있음
    4. 스택: 함수에서 사용하는 스택 내용을 보여 주며, 원하는 주소의 스택 영역의 값을 확인할 수 있음
    5. 실행 상태 값: 프로그램 코드 부분에서 실행하고 있는 위치의 오프셋 값과 변경된 메모리 주소, 레지스터의 내용 등의 정보를 확인할 수 있음
    6. 함수스택 변수: 프로그램 코드 부분에서 사용하는 매개변수와 지역변수의 위치를 레지스터 변위 값으로 표현함

### 🔧x64dbg 주요 기능

**x64dbg의 실행 기능 (자주 사용하는 명령어와 단축키)**

|명령어|단축키|설명|
|---|---|---|
|파일 불러오기|F3|실행 파일을 디버거에 적재|
|프로세스 불러오기|Alt + A|실행 프로세스를 디버거에 적재|
|실행|F9|프로그램을 실행 (중단점이 있으면 그곳까지)|
|반환할 때까지 실행|Ctrl + F9|함수에서 함수의 끝에 있는 ret 명령을 실행하기 전까지 실행|
|중단점 설정|F2|Break point를 설정 또는 해제|
|선택까지 실행|F4|마우스나 화살표로 선택한 부분까지 실행|
|다시 시작|Ctrl + F2|프로그램을 처음부터 다시 시작|
|닫기|Alt + F2|프로그램을 종료 (종료한 후 다시 시작 가능)|
|안으로 단계진행|F7|call의 안으로 들어가서 실행|
|건너서 단계진행|F8|안으로 들어가지 않고 실행|
|안으로 자동진행|Ctrl + F7|F7을 사용하여 자동 코드 실행, F12로 멈춤|
|건너서 자동진행|Ctrl + F8|F8을 사용하여 자동 코드 실행, F12로 멈춤|
|닫기|F12|자동 실행 중 일시정지|
따라서 원하는 코드의 위치로 찾아가기 위해서는 다음과 같은 과정을 반복하면 된다. 
1. F8: 한 줄씩 코드 진행
2. F2: Call 함수 위치에 중단점 설정
3. Ctrl+F2: 재시작
4. F9: 중단점까지 실행
5. F2: 이전 중단점 해제
6. F7: Call 함수 위치로 이동

따라서, 디버깅을 진행하다가 어떤 함수의 내부가 궁금할 때는 F7을, 그렇지 않을 때는 F8을 눌러서 디버깅을 진행할 수 있다. 

**x64dbg의 보조 기능 (디버깅 과정의 편의성)**

|명령어|단축키|설명|
|---|---|---|
|코드 미리 보기|Enter|Call이나 Jmp 명령어 코드 위에서 사용하였을 때, Call/Jmp 목적 주소로 옮겨서 그 곳의 코드를 실행하지 않고 보여주며, x64dbg에서는 마우스를 해당 명령어 위로 이동하면 팝업창으로 그 곳의 코드를 보여줌|
|주소 이동|Ctrl + G|원하는 주소로 실행하지 않고 이동|
|데이터 편집|Ctrl + E|해당 위치의 코드 또는 데이터 수정|
|주석|;|주석 달기|
|레이블|:|레이블 추가 (해당되는 주소에 이름이 주어짐)|
|뒤로 진행|-|현재 명령어 전의 명령어 위치로 실행 취소하지 않고 이동|
|앞으로 진행|+|현재 명령어의 다음 명령어 위치로 실행하지 않고 이동|

---

### 💻디버거를 사용하여 예시 프로그램 디버깅

- 예시 프로그램 C언어 코드 
    ```c
    #include <stdio.h>
    
    int main() 
    {
    	int n;
    	printf("Input Number: ");
    	scanf_s("%d", &n); 
    	
    	printf("Before switch statement\\n");
    	switch (n) {
    	case 0: printf("[zero]"); break;
    	case 1: printf("[one]"); break;
    	case 2: printf("[two]"); break;
    	case 3: printf("[three]"); break;
    	case 4: printf("[four]"); break;
    	default: printf("[error]"); break;
    	}
    	printf("After switch statement\\n");
    	
    	return 0;
    }
    ```

    
- 컴파일된 실행 파일이 64bit 프로그램이기 때문에, x64dbg를 사용하여 실행 파일을 불러온다. 프로그램을 구동시키고 [파일] → [열기]를 수행하여 분석할 실행 파일을 로드한다.
    
    ![[image 5 1.png]]
    
- 처음에 나오는 DLL파일은 ntdll.dll로, 시스템의 핵심 API를 호출하고 프로그램과 하드웨어 간의 연결을 지원하는 역할을 하며, 이 파일이 손상되거나 누락되면 프로그램 실행 오류 또는 시스템 충돌이 발생할 수 있다.
    
- 하지만, 우리는 Programming2.exe만 분석할 것이므로, 원하는 위치까지 직접 찾아가야 한다.
    
- 원하는 위치를 찾기 위해 문자열 검색을 사용하기 위해서는 프로그램 코드 창에서 마우스 오른쪽 버튼을 클릭하고, 메뉴가 나타나면 `다음을 찾기 -> 모든 유저 모듈 -> 문자열 참조`를 선택한다.
    
    ![[image 6 1.png]]
    
- 아래의 화면에서 원하는 문자열을 찾아 해당 내용을 클릭하면 관련된 코드 위치로 이동하게 된다. 이렇게 하면 특정 코드까지 실행하며 진행하지 않아도 바로 원하는 곳까지 찾아갈 수 있다.
    
    ![[image 7 1.png]]
    
- 원하는 위치에 도착했다면, 디버깅을 시작할 준비가 되었다. 디버깅을 하다 보면 분석하는 데 오랜 시간이 걸리는 경우가 많아 디버깅 도중에 휴식을 취하고 다시 이어서 할 필요가 있다.
    
- 따라서 디버깅을 다시 시작하는 지점을 기억할 필요가 있는데, 이 지점을 베이스캠프(base camp)라 한다. 보통, 중단점을 설정하여 베이스캠프를 지정한다.
    
- **중단점은 실행 도중에 멈추게 되므로 프로그램을 다시 분석하더라도 해당 지점에서 멈추게 할 수 있다.** 중단점의 설정과 해제는 F2키를 사용하며, 설정된 중단점은 중단점 탭에서 확인이 가능하고 Del키를 사용해서 중단점을 해제할 수 있다.
    
    ![[image 8.png]]
    
    ![[image 9.png]]