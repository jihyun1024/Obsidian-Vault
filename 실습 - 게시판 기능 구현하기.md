## 들어가며
---
이번 강의는 게시판 기능을 구현하면서 웹 서버가 어떤 원리로 구현되어 동작하는지를 더 깊이 이해할 수 있도록 할 것이다. 강의에서는 다음 기능들을 단계적으로 구현한다. 

1. 게시글 목록을 조회하는 기능
2. 게시글을 작성하는 기능
3. 게시글을 조회하는 기능
4. 게시글을 수정하는 기능
5. 게시글을 삭제하는 기능

위의 각 기능들을 [[실습 - 깔끔한 코드 패턴 만들기]] 강의에서 구현한 로그인 기능이 존재하는 Flask 웹 서버에 추가해볼 것이다. 각 기능을 하나하나 구현하며 진행하는 강의는 아니며, 각 기능이 추가될 때마다 발생하는 **변경사항과 코드의 작동 방식을 하나씩 자세히 살펴보는 방식으로 강의를 진행할 것이다.** 

![[Pasted image 20260116205257.png]]

한편, 웹 개발이나 웹 해킹을 공부하다 보면 **CRUD**라는 단어를 반드시 접하게 되는데, 이는 **Create(생성), Read(조회), Update(수정), Delete(삭제)** 의 약자로, 데이터를 다루는 네 가지 기본적인 작업을 의미하며 대부분의 웹 서비스와 데이터베이스 시스템이 동작하는 기본적인 원리이다.

CRUD는 많은 웹 서비스의 동작에 내재된 기본 원리로, 이를 이해하면 웹 서비스를 분석하고 공격 시나리오를 설계하는 데 큰 도움이 된다. 특히, <u>CRUD의 각 작업(Create, Read, Update, Delete)은 웹 해커들이 주로 공격 지점으로 삼는 부분이기도 하다.</u>


## 게시판 기능 구현하기
---
### 게시판 기능 구상하기
---
구현에 앞서, 게시판 기능을 구상해보도록 하자. 다음 다섯 가지의 기능을 추가할 것이다. 

- 게시글 목록 조회 기능
	- `GET /posts` - 게시글 목록을 보여 주는 페이지를 반환한다. 
- 게시글 작성 기능
	- `GET /posts/new` - 게시글을 작성할 수 있는 페이지를 반환한다. 
	- `POST /posts/new` - 게시글 작성을 실제 처리한다.
- 게시글 조회 기능
	- `GET /posts/<post_id>` - `post_id`에 해당하는 게시글을 보여주는 페이지를 반환한다. 
	- 게시글을 보여 주는 페이지에서는 <u>게시글을 수정/삭제할 수 있는 버튼을 보여 준다.</u>
- 게시글 수정 기능
	- `GET /posts/<post_id>/edit` - `post_id`에 해당하는 게시글을 수정할수 있는 페이지를 반환한다. 
	- 게시글 제목과 게시글 내용을 수정할 수 있도록 <u>입력폼을 보여주어야 하며, 수정하기 버튼도 필요하다.</u>
	- `POST /posts/<post_id>/edit` - `post_id`에 해당하는 게시글 수정을 실제 처리한다.
- 게시글 삭제 기능
	- `GET /posts/<post_id>/delete` - `post_id`에 해당하는 게시글을 삭제할 수 있는 페이지를 반환한다. 이때, <u>정말로 삭제할 것인지를 묻는 문구를 예/아니요 버튼과 함께 표시한다.</u>
	- `POST /posts/<post_id>/delete` - `post_id`에 해당하는 게시글 삭제를 실제 처리한다. 


## 게시글 데이터 구조 정의
---
이번 장에서는 게시글 데이터를 생각해보고 **게시글을 담는 테이블을 생성하는 코드를 *db.py*에 추가한다**. 

웹 사이트에 새로운 기능을 추가하거나 새로운 데이터를 다룰 때는 데이터의 구조를 사전에 구상해보고 이를 기반으로 데이터베이스의 설계를 진행하는 작업이 중요하다. 

- 여러 게시글 중 특정 게시글을 조회, 수정, 삭제할 수 있어야 한다.
	- 각 게시글을 구분할 수 있는 식별자가 존재해야 한다. 
- 게시글의 제목이 존재해야 한다. 
- 게시글의 내용이 존재해야 한다.
- 게시글을 수정하거나 삭제하는 작업은 해당 글의 작성자만 할 수 있도록 해야 한다. 
	- 수정하거나 삭제하려는 사용자가 작성자와 동일한 사람인지 검증하기 위해, 작성자의 정보도 게시글 데이터에 포함되어야 한다. 

위 요소들을 바탕으로 데이터베이스에 테이블을 만드는 코드를 *db.py*에 추가해야 하며, *db.py* 파일의 변경된 코드는 다음과 같다. 

```python
import sqlite3


def init_db():
	conn = sqlite3.connect('webserver.db')
	cursor = conn.cursor()
	cursor.execute('''
		CREATE TABLE IF NOT EXISTS accounts (
			id        INTEGER PRIMARY KEY AUTOINCREMENT,
			username  TEXT UNIQUE NOT NULL,
			password  TEXT NOT NULL
		)
	''')
	cursor.execute('''
		CREATE TABLE IF NOT EXISTS posts (
			id        INTEGER PRIMARY KEY AUTOINCREMENT,
			title     TEXT NOT NULL,
			content   TEXT NOT NULL,
			author    INTEGER NOT NULL,
			FOREIGN KEY (author) REFERENCES accounts(id)
		)
	''')
	conn.commit()
	conn.close()


def add_account(username, password):
	conn = sqlite3.connect('webserver.db')
	cursor = conn.cursor()
	try:
		cursor.execute('INSERT INTO accounts (username, password) VALUES (?, ?)', (username, password))
		conn.commit()
		conn.close()
		return True
	except sqlite3.IntegrityError:
		conn.close()
		return False


def check_account(username, password):
	conn = sqlite3.connect('webserver.db')
	cursor = conn.cursor()
	cursor.execute('SELECT * FROM accounts WHERE username = ? AND password = ?', (username, password))
	user = cursor.fetchone()
	conn.close()
	return user
```

여기서 `init_db()` 함수의 SQL 명령 부분만 살펴보자. 

```sqlite
CREATE TABLE IF NOT EXISTS posts (
    id          INTEGER PRIMARY KEY AUTOINCREMENT,
    title       TEXT NOT NULL,
    content     TEXT NOT NULL,
    author      INTEGER NOT NULL,
    FOREIGN KEY (author) REFERENCES accounts(id)
)
```

위 query로 생성된 테이블에는 게시글 데이터가 여러 개 저장될 수 있으며, 하나의 게시글 데이터는 다음의 정보들을 가진다. 

- `id` - 테이블의 기본 키(`PRIMARY KEY`)로, 각 게시글을 고유하게 식별하는 데 사용하는 키이다. 정수 형태를 띄며 1부터 시작해 자동으로 증가한다.
- `title` - 게시글의 제목으로, 빈 내용이 아닌 텍스트를 담는다.
- `content` - 게시글의 내용으로, 빈 내용이 아닌 텍스트를 담는다. 
- `author` - 게시글의 작성자로, 정수 형태의 데이터이며 **사용자의 고유 번호**를 담는다.
- `FOREIGN KEY (author) REFERENCES accounts(id)` - `author` 부분을 **외래 키(`FOREIGN KEY`)로 설정하는 구문** 이다. 
	- 외래 키는 한 테이블이 다른 테이블과 연결되도록 만들어 주는 역할로, 쉽게 말해 *"이 데이터가 다른 테이블의 어느 데이터와 관계가 있다"* 라고 하는 역할을 한다. 
	- 이 구문에서는 `author` 필드가 `accounts` 테이블의 `id` 필드에 있는 값을 참조하도록 설정하여 "이 게시글의 작성자는 실제로 `accounts` 테이블에 존재하는 사용자여야 함"을 데이터베이스가 자동으로 확인하고 보장하도록 만들기 위한 목적으로 사용되었다.


## 게시글 목록 조회 기능
---
이번에는 게시글 목록을 조회하는 기능을 구현해볼 것이다. 

이를 위해 `GET /posts` 엔드포인트를 만든 후 게시글 목록을 보여주는 페이지를 반환하도록 할 것이다. 이때, 반환되는 HTML 문서의 이름은 *posts.html*로 한다. 또한, 사용자가 매번 URL 바에 `/posts`를 입력해서 접근하기에는 매우 불편하고 번거로우니 메인 페이지(`/`)에 게시글 목록 페이지(`/posts`)로 이동할 수 있는 버튼을 만들 것이다. 


### 게시글 목록을 반환하는 함수 추가하기
---
