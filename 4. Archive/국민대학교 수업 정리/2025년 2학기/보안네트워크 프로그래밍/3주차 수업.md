---
tags:
  - 수업_정리
  - Programming
title: TCP & IP 클라이언트_서버 소켓 프로그래밍 (1)
---
## 학습 주제
1. 기본 TCP 서버 & 클라이언트 모델
2. TCP Echo 서버 & 클라이언트 모델
3. 실습

---
## 연관 수업
[[4. Archive/국민대학교 수업 정리/2025년 2학기/보안네트워크 프로그래밍/2주차 수업]]

---
## 강의 요약
이번 시간에는 다음 시간과 함께 소켓 응용 프로그램을 작성하는 방법을 학습할 것이다. 
### 기본 TCP 서버 & 클라이언트 모델
기본 TCP 서버와 클라이언트는 다음 사진과 같이 동작한다. 
![[Pasted image 20251005012507.png]]
서버는 수동적으로 클라이언트의 접속을 기다리다 클라이언트가 통신을 요청하면 그때 응답하며, 클라이언트는 서버에게 통신을 요청하는 역할을 한다. 

이 때 사용되는 함수(파란색 글씨)는 10개도 안 되니, 아래의 요약을 보고 전부 외워두자. 

먼저, 통신이 있기 전에 클라이언트와 서버는 `socket` 함수를 사용하여 각각의 소켓을 생성하며, 소켓은 각 당사자가 통신을 하기 위한 통로의 역할을 한다. 
(더 자세한 정보는 [[4. Archive/국민대학교 수업 정리/2025년 2학기/보안네트워크 프로그래밍/2주차 수업#소켓의 기본 개념|소켓의 기본 개념]]을 참고해서 공부하자)
#### 공통: 소켓 생성 - socket()
```cpp
int socket(int domain, int type, int protocol)
```
이 함수의 역할은 네트워크 통신에 필요한 파일 디스크립터, 즉 소켓을 생성하는 것이다. 

- `domain`: 통신 영역, 즉 도메인을 결정하는 인자
	- `AF_INET`: IPv4
	- `AF_INET6`: IPv6
	- `AF_UNIX` 또는 `AF_LOCAL`: 로컬 (같은 커널 내)
- `type`: 소켓의 형태를 결정하는 인자
	- `SOCK_STREAM`: 연속되는 바이트 스트림으로, 연결형 통신 지원
	- `SOCK_DGRAM`: 데이터그램 단위로 전송하며, 비연결형 통신 지원
- `protocol`: 실제 사용하는 프로토콜
	- `IPPROTO_TCP`: TCP 프로토콜 사용
	- `IPPROTO_UDP`: UDP 프로토콜 사용

#### Client: 서버 연결 - connect()
```cpp
int connect(int socket, const struct sockaddr *addr, socklen_t addrlen)
```
이 함수의 역할은 연결을 기다리고 있는 서버에 연결을 요청하는 것이다. 

- `socket`: `socket()` 함수로 생성된 소켓 디스크립터
- `*addr`: 서버 주소 구조체의 포인터
	- `(struct sockaddr *)&(서버 주소)`: 구조체 안에 서버 주소의 정보 존재
	- 밑에서 더 자세하게 알아볼 것이다. 
- `addrlen`: 서버 주소 구조체 안의 길이
	- `sizeof()` 함수 호출을 통해 길이 획득 가능

#### Client: 서버 연결 - sockaddr 구조체
서버의 주소 정보에는 서버의 IP 주소, 포트 번호 등등이 있다. 만약 해당 정보들을 전부 하나하나씩 타이핑해야 한다면, 구현에서의 속도가 크게 느려질 것이다. 따라서, 프로그래밍의 편리함을 위해 구조체를 만들어서 사용한다. 

```cpp
struct sockaddr {
	u_short sa_family 
	char sa_data[14]; 
};
```

- `sa_family`: 주소 체계를 구분하기 위한 변수
	- `AF_INET`: IPv4로, `struct sockaddr_in` 구조체에 해당한다. 
	- `AF_INET6`: IPv6으로, `struct sockaddr_in6` 구조체에 해당한다. 
	- `AF_UNIX` 또는 `AF_LOCAL`: 로컬에 해당하며, `struct sockaddr_un`에 해당한다. 
- `sa_data`: 실제 주소 정보를 저장하는 변수

**이 중, 가장 많이 사용하는 `AF_INET`의 경우, 16 byte의 `struct sockaddr`을 `sockaddr_in` 구조체로 형변환하여 사용한다.**

```cpp
struct sockadddr_in { 
	short sin_family;           // 주소 체계로, 무조건 AF_INET으로 설정
	u_short sin_port;           // 16bit 포트 번호, network byte order
	struct in_addr sin_addr;    // 32bit IP 주소
	char sin_zero[8];           // 전체 크기를 16 byte로 맞추기 위한 더미 데이터
};

struct in_addr {
	u_long s_addr;              // 32bit IP 주소를 저장하기 위한 구조체
};
```

지금까지 정리한 것만을 바탕으로 서버에 연결하는 C 코드를 짜보자. 
```cpp
int sock;
struct sockaddr_in in; // IPv4를 이용할 것

// 소켓 생성, TCP 프로토콜 활용
if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
	DieWithSystemMessage("socket() failed"); }
	
// 메모리를 0으로 설정, 호스트 바이트 정렬을 네트워크 바이트 정렬로 변환
// 바이트 정렬 변환 이유는 뒤에 설명
memset(&in, 0, sizeof(struct sockaddr_in));
in.sin_family = AF_INET;
in.sin_port = htons(80);

// 사람이 알아볼 수 있는 IPv4, IPv6 주소를 Binary 형태로 변환
if (inet_pton(AF_INET, "127.0.0.1", &in.sin_addr) != 1) {
	DieWithSystemMessage("socket() failed"); }

// 서버에 연결 (강제 형변환 사용)
if (connect(sock, (struct sockaddr *)&in, sizeof(struct sockaddr_in)) != 0) {
	DieWithSystemMessage("connect() failed"); }
```

#### Client: 서버 연결 - 바이트 정렬 함수
바이트 정렬이란, 쉽게 말해 Big-Endian과 Little-Endian이다. 

이 둘은 가장 높은 곳부터 데이터를 저장할지, 가장 낮은 곳부터 데이터를 저장할지로 나뉘어진다.
예를 들어, 16진수 0x12345678을 0x1000번지에 저장할 때 아래 그림과 같이 차이가 나뉜다. 
![[Pasted image 20251005022826.png]]

그런데, 서버와 클라이언트의 운영체제가 꼭 같다는 보장이 없기 때문에, 이 두 통신 당사자 간 바이트의 정렬을 맞추어야 통신이 원활하게 이루어진다. 보통은 Big-Endian으로 맞춘다. 

이 때 어디에서 어디로 데이터를 넘겨주는가에 따라 `ntoh`함수와 `hton` 함수가 사용된다.
- `hton` 함수
	- 응용 프로그램이 `socket`함수에 데이터를 넘겨주기 전에 사용한다. 
	- 변환된 데이터를 `socket`함수가 사용한다. 
- `ntoh` 함수
	- `socket`함수가 결과로 반환한 데이터를 응용 프로그램이 사용한다. 
	- 변환된 데이터를 응용 프로그램이 사용한다. 

이를 그림으로 나타내면
![[Pasted image 20251005023337.png]]

#### Server: 포트 번호 할당 - bind()
```cpp
int bind(int socket, const struct sockaddr *addr, socklen_t addrlen)
```
이 함수는 서버의 IP 주소와 포트 번호를 소켓에 고정, 즉 포트 번호를 할당한다. 

- `socket`: 소켓 디스크립터
- `*addr`: 서버 주소 구조체의 포인터
	- Client에서 설명했던 것처럼, 서버 주소를 구조체를 만들어 관리한다. 
	- `(struct sockaddr *)&(서버 주소)`: 구조체 안의 서버 주소
- `addrlen`: 서버 주소 구조체의 길이
	- `sizeof()` 함수 호출로 길이를 얻을 수 있다. 

#### Server: 접속 대기 - listen()
```cpp
int listen(int socket, int queueLimit)
```
이 함수는 클라이언트의 연결 요청을 수동적으로 대기하는 데 필요하다. 

- `socket`: 소켓 디스크립터
- `queueLimit`: 대기 시 들어오는 연결 개수의 상한선 (정수형)
	- `connect` 요청에 동시에 응답할 수 있는 연결 개수의 상한선이다. 
	- 하나씩 `accept` 함수로 처리한다. 

#### Server: 클라이언트 연결 - accept()
```cpp
int accept(int socket, const struct sockaddr *addr, socklen_t addrlen)
```
이 함수는 클라이언트가 `connect` 함수로 보낸 연결 요청을 수락하고, 통신에 사용할 새 소켓을 생성하는 데 필요하다. 

- `socket`: 서버의 소켓 디스크립터
- `*addr`: 클라이언트의 주소 구조체의 포인터
	- 이 때 클라이언트의 주소를 받아오는 게 중요하다. 
	- `(struct sockaddr *)&(클라이언트 주소)`: 구조체 안의 클라이언트 주소
- `addrlen`: 클라이언트 주소 구조체의 길이
	- `sizeof()` 함수 호출로 구조체의 길이를 획득할 수 있다. 

#### 공통: 소켓 종료 - close()
```cpp
int close(int socket)
```
이 함수는 말 그대로 통신을 종료하기 위해 소켓을 닫을 때 소켓 디스크립터를 받아 사용한다. 

또한, 소켓을 열었을 때, 반드시 소켓을 닫아 줘야 한다. 이 점은 `calloc, malloc` 함수에서 사용하는 `free`함수와 비슷하다. 

### TCP Echo 서버 & 클라이언트 모델
Echo란 개념은 일종의 메아리 같은 개념으로,
TCP Echo 서버는 클라이언트가 보낸 데이터를 그대로 돌려주며, TCP Echo 클라이언트는 서버에 메시지를 보내고, 그 메시지가 잘 도착했는지 확인하기 위해 그 메시지를 돌려받는다. 

이를 그림과 약간의 글로 설명하면,![[Pasted image 20251005030036.png]]
그러면, TCP Echo에서 사용하는 추가적인 함수들에 대해서 알아보자. 이번에 소개할 두 개의 함수들은 TCP Echo 서버와 Echo 클라이언트에서 공통적으로 사용할 수 있다. 
#### 데이터 송신 - send()
```cpp
ssize_t send(int socket, const void *msg, size_t msgLength, int flags)
```
이 함수는 소켓을 통해 지정된 메시지를 네트워크로 전송한다. 

- `socket`: 데이터를 보낼 소켓의 디스크립터
- `*msg`: 소켓으로 보낼 메시지가 담겨 있는 **버퍼의 포인터**
	- `const`를 사용한 이유는 어차피 읽기 위한 값이지 수정하기 위한 값이 아니기 때문이다.
- `msgLength`: 보낼 메시지의 길이
	- `strlen(메시지)` 또는 `sizeof(메시지) - 1`로 얻을 수 있다. 
- `flags`: 송신 동작 제어 옵션
	- 일반적으로 0 사용

 >`const`를 사용하면 함수가 해당 매개변수의 값을 변경하지 않을 것이라는 것을 컴파일러에 알려주기 때문에, 값 복사 대신 참조(&)를 사용하거나 불필요한 객체 복사를 피하게 되어 성능적인 면에서 이점을 얻을 수 있다.

#### 데이터 수신 - recv()
```cpp
ssize_t recv(int socket, void *rcvBuffer, size_t bufferLength, int flags)
```
이 함수는 소켓으로 들어온 메시지를 읽어 `rcvBuffer` 버퍼에 복사한다. 

- `socket`: 데이터를 받을 소켓의 디스크립터
- `*rcvBuffer`: 수신한 데이터를 저장할 버퍼의 포인터
- `bufferLength`: 수신할 데이터를 저장할 버퍼의 길이
- `flags`: 수신 동작 제어 옵션
	- 일반적으로 0 사용

### 실습
먼저, 기본 TCP 서버 및 클라이언트에 대해 프로그래밍 해 보자. 
#### TCPClient.c
```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "Practical.h"


int main(int argc, char *argv[]) {
  if (argc < 3 || argc > 4) // 명령어 인자의 정확한 개수 확인
    DieWithUserMessage("Parameter(s)",
        "<Server Address> [<Server Port>]");

  // 서버 IP 설정, 포트 지정 > 없으면 기본 7로 고정
  char *servIP = argv[1];     
  in_port_t servPort = (argc == 3) ? atoi(argv[2]) : 7;

  // TCP 소켓 생성
  int sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
  if (sock < 0)
    DieWithSystemMessage("socket() failed");


  // 서버 주소 구조체인 sockaddr_in (IPv4) 생성
  struct sockaddr_in servAddr;            // Server address
  memset(&servAddr, 0, sizeof(servAddr)); // Zero out structure
  servAddr.sin_family = AF_INET;          // IPv4 address family

  // 문자열 IP를 네트워크 주소로 Binary로 변환
  int rtnVal = inet_pton(AF_INET, servIP, &servAddr.sin_addr.s_addr);
  if (rtnVal == 0)
    DieWithUserMessage("inet_pton() failed", "invalid address string");
  else if (rtnVal < 0)
    DieWithSystemMessage("inet_pton() failed");
    
  servAddr.sin_port = htons(servPort);    // Server port


  // 서버 연결 요청
  if (connect(sock, (struct sockaddr *) &servAddr, sizeof(servAddr)) < 0)
    DieWithSystemMessage("connect() failed");


  printf("Connected to Server: ");
  PrintSocketAddress((struct sockaddr*)&servAddr, stdout);
  close(sock);
}
```
#### TCPServer.c
```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "Practical.h"
  

static const int MAXPENDING = 5; // 연결 요청을 대기할 수 있는 최대 수


int main(int argc, char *argv[]) {
  if (argc != 2) // 명령어 인자의 개수 확인
    DieWithUserMessage("Parameter(s)", "<Server Port>");

  in_port_t servPort = atoi(argv[1]); // 첫 번째 인자: 지역 포트

  // TCP 소켓 생성, 연결 요청 처리 준비
  int servSock; // 서버 소켓 식별자 선언
  if ((servSock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
    DieWithSystemMessage("socket() failed");

  // 지역 주소 구조체 생성
  struct sockaddr_in servAddr;                  // 지역 주소
  memset(&servAddr, 0, sizeof(servAddr));       // 0으로 초기화
  servAddr.sin_family = AF_INET;                // IPv4 주소 패밀리 명시
  servAddr.sin_addr.s_addr = htonl(INADDR_ANY); // 호스트의 어떤 IP로도 수락
  servAddr.sin_port = htons(servPort);          // 지역 포트

  // 지역 주소에 바인트
  if (bind(servSock, (struct sockaddr*) &servAddr, sizeof(servAddr)) < 0)
    DieWithSystemMessage("bind() failed");

  // 소켓이 들어오는 요청을 처리할 수 있도록 설정
  if (listen(servSock, MAXPENDING) < 0)
    DieWithSystemMessage("listen() failed");

  struct sockaddr_in clntAddr; // 클라이언트 주소 구조체체
  socklen_t clntAddrLen = sizeof(clntAddr); // 클라이언트 주소 구조체의 크기
  
  // 클라이언트의 연결을 기다리고, 연결이 오면 accept
  int clntSock = accept(servSock, (struct sockaddr *) &clntAddr, &clntAddrLen);
  if (clntSock < 0)
      DieWithSystemMessage("accept() failed");

  printf("Connected to Client: ");
  PrintSocketAddress((struct sockaddr*)&clntAddr, stdout);

  close(clntSock);
  close(servSock);
}
```
이 두 코드를 컴파일해서 실행해 보면, 다음과 같이 정상적으로 실행된다 (교재 사진)
![[Pasted image 20251005035109.png]]


그 다음은 TCP Echo 서버 및 클라이언트에 대해 프로그래밍 해 보자. 
#### TCPEchoClient.c
```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "Practical.h"

int main(int argc, char *argv[]) {
  if (argc < 3 || argc > 4) // 명령어 인자의 정확한 개수 확인
    DieWithUserMessage("Parameter(s)",
        "<Server Address> <Echo Word> [<Server Port>]");
        
  char *servIP = argv[1];     // 첫 번째 인자: 서버 IP 주소 (dotted 형식)
  char *echoString = argv[2]; // 두 번째 인자: 보내려는 EchoString

  // 세 번째 인자(선택): 서버 포트(숫자 형식), 생략 시 기본 값으로 7 사용
  in_port_t servPort = (argc == 4) ? atoi(argv[3]) : 7;

  // TCP를 사용하여 안정된 스트림 소켓 생성
  int sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
  if (sock < 0)
    DieWithSystemMessage("socket() failed");

  // 서버 주소 구조체 생성
  struct sockaddr_in servAddr;            // 서버 주소
  memset(&servAddr, 0, sizeof(servAddr)); // 0으로 구조체 초기화
  servAddr.sin_family = AF_INET;          // IPv4 주소 패밀리

  // 주소 변환
  int rtnVal = inet_pton(AF_INET, servIP, &servAddr.sin_addr.s_addr);
  if (rtnVal == 0)
    DieWithUserMessage("inet_pton() failed", "invalid address string");
  else if (rtnVal < 0)
    DieWithSystemMessage("inet_pton() failed");
  servAddr.sin_port = htons(servPort);    // 서버 포트

  // Echo 서버에 연결 요청
  if (connect(sock, (struct sockaddr *) &servAddr, sizeof(servAddr)) < 0)
    DieWithSystemMessage("connect() failed");

  size_t echoStringLen = strlen(echoString); // Echo 문자열 길이 확인
  
  // 서버에 Echo 문자열 전송
  ssize_t numBytes = send(sock, echoString, echoStringLen, 0);
  if (numBytes < 0)
    DieWithSystemMessage("send() failed");
  else if (numBytes != echoStringLen)
    DieWithUserMessage("send()", "sent unexpected number of bytes");

  // 서버로부터 동일한 Echo 문자열 수신
  unsigned int totalBytesRcvd = 0; // 수신한 문자열의 문자의 개수
  fputs("Received: ", stdout);     // 돌려받은 Echo 문자열 출력 설정
  while (totalBytesRcvd < echoStringLen) {
    char buffer[BUFSIZE]; // I/O buffer

    /* 버퍼 크기(byte) 만큼 서버로부터 수신 (널 문자를 위해 1byte 남김)*/
    numBytes = recv(sock, buffer, BUFSIZE - 1, 0);
    if (numBytes < 0)
      DieWithSystemMessage("recv() failed");
    else if (numBytes == 0)
      DieWithUserMessage("recv()", "connection closed prematurely");
      
    totalBytesRcvd += numBytes; // 총 받은 크기 기록
    buffer[numBytes] = '\0';    // 널 문자를 끝에 추가해서 문자열 완성
    fputs(buffer, stdout);      // Echo 문자열 버퍼 내용물 출력
  }

  fputc('\n', stdout); // 마지막으로 개행문자 출력

  close(sock);
  exit(0);
}
```

#### TCPEchoServer.c
```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "Practical.h"
  
static const int MAXPENDING = 5; // 연결 요청을 대기할 수 있는 최대 수

int main(int argc, char *argv[]) {
  if (argc != 2) // 명령어 인자의 개수 확인
    DieWithUserMessage("Parameter(s)", "<Server Port>");

  in_port_t servPort = atoi(argv[1]); // 첫 번째 인자: 지역 포트

  // 연결 요청을 처리할 소켓 생성
  int servSock; // 서버 소켓 식별자(디스크립터)
  if ((servSock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
    DieWithSystemMessage("socket() failed");

  // 지역 주소 구조체 생성
  struct sockaddr_in servAddr;                  // 지역 주소
  memset(&servAddr, 0, sizeof(servAddr));       // 0으로 초기화
  servAddr.sin_family = AF_INET;                // IPv4 주소 패밀리
  servAddr.sin_addr.s_addr = htonl(INADDR_ANY); // 호스트의 어떤 IP로도 수락
  servAddr.sin_port = htons(servPort);          // 지역 포트

  // 지역 주소에 바인드
  if (bind(servSock, (struct sockaddr*) &servAddr, sizeof(servAddr)) < 0)
    DieWithSystemMessage("bind() failed");

  // 소켓이 들어오는 요청을 처리할 수 있도록 설정 (접속 대기)
  if (listen(servSock, MAXPENDING) < 0)
    DieWithSystemMessage("listen() failed");

  for (;;) { // 무한 반복
    struct sockaddr_in clntAddr; // 클라이언트의 주소를 담고 있는 구조체
    socklen_t clntAddrLen = sizeof(clntAddr); // 클라이언트 주소 구조체 크기 설정

    // 클라이언트의 연결을 대기하다 연결 요청이 들어오면 accept
    int clntSock = accept(servSock, (struct sockaddr *) &clntAddr, &clntAddrLen);
    if (clntSock < 0)
      DieWithSystemMessage("accept() failed");

    // clntSock가 클라이언트와 연결됨!
    char clntName[INET_ADDRSTRLEN]; // 클라이언트 주소를 담기 위한 문자열
    if (inet_ntop(AF_INET, &clntAddr.sin_addr.s_addr, clntName,
        sizeof(clntName)) != NULL)
      printf("Handling client %s/%d\n", clntName, ntohs(clntAddr.sin_port));
    else
      puts("Unable to get client address");
      
	// 연결된 클라이언트와 데이터 송수신 처리 (Echo 서버 역할)
    HandleTCPClient(clntSock);
  }
  // 실행되지 않음
}
```
이 두 코드를 컴파일해서 실행해 보면, 다음과 같이 정상적으로 실행된다 (교재 사진)
![[Pasted image 20251005041108.png]]

---
## 중요한 단어
1. 기본 TCP Server
2. 기본 TCP Client
3. TCP Echo Server
4. TCP Echo Client
5. sockaddr 구조체
6. 소켓 디스크립터