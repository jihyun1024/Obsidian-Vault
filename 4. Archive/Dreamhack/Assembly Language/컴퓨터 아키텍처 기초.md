- [[#소프트웨어 레지스터|소프트웨어 레지스터]]
	- [[#소프트웨어 레지스터#범용 레지스터|범용 레지스터]]
	- [[#소프트웨어 레지스터#명령어 레지스터|명령어 레지스터]]
	- [[#소프트웨어 레지스터#세그먼트 레지스터|세그먼트 레지스터]]
	- [[#소프트웨어 레지스터#플래그 레지스터|플래그 레지스터]]
	- [[#소프트웨어 레지스터#레지스터의 크기|레지스터의 크기]]
- [[#하드웨어 레지스터|하드웨어 레지스터]]
	- [[#하드웨어 레지스터#제어 레지스터|제어 레지스터]]
	- [[#하드웨어 레지스터#디버그 레지스터|디버그 레지스터]]
- [[#명령어 처리 절차|명령어 처리 절차]]
- [[#컴퓨터의 주소 처리 방식|컴퓨터의 주소 처리 방식]]


CPU(Central Processing Unit): 소프트웨어 명령의 실행이 이루어지는 컴퓨터의 장치로, 기계어로 된 명령어를 해석하여 실행

CPU의 기능을 수행하기 위해 필요한 것
1. 레지스터(register)
2. 산술논리연산장치(ALU, Arithmetic Logic Unit)
3. 제어부(control unit)와 내부 버스

→ 프로그램이 실행되면 프로그램이 메모리에 적재, 메모리의 내용을 CPU로 가져와 레지스터에 저장한 후 제어부를 통해 ALU에 전달되어 ALU에서 산술 연산 수행

# 레지스터
CPU 내에는 CPU 연산에서 사용하는 자료를 보관하는 작고 빠른 메모리가 존재하며, 이를 레지스터라 하고 고속 연산과 컴퓨터 프로그램 제어를 위해 사용함
⇒ 주기억장치 → 레지스터 → 데이터 처리 → 주기억장치

<aside> 💡

레지스터는 CPU와 운영체제에 따라 크기와 종류가 다양하기 때문에 여기서는 인텔 CPU 기반 레지스터를 주로 설명한다.

</aside>

## 소프트웨어 레지스터

### 범용 레지스터
* AX(Accumulator Register): 산술 연산에 사용되는 레지스터
* BX(Base Register): 데이터의 포인터로 사용되는 레지스터
* CX(Counter Register): 이동 연산, 루프에서 카운터로 사용되는 레지스터
* DX(Data Register): 산술, 입출력 연산에서 사용되는 레지스터
* SP(Stack Pointer Register): 스택의 최상위 포인터
* BP(Base Pointer Register): 스택의 기준 포인터
* SI(Source Index Register): 메모리 스트림 연산에서 소스 포인터
* DI(Destination Index Register): 메모리 스트림 연산에서 목적지 포인터

### 명령어 레지스터
IP(Instruction Pointer register) = PC(Program Counter)라고도 하며 명령어 주소를 계산하는 데 사용
⇒ 프로그램 코드에서 다음에 실행해야 할 명령어의 위치를 저장

### 세그먼트 레지스터
각 [[세그먼트]]의 위치를 나타내며, 이를 물리 주소로 변환할 때 사용
세그먼트: 코드(text) + 데이터(data) + 스택(stack) + 라이브러리 세그먼트

* SS(Stack Segment): 스택 세그먼트의 시작 주소
* CS(Code Segment): 코드 세그먼트의 시작 주소
* DS(Data Segment): 데이터 세그먼트의 시작 주소
* ES(Extra Segment): 추가 세그먼트의 시작 주소로, 데이터 전송 시 데이터의 시작 주소를 저장
* FS(F Segment): ES에 이어져 추가 세그먼트를 가리키는 주소, TEB(Thread Environment Block)의 주소를 지정하는 데 사용
* GS(G Segment): ES, FS에 이어져 추가 세그먼트를 가리키는 주소

### 플래그 레지스터

프로그램이 실행되는 순간마다 프로그램의 수행 상태를 비트 단위로 저장
ex) 연산 결과에서 캐리가 발생하였는지, 짝수인지, 음수인지
또한, 디버깅 관련 플래그도 존재 → 이를 바탕으로 jmp 명령어에서는 분기 조건이 갈림

* CF(Carry Flag): 마지막 산술 연산이 레지스터의 크기를 초과해 비트를 빌리거나 올림이 발생한 경우
* PF(Parity Flag): 최하위 비트가 0인 경우 = 2의 배수인 경우
* AF(Adjust Flag): 산술연산에서 BCD 숫자의 캐리가 발생한 경우
* ZF(Zero Flag): 연산 결과가 0인 경우
* SF(Sign Flag): 연산 결과가 음수인 경우
* TF(Trap Flag): 디버거가 중단점을 설정한 경우 설정하며, 한 번에 하나의 연산만 실행
* IF(Interruption Flag): 인터럽트가 사용 가능한 경우
* DF(Direction Flag): DF를 설정한 경우, 스트림 문자열 연산에서 역순으로 읽음
* OF(Overflow Flag): 부호 있는 산술 연산의 결과가 오버플로우 되어 레지스터가 표현 불가능한 경우

### 레지스터의 크기
- 64비트 CPU의 경우 → 16비트 레지스터 이름 앞에 “R”문자
- 32비트 CPU의 경우 → 16비트 레지스터 이름 앞에 “E” 문자
![[Pasted image 20250718204043.png]]
## 하드웨어 레지스터

프로세스를 제어하기 위한 레지스터인 제어 레지스터와 디버깅 모드에서 사용되는 레지스터인 디버그 레지스터로 구분됨
### 제어 레지스터
* CR0(paging): PE(보호/리얼모드)와 PG(no paging/paging)을 제어
* CR2(PFLS, Page Fault Linear Address): 페이징 오류 주소 저장
* CR3: 페이지 데이터의 베이스 주소로, PG가 1일 때 선형 주소를 물리 주소로 바꿀 때 사용
* CR4: 보호 모드에서 8086 가상화 운영
* CR8: 64비트 모드에서 사용

### 디버그 레지스터
* DR0 ~ DR3: 4개의 중단점(break point)의 주소
* DR6(Debug Status Register): 디버그 상태를 발생, 디버그 예외 처리를 보호하고 있을 때 예외 처리 핸들러를 실행하기 전에 활성화, 반환하기 전에 0으로 설정
* DR7(Debug Control Register): 중단점의 상태를 선택적으로 활성화

---

# 컴퓨터 명령어 코드

명령어: 명령어 코드(Operation Code, ex: mov) + 오퍼랜드(Operand, ex: eax)

⇒ 이를 통해 CPU가 실행할 연산을 지정, 명령어의 종류, 명령어의 구성 등의 정보를 알 수 있음

|오퍼랜드|예|설명|
|---|---|---|
|레지스터|eax|읽고 쓰기 위해 사용하는 레지스터|
|값|0x1024|코드 안에 삽입된 직접적인 값(상수)|
|메모리 주소|[0x080f349e]|해당 메모리 주소 안에 저장된 값|

## 명령어 처리 절차

1. 명령어의 주소를 계산하는 데 사용하는 EIP 주소에 접근하여 Op-code 부분 1바이트를 가져옴
2. Op-code를 해석, Op-code 명령어 길이만큼 EIP의 주소 변경
3. Operand 부분 읽어옴
4. Op-code에 따라 해당 명령어 실행
5. 실행 결과를 Operand에 해당하는 레지스터에 저장
6. 다음 EIP 주소에 접근, 위의 과정을 반복
![[Pasted image 20250718204109.png]]
## 컴퓨터의 주소 처리 방식

- 직접 주소(Direct Address): 기억장소 주소를 직접 지정
- 간접 주소(Indirect Address): 피연산자가 있는 주소를 지정
![[Pasted image 20250718204121.png]]