프로세스가 실행될 때 각 프로세스는 독립된 메모리 공간을 할당받는다. 이 메모리 공간은 용도에 따라 여러 영역으로 나뉘며, 각 영역은 특정한 목적을 가지고 동작한다. 
이렇게 메모리 영역을 나눠서 관리하면 각 영역을 용도에 맞게 권한을 부여할 수 있다는 장점이 있다. 그 때 부여할 수 있는 권한은 읽기(r), 쓰기(w), 실행(x) 세 가지가 존재하며, CPU는 해당 영역에 부여된 권한의 행위만 할 수 있다. 
리눅스에서는 프로세스의 메모리를 크게 5가지 세그먼트로 구분한다.
여기서 세그먼트란 적재되는 데이터의 용도별로 메모리의 구획을 나눈 것이며, 크게 코드 세그먼트, 데이터 세그먼트, BSS 세그먼트, 힙 세그먼트, 스택 세그먼트로 구분한다. ![[Pasted image 20250722131833.png]]
### 코드 세그먼트
실행 가능한 기계어 코드가 위치하는 영역으로, 텍스트 세그먼트라고도 한다. 
해당 영역은 실행할 수 있어야 하기 때문에 읽기 권한과 실행 권한이 주어지지만 쓰기 권한은 주어지지 않는데, 이는 쓰기 권한이 부여되면 취약점을 이용해 프로그램의 코드를 수정할 수 있어 해커가 악의적인 행위를 할 수 있기 때문이다. 
예를 들어, 아래 코드를 컴파일 한 뒤 메인 함수를 기계 코드로 변환하면 `554889e5488d05ac0e00004889c7b800000000e8ebfeffffb8000000005dc3`이 되는데, 해당 기계 코드가 코드 세그먼트에 올라가게 된다. 
```cpp
int main() {
	printf("Hello, World!");
	return 0;
}
```
어셈블리어 에서는 `section .text:`를 입력한 뒤 아랫줄에 어셈블리어 코드를 입력하여 컴파일 시 코드 세그먼트에 기계 코드가 자리잡히게 된다. 
아래 코드는 코드 세그먼트에 어셈블리어 코드를 작성해 "Hello, World!"를 출력하는 예시이다. 
```
section .data
    message db "Hello, World!", 0xA
    message_len equ $ - message

section .text
    global _start

_start:
    mov rax, 1
    mov rdi, 1
    mov rsi, message
    mov rdx, message_len
    syscall

    mov rax, 60
    xor rdi, rdi
    syscall
```
### 데이터 세그먼트
데이터 세그먼트에는 컴파일 시점에 값이 정해진 전역 변수 및 전역 상수들이 위치한다. CPU가 이 세그먼트의 데이터를 읽을 수 있어야 하기 때문에 읽기 권한이 부여된다. 
데이터 세그먼트는 쓰기가 가능한 세그먼트와 쓰기가 불가능한 세그먼트로 다시 나뉘게 되는데, 쓰기가 가능한 세그먼트는 전역 변수처럼 프로그램이 실행되면서 값이 변할 수 있는 데이터들이 위치한다. 이런 세그먼트는 `data 세그먼트`라고 한다. 
반면 쓰기가 불가능한 세그먼트에는 프로그램이 실행되면서 값이 변하면 안 되는 데이터(전역으로 선언된 상수 등)들이 위치한다. 이런 세그먼트를 `rodata(read-only data) 세그먼트`라고 한다. 
아래는 데이터 세그먼트에 포함되는 여러 문자열의 유형이다. 
```
int data_num = 31337;                       // data
char data_rwstr[] = "writable_data";        // data
const char data_rostr[] = "readonly_data";  // rodata
char *str_ptr = "readonly";  // str_ptr은 data, 문자열은 rodata

int main() { ... }
```
이 중 주의 깊게 살펴봐야 할 변수는 `str_ptr`이다. `str_ptr`은 `readonly`라는 문자열을 가리키고 있는데, 이 문자열은 상수 문자열로 취급되어 rodata에 위치하며, 이를 가리키는 `str_ptr`은 전역 변수로 data에 위치한다. 
### BSS 세그먼트
컴파일 시점에 값이 정해지지 않은 전역 변수가 위치하는 메모리 영역이다. 
여기에는 개발자가 선언만 하고 초기화하지 않은 전역변수 등이 포함되며, 이 세그먼트의 메모리 영역은 프로그램이 시작될 때 모두 0으로 값이 초기화된다. 
이런 특성 때문에 C언어로 코드를 작성할 때, 초기화되지 않은 전역 변수의 값은 0이 된다. 
이 세그먼트에는 읽기 권한 및 쓰기 권한이 부여된다. 
아래 C언어 코드에서는 초기화되지 않은 전역 변수인 `bss_data`가 BSS 세그먼트에 위치한다.  
```c
int bss_data;

int main() {
	printf("%d\n", bss_data);
	return 0;
}
```
### 스택 세그먼트
프로세스의 스택이 위치하는 영역으로, 함수의 매개변수나 지역 변수 등의 임시 변수들이 저장된다. 
해당 세그먼트는 NX(Non-Executable) 보호기법이 나오기 전까지는 실행 권한이 존재했지만, 쉘코드를 이용해 스택에 기계 코드를 넣어 해커가 해당 스택 영역을 호출하는 기법이 나오면서 컴파일 시 기본적으로 NX 보호기법을 활성화 시켜 실행 권한을 없앴기 때문에 해당 세그먼트에는 읽기 권한과 쓰기 권한이 주어진다. 
스택을 구성하는 단위는 스택 프레임이라고 한다. 스택 프레임은 함수가 호출될 때 전달된 매개변수나 함수가 끝나고 돌아가서 돌아갈 반환 주소, 그리고 지역 변수를 저장하고 있다. 
스택 프레임이 존재하는 이유는 각 함수가 실행을 마쳤을 때 해당 함수가 어느 함수로부터 호출 되었는지에 대한 정보와 함수의 정보를 저장하기 위해 이를 스택 프레임으로 관리하고 있다. 동시에, 스택 프레임을 만들어 함수들의 영역을 구분하는 역할도 한다. 
스택 프레임은 함수가 호출될 때 생성되고, 반환할 때 해제된다. 그런데 프로그램의 실행 흐름은 사용자의 입력이나 기타 다른 이유에 의해 영향을 받기 때문에 예를 들어 아래의 코드에서 사용자가 `choice`에 어떤 값을 입력하는지에 따라 `call_true()`가 호출될 수도 있고, `call_false()`가 호출될 수도 있다. 
```c
void func() {
  int choice = 0;

  scanf("%d", &choice);

  if (choice)
    call_true();
  else
    call_false();

  return 0;
}
```
따라서, 어떤 프로세스가 실행될 때 이 프로세스가 얼마 만큼의 스택 프레임을 사용하게 될 지를 미리 계산하는 것은 불가능하다. 그래서 운영체제는 프로세스를 시작할 때 작은 크기의 스택 세그먼트를 먼저 할당하고, 부족해 질 때마다 이를 확장하는 식으로 스택 프레임을 분배한다. 
스택에 대해 '아래로 자란다'라는 표현을 종종 사용하는데, 이는 스택이 확장되는 경우, 기존 주소보다 낮은 주소로 확장되기 때문이다. 
스택 영역에는 CPU가 자유롭게 값을 읽고 쓸 수 있어야 하므로 읽기 권한과 쓰기 권한이 부여된다. 
위의 코드에서는 지역 변수 `choice`가 스택에 저장된다. 
C언어나 Python 등의 고급 언어에서는 이런 스택 프레임을 직접 관리하지 않고 컴파일러에서 관리해 주지만, 어셈블리어에서는 함수를 호출하기 위해 직접 스택 프레임을 만들고, 함수가 끝나면 반환해야 한다. 
이를 함수 프롤로그와 함수 에필로그라고 한다. 
#### 함수 프롤로그
스택 프레임을 만드는 방법으로, 함수 시작 부분에 몇 줄의 코드가 존재하며, 해당 코드에서는 함수 내에서 사용할 스택과 레지스터를 준비하고, 아래의 코드는 x86 어셈블리어를 이용한 함수 프롤로그의 예시이다.
```
push ebp
mov ebp, esp
sub esp, 0x100
```
해당 코드를 분석하면 다음과 같다.
1. 현재 베이스 포인터(ebp)를 스택에 푸쉬하여 나중에 에필로그 과정에서 복구할 수 있도록 한다. 
2. 베이스 포인터를 현재 스택 포인터의 주소(esp)로 설정, 베이스 포인터가 스택의 상단을 가리키게 한다.
3. 현재 스택 포인터의 주소로부터 0x100만큼 감소시켜 함수의 지역변수, 인자를 위한 공간을 확보한다.
#### 함수 에필로그
함수를 종료할 때 스택 프레임을 정리하는 방법이다. 함수 끝 부분에 몇 줄의 코드가 존재하며, 함수 프롤로그와 반대로 함수가 호출되기 전 스택과 레지스터 상태로 복원한다. 
```
mov esp, ebp
pop ebp
ret
```
해당 코드를 분석하면 다음과 같다. 
1. 현재 베이스 포인터를 현재 스택의 포인터로 옮겨 현재 스택 포인터가 함수 프롤로그를 호출할 시점의 스택 포인터를 가리키게 한다. 
2. `push`했던 베이스 포인터를 다시 `pop`연산을 통해 스택에서 제거한다.
3. 함수를 호출하기 전으로 돌아간다. 
참고로, 해당 코드는 x86 프로세서에서 내장 명령어가 존재하며, 다음과 같이 프로그래밍해도 동일하게 동작한다. 
```
leave
ret
```
### 힙 세그먼트
힙 데이터가 위치하는 세그먼트로, 스택 세그먼트와 마찬가지로 실행 중에 동적으로 할당될 수 있으며, 리눅스에서는 스택 세그먼트와 반대 방향으로 자란다. 
C언어에서`malloc(), calloc()` 등을 호출해 할당받는 메모리가 이 세그먼트에 위치하게 되며, 일반적으로 읽기, 쓰기 권한이 부여된다. 어셈블리어에서 힙 세그먼트를 관리하고 싶다면 `sys_brk()` 또는 `mmap()`시스템 콜을 호출해 힙 세그먼트를 관리할 수 있다.
실제로, `malloc()`같은 함수는 내부적으로 해당 시스템 콜을 사용해 힙 세그먼트를 생성한다. 
아래 예제 코드는 `heap_data_ptr`에 `malloc()`으로 동적 할당한 영역의 주소를 대입하고, 이 영역에 값을 쓴다. `heap_data_ptr`은 지역변수이기 때문에 스택에 위치하며, `malloc()`으로 할당받은 힙 세그먼트의 **주소**를 가리킨다. 
```c
int main() {
	int *heap_data_ptr = malloc(sizeof(*heap_data_ptr));
	*heap_data_ptr = 31337;
	printf("%d\n", *heap_data_ptr);
	return 0;
}
```
참고로 힙과 스택이 자라는 방향이 반대인 이유는 만약 두 세그먼트가 동일한 방향으로 자라며 연속된 메모리 주소에 할당된다 가정할 경우, 기존의 힙 세그먼트를 모두 사용하고 나면 이를 확장하는 과정에서 스택 세그먼트와 충돌하게 된다. 
이를 해결하기 위해 리눅스는 스택을 메모리의 끝에 위치시키고, 힙과 스택을 반대로 자라게 해 메모리를 최대한 자유롭게 사용할 수 있으며, 충돌 문제로부터도 비교적 자유롭게 된다. 