---
tags:
---
# 참고 문서
[[리버스 엔지니어링]]
[[컴퓨터 아키텍처 기초 (레지스터)]]
[[Assembly]]

# 스택
- PUSH 명령과 POP 명령을 사용해 데이터를 저장하고 꺼내는 LIFO(Last In First Out) 데이터 구조를 가진 영역이다.
- 프로그램 실행 중 스택의 상태는 계속 변화함
- 스택의 Top 주소는 ESP에, Base 주소는 EBP 레지스터에 저장
- 함수의 인수, 로컬 변수, 리턴 주소(함수 실행이 끝나면 어디로 가야 할지) 등 저장
	- 참고: [[함수 프롤로그 & 에필로그]]

# 호출 규약
* 함수 호출 시 인수를 전달하는 방법과 반환값을 받는 방법을 정의
* 호출 규약에 따라 레지스터와 스택을 이용하는 방법이 다름
	* 리버스 엔지니어링 시 코드를 잘 분석하기 위해서 호출 규약 파악 필수
	* 아키텍처나 프로그램의 포맷, 컴파일러나 링커에 따라 변화

### cdecl
- x86의 [[C,C++]]에서 가장 일반적
- 함수의 인수를 역순으로 스택에 PUSH
- 반환값: EAX에 저장

### stdcall
- Windows API에서 사용되는 호출 규약
- 함수의 인수와 반환값은 cdecl과 동일하게 동작
- 함수가 종료될 때 해당 함수 자체가 스택을 PUSH

### fastcall
- 레지스터를 사용해 인수를 사용
	- 처음 2개의 인수: ECX, EDX 레지스터에 저장
	- 3개 이상의 인수: cdecl처럼 나머지를 역순으로 스택에 PUSH
- 인수 전달에 스택을 사용한 경우 stdcall처럼 함수가 종료될 때 해당 함수가 스택을 Free

### thiscall
- C++ 클래스의 멤버 함수로 이용되는 호출 규약
- 기본적으로는 cdecl과 동일
	- Windows에서는 cdecl처럼 동작
	- `this` 포인터(C++에서 모든 멤버 함수에 추가되는 매개변수)를 ECX 레지스터에 저장

# C 언어와 어셈블리 언어
- C 언어 소스코드와 그 실행 파일을 디스어셈블한 코드를 이용해 C 언어 코드의 동작 알아보기
- 알 수 없는 명령어의 경우, [인텔의 공식 매뉴얼](https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html#combined)이나 구글링으로 동작을 확인

### 함수 호출
[[Assembly]] 문서 참고
(너무 길어서 다른 문서로 링크 걸어놨음)

# PE 포맷
* Windows에서 이용하는 실행 파일 형식
* Malware의 대부분은 Windows 환경을 대상으로 하기 때문에 PE 포맷의 이해가 중요함
* 보다 자세한 강의 자료
	* https://github.com/corkami/pics/blob/master/binary/pe101/pe101.pdf
	* https://www.openrce.org/reference_library/files/reference/PE%20Format.pdf

## 헤더
* PE 포맷 헤더의 각 요소에서 중요한 항목을 설명
* 구조는 그림과 같음
	![[Pasted image 20250823002407.png]]
### DOS 헤더
* `IMAGE_DOS_HEADER` 구조체로 정의
	* `e_magic`: PE 형식 실행 파일의 매직 넘버(시그니처)인 `MZ (0x4D 0x5A)`를 가짐
	* `e_lfanew`: 마지막 멤버로, `0x3C`를 가지며 PE 헤더의 오프셋을 나타냄

### DOS Stub
- MS-DOS용 코드
	- 본래는 DOS 모드로 실행하면 발생하는 에러 코드
	- 리버스 엔지니어링에서는 매직 넘버와 함께 PE 포맷의 실행 파일인지 확인하는 요소
- "This program cannot be run in DOS mode"라는 문자열을 포함

### PE 헤더
- `IMAGE_NT_HEADER` 구조체로 정의
	- `PE (0x50 0x45 0x00 0x00)`이라는 값의 서명과 `IMAGE_FILE_HEADER`구조체의 FileHeader, `IMAGE_OPTIONAL_HEADER32` 구조체의 OptionalHeader로 구성
		- FileHeader 중 중요한 멤버: 
			- 섹션 수를 나타내는 Number Of Sections
			- 컴파일한 일시를 나타내는 Number Of Sections
		- OptionalHeader 중 중요한 멤버: 
			- 엔트리 포인트의 주소(RVA)를 나타내는 Address Of Entry Point
				- RVA: Relative Virtual Address의 약자
				- 실제 주소: RVA + ImageBase
			- 프로그램이 메모리에 로드되는 주소를 나타내는 ImageBase
				- exe일 경우, ImageBase의 값은 0x400000
				- dll일 경우, ImageBase의 값은 0x10000000
			- `IMAGE_DATA_DIRECTORY` 구조체의 배열인 Data Directory

### 섹션 테이블 (섹션 헤더)
* `IMAGE_SECTION_HEADER` 구조체로 정의
* 각 섹션의 이름과 주소 정보가 저장

## 섹션
| Section 이름 | 역할                                                   |
| ---------- | ---------------------------------------------------- |
| .text      | 실행 가능한 코드 보관                                         |
| .rdata     | 읽기 전용 데이터 보관                                         |
| .data      | 읽기/쓰기 전용 데이터 또는 글로벌 변수 보관                            |
| .idata     | import 함수 정보 보관, 이 섹션이 없다면 import 함수의 정보는 .rdata에 저장 |
| .edata     | export 함수 정보 보관, 이 섹션이 없다면 export 함수의 정보는 .rdata에 저장 |
| .bss       | 초기화되지 않은 데이터 보관                                      |
| .rsrc      | 아이콘, 다이얼로그 등 실행 파일에서 사용하는 자원 보관                      |
| .reloc     | 라이브러리의 재배치(RELOCation)에 대한 정보 보관                     |

## 라이브러리
* 파일 조작, 메모리 조작, 통신 등 대부분의 프로그램 동작에는 OS가 제공하는 라이브러리 이용
	* PE 포맷의 경우 Windows API가 라이브러리로 제공
* 라이브러리 실행 방법: 정적 링크와 동적 링크
	* 정적 링크: 라이브러리를 결합해 하나의 실행 파일을 생성
	* 동적 링크: DLL(Dynamic Link Library) 형식으로 다른 프로그램에 라이브러리 함수 제공

### 임포트 (import)
* 대부분의 프로그램 동작에는 Windows API가 필요
	* PE 포맷에서는 DLL이 내보내는 함수를 import할 수 있음
* Windows API를 이용하기 위해서 Windows가 제공하는 DLL이 내보내는 함수를 import해 호출
* PE 헤더의 import table에는 실행 파일이 import하는 함수의 정보가 저장
* 분석 대상 프로그램의 import 함수를 확인해 그 프로그램의 기능을 추측 가능

### 익스포트 (export)
- PE 포맷에서는 다른 프로그램에서 사용하는 함수를 내보낼 수 있음
	- PE 헤더의 export table에는 실행 파일이 export할 함수의 정보가 저장
- DLL은 exe에 함수를 제공하기 위한 형식
	- 따라서 DLL은 대부분 export 함수가 많음
	- 분석 대상이 DLL일 경우, 프로그램의 export 함수를 분석해 해당 프로그램의 기능을 추측 가능능

# x64 아키텍처
- 지금까지의 설명: x86 아키텍처 프로그램에 대한 리버스 엔지니어링
	- 아직 Malware는 32bit 프로그램이 대부분
	- 최근 운영체제는 64bit
		- 따라서 x64 아키텍처 프로그램을 분석할 기회도 많아짐
- 이번 장에서 설명할 내용: Windows와 Linux의 x64 아키텍처 프로그램 분석에 대한 지식

### 변화된 점
1. 모든 주소와 포인터가 64bit로
2. 레지스터의 추가
3. 64bit 명령어 추가
4. 함수 호출 규약에서의 x64 호출 규약의 추가 및 변경

### x64 레지스터
- 범용 레지스터의 64bit 확장과 r8 ~ r15 레지스터의 추가
- x86 아키텍처에서 존재하던 이름도 사용 가능

| 레지스터명    | 의미       | 주요 용도               |
| -------- | -------- | ------------------- |
| RAX      | 계산 레지스터  | 연산, 함수의 반환값         |
| RBX      | 베이스 레지스터 | 데이터에 대한 포인터         |
| RCX      | 카운트 레지스터 | 루프 처리 시 카운터         |
| RDX      | 데이터 레지스터 | 연산                  |
| RSP      | 스택 포인터   | 스택 Top의 포인터         |
| RBP      | 베이스 포인터  | 베이스 포인터로 사용하지 않음    |
| RSI      | 소스 인덱스   | String 조작 시 소스 포인터  |
| RDI      | 목적 인덱스   | String 조작 시 목적지 포인터 |
| r8 ~ r15 | -        | 인수 저장 등에 사용         |
### x64 호출 규약
* Windows
	* 첫 번째부터 네 번째 인수를 각각 RCX, RDX, r8, r9에 저장
	* 인수가 부동소수점인 경우: XMM0 ~ XMM3
	* 인수가 4개 이상: 스택을 이용해서 전달
		* 처음 4개 인수는 레지스터에 저장
		* 스택 위에 그 인수 전용 **홈 영역**이라는 예약 영역을 가짐
	* 반환값이 정수 또는 포인터: RAX 레지스터에 저장
	* 반환값이 부동소수점인 경우: XMM0에 저장
	* RBP 레지스터는 베이스 포인터로 사용하지 않음
	* 변수 등의 스택 참조: RSP 레지스터를 사용
	* 함수 프롤로그 처리 후 스택의 요소
		* 리턴 주소
		* 함수의 프롤로그에서 PUSH된 비휘발 레지스터 값
			* 비휘발 레지스터: RBX, RBP, RSP, r12 ~ r15
			* 값을 보관하여 함수 종료 시에 복원
		* 함수가 사용하는 로컬 변수, 스택을 경유해 받은 인수
		* 레지스터를 경유해 받은 인수의 홈 영역
	
* Linux 등 Unix 계열 운영체제
	* 첫 번째부터 여섯 번째 인수를 각각 RDI, RSI, RDX, RCX, r8, r9에 저장
	* 시스템 호출 시 r10 레지스터 사용
	* 인수가 6개 이상: 스택을 이용해서 전달
	* 인수가 부동소수점인 경우: XMM0 ~ XMM7
	* 반환값이 64bit 까지의 정수 또는 포인터: RAX 레지스터에 저장
		* 128bit일 경우 상위 64bit는 RDX에, 하위 64bit는 RAX 레지스터에 저장
		* 부동소수점의 경우도 마찬가지
			* 64bit까지는 XMM0 레지스터에 저장
			* 128bit까지는 XMM0와 XMM1 레지스터에 분할하여 저장
	- **Red Zone**: Windows에는 존재하지 않는 개념
		- 스택 포인터 아래에 배치되는 128byte 최적화를 위한 영역
		- 이 덕분에 128byte까지의 일시 데이터를 스택 포인터 변경 없지 스택에 배치 가능
	- 함수 프롤로그 처리 후 스택의 요소
		- 리턴 주소
		- 함수가 사용하는 로컬 변수
		- 스택을 경유하여 전달된 인수
		- **레드존**
	- 비휘발 레지스터: RBX, RBP, RDI, RSI, RSP, r12 ~ r15, XMM6 ~ XMM15