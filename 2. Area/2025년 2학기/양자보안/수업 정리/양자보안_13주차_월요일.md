---
tags:
  - 수업_정리
  - 암호학
title:
---
## 학습 주제
1. PQC: Lattice
2. PQC: Module Lattice

---
## 연관 수업
[[양자보안_9주차_월요일]]
[[양자보안_9주차_수요일]]
[[양자보안_10주차_월요일]]
[[양자보안_10주차_수요일]]
[[양자보안_11주차_월요일]]
[[양자보안_11주차_수요일]]
[[양자보안_12주차_월요일]]
[[양자보안_12주차_수요일]]

---
## 수업과 관련한 질문 3가지
1. Lattice에서 각각의 벡터를 다항식으로 표현 가능하다면, NTT에서는 고차원적인 연산이 2차원에서의 연산으로 다운그레이드되어 연산할 수 있어 속도가 빨라질 수 있는 것인지
2. MLWE에서 비밀로 해야 하는 정보와 그렇지 않은 정보는 각각 무엇인지
3. 격자 관련 문제에서 CVP와 SVP의 차이점이 무엇인지

---
## 강의 요약
### PQC: Lattice
PQC에서는 격자 기반이 가장 많이 사용되는 만큼, **Lattice**에 대해 다룰 것이다.
RSA나 ECC의 수학적인 무대가 되는 $Z_n$이나 타원곡선과는 달리, Lattice는 양자 컴퓨터로도 깨지지 않는 동네라고 할 수 있다. 그렇다면 왜 안 깨지는지 알아보도록 하자. 

선형대수학을 정상적으로 배웠다면, $v_1$과 $v_2$가 $R^2$ 공간 위의 두 기저(basis)라고 할 때, 그 두 가지의 기저를 실수배 해서 $R^2$ 공간 위의 모든 벡터를 나타낼 수 있다. 즉, Vector Space는 $<R^2,\ +,\ 스칼라곱,\ 원점\ 0,\ 기타\ 성질들>$로 이루어진 공간이라 할 수 있다. 

위의 설명이 Vector space였는데, Vector space와 많이 유사한 개념이 Lattice라고 말할 수 있다. 단, vector space 내부의 벡터는 기저를 **실수배**한 결과물이지만, lattice 내부의 격자점은 여러 벡터(또는 기저)를 **정수배**해서 저장한 결과물이라는 것이다. 즉, **Vector space에서는 Field를 쓰지만, Lattice에서는 그것보다 조금 더 널널하게 잡아 Ring을 사용한다는 것이다.**

이 사진을 보면서 이해하면 이해가 쉬울 것이다.
![[Pasted image 20251125022918.png]]
이 그림에서 $b_1, b_2$를 기저로 해서 기저에 정수배를 해서 만들어진 모든 격자점을 모은 것이 lattice라고 할 수 있다. (물론, 실제 양자내성암호의 구현에서는 아이디어만 이렇다는 것이다)

사실, 정수배를 해도 정수는 무한히 많기 때문에 컴퓨터에 이 모든 격자점들을 전부 저장하기 어렵다는 한계가 있다. 그래서 Ring을 사용해 정수의 역할을 대신하도록 한다. 

또 다른 포인트는 이 그림은 이해를 돕기 위해 2차원으로 표시했지만, 실제로는 여러 개의 벡터를 사용해 굉장히 높은 차원에서 연산이 이루어지도록 프로그래밍한다. 

### CVP (Closest Vector Problem)
이 때 PQC의 어려움의 기반이 되는 문제가 등장하는데, 2차원에서 특정 점을 주고 기저를 얼마나 정수배 해야 그 점이 나오는지는 알기 쉽지만, 고차원에서는 그 문제를 해결하는 것이 매우 어렵다는 것이다.

![[Pasted image 20251125024026.png]]
이는 RSA의 Factorization 문제나 ECC의 DLP, ECDLP 문제와 비슷한 맥락으로 이해할 수 있다

위의 사진에서는 매우 쉽게 찾을 수 있지만, 실제 PQC에서는 그 답을 구하는 과정이 모든 슈퍼컴퓨터를 동원해도 찾을 수 없을 정도로 매우 어렵다는 것을 CVP의 핵심 아이디어로 한다. 

### LWE (Learning With Errors)
**LWE (Learning With Errors)** 는 말 그대로 오류 또는 오차를 이용한 문제로, 비밀이 되는 값과 약간의 오류를 이용해 선형 방정식의 해를 구하는 것을 매우 어렵게 하는 문제이다. 

![[Pasted image 20251125024814.png]]
이 그림을 보면서 공부하면 조금 이해가 쉬울 수 있다. 

여기서 공개하는 값은 행렬 $A$와 결과값 $t$이며, 비밀로 하는 값은 자신의 개인키가 되는 $s$를 비밀로 한다. 행렬 $A$와 비밀값 $s$를 곱한 뒤, 거기에 오류값 $e$를 더해 추가적인 조치를 한다. 그렇게 함으로써, 알고리즘과 $A, t$를 공개했음에도 불구하고 $A, t$로부터 $s$를 구해 비밀을 알아내는 과정이 거의 불가능하게 할 수 있다. 

이는 작은 오차, 즉 $e$를 포함한 문제로 인해서 근사 해를 찾기 어렵기 때문에 LWE는 격자 문제인 SVP, CVP와 동일한 보안 강도를 가진다. 

### PQC: Module Lattice
CRYSTALS-KYBER의 정식 명칭인 ML-KEM은 Module-Lattice 기반 PQC이기 때문에, 우리는 Lattice뿐만이 아닌 **Module Lattice**까지 알아야 한다. 

Module Lattice는 Lattice와 비슷한 말이기는 한데, 조금 다르다고 할 수 있다. Module이 들어갔기 때문에, 우리가 배웠던 Modular 개념을 사용해 계수가 엄청나게 커지기 전에 미리 제한한다. 

### MLWE (Module-Learing With Errors) KeyGen / Enc / Dec
다음 그림을 보자. 이 그림을 그릴 줄 알고 자세히 설명할 수 있어야 한다. 
(이 그림에서 $Z_q/<x^n+1>$은 오타로, $Z_q[x]/<x^n+1>$로 고쳐야 한다)
![[Pasted image 20251125030219.png]]

**ML-KEM에서의 단계**는 크게 키 생성, 암호화, 복호화의 세 단계로 나누어진다. 

키 생성과 복호화는 같은 사람이 하며 암호화는 제 3자가 수행한다. 이 때, 제 3자는 정상적인 사용자가 될 수도 있지만, 반대로 공격자가 될 수도 있기 때문에 비밀키 $sk$는 Alice만이 가지게 된다.

실생활에 대입해서 예시를 들어 보면 Alice는 과제 공지를 하고 과제물을 받아 복호화를 하는 교수님이라 할 수 있고, Bob은 과제 공지를 받아 암호화를 해 전송하는 학생이라 이해하면 된다. 
이 때, 학생은 교수로부터 교수의 공개키만을 받아 과제 $M$을 암호화 해서 전송하며, $sk$를 가진 교수만이 해당 암호문을 복호화해 $M$을 가질 수 있다. 

또한, Module이라는 단어가 들어갔기 때문에 $A$의 계수는 $Z_q$로 통제를 받게 된다. 

사진에서의 Key와 ML-KEM에서 Encapsulation의 대상이 되는 Key는 같을까, 다를까? 정답은 '같지 않다'이다. Alice와 Bob과의 통신에서 최종적으로 공유되는 값은 $M$이며, 해당 값은 Alice와 Bob이 통신을 위해 나눠 가지게 되는 키가 된다. 

이 사진에서는 간단하게 나왔지만, 실제로는 엄청나게 많은 연산이 등장하며 여태까지 배웠던 NTT나 다항식 연산 등이 이 과정에서 사용된다.

Encryption 과정에서도 오류인 $e_1, e_2$가 사용된다는 것을 잊지 말도록 하자.

---
## 중요한 단어
1. Lattice
2. Difference between Lattice and Vector Space
3. CVP (Closest Vector Problem)
4. LWE (Learning With Errors)
5. Module Lattice
6. MLWE KeyGen / Enc / Dec