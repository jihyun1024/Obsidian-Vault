---
tags:
  - 수업_정리
---
## 학습 주제
1. 운영체제의 역할
2. 컴퓨터 시스템의 구성
3. 운영체제의 구분
4. 이중 모드와 시스템 호출
5. 운영체제의 구조
6. 운영체제의 기능

---
## 이전 수업
[[운영체제_1주차_목요일]]

---
## 강의 요약
아직은 Overview이기 때문에, 교양 강의 듣는 기분으로 이런 게 있다 정도만 알면 됨.
### 운영체제의 역할
컴퓨터 시스템은 다음 그림으로 심플하게 나타낼 수 있다. 
![[Pasted image 20250913204542.png]]
운영체제는 이 그림에서 시스템 SW에 속하며, 다음의 기능들을 수행한다. 

- User Interface (편리성)
	- CUI (Character User Interface)
	- GUI (Graphical User Interface)
	- EUCI (End-User Comfortable Interface)
- Resource Management (효율성)
	- HW resource (processor, memory, I/O devices, etc)
	- SW resource (file, application, message, signal, etc)
- Process and Thread Management 
- System Management (시스템 보호)

이 기능들 중 가장 중요한 기능은 두 번째의 Resource Management로, 운영체제는 컴퓨터 시스템의 자원 관리에 가장 중점을 두고 있다. 

### 컴퓨터 시스템의 구성
이것도 심플하게 사진 하나로 볼 수 있다. 
![[Pasted image 20250913205053.png]]

### 운영체제의 구분
운영체제는 여러 기준에 따라 어떤 시스템인지 갈리며, Single-User system이면서 동시에 Single-tasking system일 수 있다. 

1. 동시 사용자 수
	- [[운영체제_2주차_화요일#Single-user system|Single-user system]]
	- [[운영체제_2주차_화요일#Multi-user system|Multi-user system]]
2. 동시 실행 프로세스 수
	- [[운영체제_2주차_화요일#Single-tasking system|Single-tasking system]]
	- [[운영체제_2주차_화요일#Multi-tasking system|Multi-tasking system (a.k.a Multiprogramming system)]]
3. 작업 수행 방식 (사용자가 느끼는 작업 환경)
	- [[운영체제_2주차_화요일#Batch processing system|Batch processing system]]
	- [[운영체제_2주차_화요일#Time-sharing system|Time-sharing system]]
	- [[운영체제_2주차_화요일#Distributed processing system|Distributed processing system]]
	- [[운영체제_2주차_화요일#Real-time system|Real-time system]]

#### Single-user system
한 명의 사용자만 시스템 사용이 가능한 우리가 흔히 아는 시스템으로, 한 명의 사용자가 모든 시스템 자원을 독점해 자원의 관리나 시스템 보호 방식이 간단하다. 
이 시스템은 개인용 장비(PC, Mobile)에 많이 사용된다. 

#### Multi-user system
동시에 여러 사용자들이 시스템 사용이 가능한 시스템으로, 각종 시스템 자원(파일 등)들에 대한 각각의 소유 권한에 대해 관리가 필요하며, 여러 사용자들이 하나의 PC를 사용하는 과정에서는 당연하게도 사용자들은 각각 다른 작업을 하기 때문에 기본적으로 Multi-tasking 기능이 필요하다. 
따라서 OS의 기능과 구조가 복잡하다. 
이 시스템은 여러 사용자들이 모이는 서버, 클러스터 등에 사용되며, Unix, Linux, Windows Server 등의 운영체제가 있다. 

#### Single-tasking system
시스템 내에 하나의 작업(프로세스)만 존재하는 시스템으로, 하나의 프로그램 실행을 마친 뒤에야 다른 프로그램이 실행될 수 있다. 
이 시스템은 운영체제의 구조가 간단해 MS-DOS 등 옛날 컴퓨터의 운영체제에 많이 사용되었다.

#### Multi-tasking system
동시에 여러 작업이 가능하며, 이를 위해 작업들 사이의 동시 수행, 동기화 등을 관리해야 한다. 따라서 운영체제의 구조와 기능이 복잡해 Unix/Linux, Windows 등 현대 컴퓨터에 많이 사용된다.

#### Batch processing system
1950년 ~ 1960년대까지 주로 사용된 시스템으로, 모든 시스템을 중앙에서 관리 및 운영하고, 사용자의 요청을 일정 시간 모아 두었다가 한 번에 처리하는 시스템이다. (시스템 지향적)
이 때의 유물로 천공카드가 있다. 
![[Pasted image 20250913212505.png]]
- 장점: 많은 사용자가 시스템 자원 공유, 처리 효율 향상
- 단점: 같은 유형의 작업이 모이기를 기다려야 해 생산성 저하 + 긴 응답시간

#### Time-sharing system
1960년 ~ 1970년대까지 주로 사용된 시스템으로, 여러 사용자가 자원을 동시에 사용하고 OS가 파일 시스템과 가상 메모리를 관리한다. 
또한 프로그램 A, B, C, D가 있다면 해당 프로그램들을 조금씩 나눠서 여러 번 실행하였다. 
이는 사용자 지향적인 시스템으로, 단말기를 컴퓨터에 여러 대 연결해 하나만 관리하면 되었다. 
![[Pasted image 20250913212647.png]]
- 장점: 응답에 걸리는 시간 단축, 프로세서 유휴 시간 감소로 인한 생산성 향상
- 단점: 통신 설비 비용, 보안 문제 등으로 인한 통신 비용 증가, 개인 사용자 체감 속도 저하 (동시 사용자 수가 늘어날수록 시스템 부하가 크고, 그에 따라 느려짐)

#### Distributed processing system
네트워크를 기반으로 구축된 병렬처리 시스템으로, 물리적으로는 분산되어 있지만 통신망을 이용해 상호 연결되어 있는 시스템이다. 
해당 시스템에 연결되어 있는 기기들은 각각 운영체제를 탑재한 다수의 범용 시스템들이며, 사용자는 이 분산운영체제를 통해 각 구성 요소들 간의 독립성을 유지한 채 공동작업이 가능하다. 
이 시스템은 현재 Cluster system, client-server system, P2P 등에 사용되고 있다. 
![[Pasted image 20250913213325.png]]
- 장점: 자원 공유를 통한 높은 성능, 고신뢰성, 높은 확장성
- 단점: 구축과 관리가 어려움

#### Real-time system
이 시스템은 제한 시간 내에 서비스를 제공하는 것이 효율성보다 더 중요한 시스템, 예를 들어 원자력 발전소나 동영상 실시간 전송 시스템, 무기 관리 시스템 등에 사용된다. 

작업의 종류는 세 가지로 나누어진다. 
- Hard real-time task
	- 시간 제약을 지키지 못하는 경우 시스템에 치명적인 영향
	- 예: 발전소 제어, 무기 제어 등
- Soft real-time task
	- 동영상 재생 등
- Non real-time task

### 이중 모드와 시스템 호출
프로그램을 실행할 때, 개별 프로세스가 자원에 직접적으로 접근하는 방식은 프로세스들과의 충돌 등 많은 위험성을 가지고 있어 운영체제는 응용 프로그램들이 자원에 접근하려 할 때 오직 운영체제 자신을 통해서만 접근하도록 해서 자원을 보호하며, 이러한 것은 **이중 모드**로 구현한다.![[Pasted image 20250913222547.png]]

이중 모드란 CPU가 명령어를 실행하는 모드를 크게 **사용자 모드**와 **커널 모드**로 구분하는 방식으로, 각각은 다음과 같다. 
![[Pasted image 20250913222900.png]]
- 사용자 모드
	- 운영체제 서비스를 제공받을 수 없는 운영 모드
	- 커널 영역의 코드를 실행할 수 없음
	- 자원 접근 불가
- 커널 모드
	- 운영체제의 서비스를 제공받을 수 있는 운영 모드
	- 자원 접근을 비롯한 모든 명령어 실행 가능

이 때 사용자가 사용자 모드에서 실행한 명령을 커널 모드로 전환해서 실행하기 위해 **시스템 호출**을 사용하며, 이는 일종의 소프트웨어 인터럽트이다. 
![[Pasted image 20250913223125.png]]

### 운영체제의 구조
위에서 커널에 대해 언급했는데, 커널이란 OS의 핵심 부분으로, 항상 메모리에 상주하며 시스템 관리 등 가장 빈번하게 사용되는 기능들을 담당한다. 
![[Pasted image 20250913223408.png]]
커널은 단일 커널과 계층 커널, 마이크로커널, 하이브리드 커널로 분류할 수 있다. 

- 단일 커널
	- 하나의 커널 내에 여려 기능들을 동시에 때려박은 것
	- ![[Pasted image 20250913223913.png]]
	- 장점
		- 커널 내의 모듈(기능)간 직접 통신
		- 효율적인 자원 관리 및 사용 가능
	- 단점
		- 커널의 거대화로 인해 오류, 버그, 추가 기능 구현 등 유지보수의 어려움이 따름
		- 동일 메모리에 모든 기능이 있어 모듈 하나의 문제가 전체 시스템에 영향을 줌 (악성 코드 등)
- 계층 커널
	- 하나의 커널 내에서 모듈들을 계층화시킨 것
	- ![[Pasted image 20250913223925.png|500x400]]
	- 장점
		- 모듈화로 인해 계층간 검증 및 수정이 쉬움
		- 설계와 구현이 간단함
	- 단점
		- 원하는 기능 수행을 위해 여러 계층을 거쳐야 해 단일 커널 대비 성능 저하가 있음
		- 특정 상황에서만 사용됨
- 마이크로커널
	- 커널에 담을 기능들을 최소한의 필수 기능만 넣어 놓은 것
	- 기타 기능들은 사용자 영역에서 수행
	- ![[Pasted image 20250913224104.png]]
- 하이브리드 커널
	- 마이크로커널에 단일 커널의 장점을 혼합해 만든 설계
		- 핵심 OS 서비스를 커널에 포함
		- 커널과 사용자 영역 사이의 Communication을 최소화
		- 일부 드라이버, 보조 서비스 등은 사용자 영역에서 독립적으로 실행
	- ![[Pasted image 20250913224222.png]]

### 운영체제의 기능
운영체제는 다음의 6가지 기능을 수행한다. 

1. 프로세스 관리
	- OS의 프로세스 관리 기능: 생성/삭제, 상태관리, 자원 할당, 프로세스 간 통신 및 동기화, 교착상태 해결
	- 프로세스 정보 관리: PCB (Process Control Block)
2. 프로세서 관리
	- 프로세스 스케줄링: 시스템 내의 프로세스 처리 순서를 결정하는 작업
	- 프로세서 할당 관리: 프로세스들에 대한 프로세서 할당 과정으로, 한 번에 하나의 프로세스만 프로세서에서 처리 가능하기 때문에 있는 과정이다. 
3. 메모리 관리
	- Multi-user, Multi-tasking system에서 필요한 것
		- 프로세스에 대한 메모리 할당, 회수
		- 메모리 여유 공간 관리
		- 각 프로세스에 할당된 메모리 영역에 대한 접근 보호
	- 메모리 할당 방법
		- 전체 적재: 구현이 간단하나, 메모리 공간이 제한적이라는 단점 존재
		- 일부 적재: 프로그램이나 데이터의 일부만 적재하는 방법으로, 메모리를 효율적으로 활용할 수 있지만 보조 기억 장치에 접근해야 한다는 불편함이 있다. 
4. 파일 관리
	- 파일: 데이터의 논리적 저장 단위
	- 대표적인 파일 관리 기능
		- 파일 및 디렉터리 생성/삭제
		- 파일 접근/조작
		- 파일을 물리적인 저장 공간으로 mapping
		- 파일 백업
5. 입출력 관리
	- 입출력 관리 또한 커널에서의 이중모드와 비슷하게 OS를 반드시 거쳐가야 한다. 
	- ![[Pasted image 20250913225625.png]]
6. 보조 기억 장치 및 기타 장치 관리 등

---
## 중요한 단어
1. Kernel과 Kernel의 종류
2. 운영체제의 구분
3. 운영체제의 기능