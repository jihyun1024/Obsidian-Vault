---
tags:
  - 수업_정리
title: Main Memory (2)
---
## 학습 주제
1. Paging
2. Swapping

---
## 연관 수업
[[운영체제_2주차_화요일]]
[[운영체제_2주차_목요일]]
[[운영체제_12주차_화요일]]

---
## 강의 요약
[[운영체제_12주차_화요일#Paging|Paging]] 강의 내용에서 바로 이어지는 강의이니, 모르겠으면 저번 강의를 보고 오자. 
### Paging
Paging 뿐만이 아닌 다른 개념을 소개할 때도 Logical address와 Physical address라는 표현을 자주 보게 될 것인데, Paging의 기본 개념 중 physical memory를 고정된 사이즈의 블록으로 바꾼 것을 **Frame**이라 하며, logical memory를 동일한 사이즈의 블록으로 바꾼 것을 **Page**라 한다. 

이 때, logical address 공간은 physical address 공간과 완벽하게 분리되어 있는 상태로, 실제로 사용하는 것은 physical address 공간에 있는 것이지만, physical address 공간에 있는 데이터들은 분할되어서 저장되어 있기 때문에 그 데이터들이 각각 어디에 있는지 매칭하기 위해 page를 쓴다.

![[Pasted image 20251126045448.png]]
CPU로부터 생성된 모든 주소들은 몇 번째 page임을 나타내는 page number와 page 내에서 몇 번째 offset인지 나타내는 page offset의 두 부분으로 나누어진다. 

이렇게 나누는 이유는 다음 사진을 참고하면 자세히 알 수 있다. ![[Pasted image 20251126045639.png]]
page number는 frame number로 대응되며, 이는 paging을 구현하기 위한 요소인 **Page Table**에 의해 변환되어 frame으로 매칭되어 해당 프레임 내의 offset에 있는 데이터를 가지고 올 수 있다. 

Page table이란, 몇 번 Page는 몇 번 Frame에 있는지 알려주기 위해 고안된 개념으로, 위의 사진에서는 연속적으로 저장되었지만, 실제로는 다음과 같이 저장될 수 있다. 
![[Pasted image 20251126050200.png]]
이 상황에서 physical memory에 있는 page는 불연속적으로 저장되기 때문에, 이 그림에서 특정 페이지, 예를 들어 page 2를 찾으려면 다음과 같은 과정을 거친다. 

1. Page number 2를 찾고 그 2를 page table의 index로 사용한다. 
2. Index 2에 해당하는 Frame number 3을 page table에서 찾는다. 
3. Page number 2를 Frame number 3으로 replace한다. 

이 때 page의 크기는 주소와 관련이 있으며 hardware에 의해 결정된다. page의 크기는 2의 제곱으로 4KB와 1GB 사이에서 관리된다. 만약 page의 크기로 4KB를 사용할 경우, 4KB = $2^{12}$ byte 이므로 $n = 12$가 되어 12bit를 page offset에 할당한다. 이는 page offset이 곧 page의 크기와 관련되기 때문이다. 

만약 Logical address의 크기가 $2^m$ byte이고 page size가 $2^n$일 경우, 다음 그림처럼 최상위 $m-n$ bit는 page number를 나타내며 $n$bit는 page offset을 나타낸다.

예를 들어, 아래의 상황에서는 page number와 page offset의 범위가 전부 0에서 3까지 나타난다.
![[Pasted image 20251126051711.png]]

아니면 다음 사진과 같은 Paging 방법도 있다. ![[Pasted image 20251126051859.png]]
이 상황은 **Free-Frame List**를 가지고 있어 어디어디가 빈 공간인지 기억해 뒀다가 새로운 프로세스가 들어오면 해당 빈 공간에 각각 Paging을 하는 방법이다. 

사실, Paging 자체가 page table에 접근하고, 그 table이 가리키는 주소에도 한번 더 접근하는 이중 접근을 유발하게 되어 상당한 비효율성을 가진다. 따라서, 이러한 비효율성을 해결하기 위해서 새로운 방식을 사용하는데, 바로 굉장히 작고 빠른 캐시 메모리를 이용해 lookup table을 만들어 자주 접근하는 데이터만 모아 놓는 방식인 **TLB (Translation Look-aside Buffer)** 방식을 사용할 수 있다. 

이 그림을 참고해서 보자.![[Pasted image 20251126052632.png]]
logical address에 접근하는 것까지는 똑같지만, 바로 page table을 뒤지는 게 아니라 page table 중 자주 쓰는 것만 모아 놓은 TLB를 먼저 뒤져서 miss가 나지 않는다면 빠르게 frame number를 찾을 수 있다. 만약 miss가 난다면 page table을 뒤져서 frame number를 찾는다. 

간단하게 계산을 해 보자. 

TLB hit, TLB miss가 있고, hit ratio는 TLB hit이 성공할 확률을, 메모리에 한 번 접근할 때는 10ns가 걸린다고 가정해 보자. 이 경우, Effective Memory Access Time은 다음과 같이 계산할 수 있다. 

- hit ratio = 80%일 경우: EAT = $0.8 \times 10 + 0.2 \times 20 = 12ns$
- hit ratio = 99%일 경우: EAT = $0.99 \times 10 + 0.01 \times 20 = 10.1ns$

이렇게 hit ratio가 올라감에 따라 메모리 접근 시간이 점점 줄어들어 TLB를 쓰지 않을 때보다 더 효율적으로 메모리를 관리할 수 있음을 파악할 수 있다. 

한편, 다음 사진의 상황을 가정해 보자.![[Pasted image 20251126053913.png]]
이 사진에서는 **valid-invalid bit**을 사용해 특정 page가 valid한지, invalid한지 판단한다. 

Paging의 장점으로는 동일한 코드(예: 텍스트 에디터, 컴파일러, Windows System)를 여러 프로세스가 공유할 때, 해당 page를 공유하도록 같은 frame으로만 연결해 주면 되기 때문에 메모리를 절약할 수 있다는 장점이 있다. 

Page table을 만들 때, 만약 32bit logical address space에서 12bit를 page offset으로 할당한다면, $2^{20}$ 만큼의 page table을 만들 수 있는데 이는 page table을 만들게 된 근본적인 이유인 fragmentation을 오히려 더 유발할 수 있어 비효율적이다. 

이러한 상황을 해결하기 위한 방법으로는 세 가지의 방법이 있다. 

- Hierarchical Paging
	- OS에서 가장 많이 채택하는 방법
	- 보통 Level 4 또는 5 사용
	-  logical address space를 더 작은 table로 나누는 방법![[Pasted image 20251126054946.png]]
	- 위의 2-Level의 경우, $2^{20}$에서 $2^{10}$으로 줄어들어서 1024개만 만들면 된다. ![[Pasted image 20251126055150.png]]
	- 이보다 더 잘게 쪼갤 수도 있다. 
	- 단점: 메모리 참조를 2번이 아니라 그보다 더 많이 수행
- Hashed Page Table
	- hash table을 관리하는 방식
	- hash function의 결과에 해당하는 frame만 뒤지면 되어 효율적인 관리 가능![[Pasted image 20251126055755.png]]
- Inverted Page Table
	- 역전된 방식으로, frame마다 해당하는 page를 기록해 놓는 방식
	- process id까지 같이 조회![[Pasted image 20251126055925.png]]

### Swapping
**Swapping**이란 [[운영체제_13주차_화요일|다음 시간]]에 배울 Virtual Memory와 연결이 되는 개념이다. 

프로세스의 수에 비해 메모리는 항상 부족하기 때문에 일시적으로 다른 저장매체로 swap을 해 뒀다가 필요하면 main memory에 올리는 방식으로 동작한다. ![[Pasted image 20251126060313.png]]
이 때 backing store는 SSD나 하드 디스크 등이 될 수 있다. 

자세한 내용은 다음 시간에 다루는 것으로 하자. 

---
## 중요한 단어
1. Paging
2. Frame & Page
3. Page Table
4. Free-Frame List
5. TLB (Translation Look-aside Buffer)
6. Valid-Invalid Bit
7. Hierarchical Paging
8. Hashed Page Table
9. Inverted Page Table
10. Swapping