---
tags:
  - 수업_정리
  - Programming
---
## 학습 주제
1. Implicit Threading
2. Thread Pools
3. Fork & Join
4. OpenMP
5. Grand Central Dispatch (GCD)

---
## 연관 수업
[[운영체제_4주차_화요일]]
[[운영체제_4주차_목요일]]

---
## 강의 요약
이번 수업은 드디어 Thread를 다루는 수업의 마지막이다. 힘내서 공부해 보자. 
### Implicit Threading
관리해야 하는 스레드의 수가 늘어남에 따라, explicit threading, 즉 [[운영체제_4주차_목요일]] 수업에서 배웠던 하나하나 코딩하는 방법으로는 프로그램의 관리가 더 어려워졌다. 

이 때, **Implicit Threading**이라는 방법이 나왔는데, 이는 프로그래머가 직접 스레드를 생성하거나 관리하지 않고, 컴파일러나 런타임 시스템에서 자동적으로 병렬 처리를 수행하는 방법이다. 

쉽게 말하면, 프로그래머가 `Thread` 객체를 만들고, `start()`를 호출하고, `join()`으로 기다리는 등의 복잡한 작업을 하지 않아도 컴파일러가 코드를 분석해서 병렬로 실행할 수 있는 부분을 찾아내고 런타임이 알아서 스레드를 생성하고 작업을 분산해서 실행하는 것이다. 

Implicit Threading에는 밑에서 살펴볼 네 가지의 방법들이 있다. 

### Threading Pools
Thread를 미리 많이 만들어 놓고, 애플리케이션이 필요로 할 때마다 Pool에서 그 Thread를 빌려오는 방식으로 요약할 수 있다. 

장점은 다음과 같다. 
1. 새로 Thread를 만드는 것보다 이미 있는 Thread를 빌려오는 게 속도가 더 빠르다. 
2. 동시에 실행될 수 있는 Thread 수를 제한할 수 있어 시스템 자원을 과도하게 사용하는 것을 방지할 수 있다. 
3. 여러 작업을 균등하게 Thread에 분배할 수 있어 시스템 전체의 부하를 분산시킬 수 있다. 

다음 세 개의 코드가 사용된다. 
- `static ExecutorService newSingleThreadExecutor()`
- `static ExecutorService newFixedThreadPool(int size)`
- `static ExecutorService newCachedThreadPool()`

Java로 코딩한 예시는 다음과 같다. 
```java
import java.util.concurrent.*;

public class ThreadPoolExample {
	public static void main(String[] args) {
		int numTasks = Integer.parseInt(args[0].trim());
		
		// 새로운 Thread Pool 생성
		ExecutorService pool = Executors.newChachedThreadPool();
		
		// 각각의 Task를 Pool의 thread를 사용해 실행
		// 병렬화 할 부분에 Pool 사용
		for (int i = 0; i < numTasks; i++) {
			pool.execute(new Task());
		}
		
		// 모든 Thread가 종료되면 Pool 닫기
		pool.shutdown();
	}
}
```

### Fork & Join
분할정복법과 유사하며, main thread를 fork해서 task를 수행하고 이를 join해서 다시 main thread로 합치는 방법으로 요약할 수 있다. 

Pseudo-code는 왼쪽 사진과 같고, Fork & Join 전략은 오른쪽 사진처럼 확장할 수 있다. 
![[Pasted image 20251001054725.png|320x170]]![[Pasted image 20251001054803.png|280x280]]

`ForkJoinTask`는 `ForkJoinPool`이라는 Thread Pool을 사용하는 추상 클래스로, 이 클래스를 상속받은 두 가지 주요 클래스가 있다. 
- `RecursiveTask`
	- 반환값이 있어 사칙연산 등에 주로 사용한다. 
- `RecursiveAction`
	- 반환값이 없어 출력 등에 주로 사용한다. 

Java로 코딩한 예시는 다음과 같다.
```java
import java.util.concurrent.*;

public class Sumtask extends RecursiveTask<Integer> {
	// begin과 end 사이 값들이 얼마나 차이나는지 계산해서
	// fork할지 안할지 판단
	static final int THRESHOLD = 1000; 
	
	private int begin;
	private int end;
	private int[] array;
	
	public SumTask(int begin, int end, int[] array) {
		this.begin = begin;
		this.end = end;
		this.array = array;
	}

	protected Integer conpute() {
		if (end - begin < THRESHOLD) { // 합 연산의 노가다 횟수가 작은 경우
			int sum = 0;
			for (int i = begin; i <= end; i++)
				sum += array[i];
		
			return sum;
		}
		else { // 합 연산의 노가다 횟수가 큰 경우
			int mid = (begin + end) / 2; // 중간값을 설정
		
			// SumTask를 사용해 중간까지 더한 것과 그 뒤로 더한 것을 계산
			SumTask leftTask = new SumTask(begin, mid, array);
			SumTask rightTask = new SumTask(mid + 1, end, array);
		
			// 스레드를 두 개로 fork 
			leftTask.fork();
			rightTask.fork();
			
			// 두 개의 결과를 join
			return rightTask.join() + leftTask.join();
		}
	}
}

// 실제 코드 실행
ForkJoinPool pool = new ForkJoinPool();
int[] array = new int[SIZE];

SumTask task = new SumTask(0, SIZE - 1, array);
int sum = pool.invoke(task);
```

### OpenMP
C, C++, FORTRAN 언어를 위해 제작된 API이다. 
사용 방법은 굉장히 간단한데, parallel하게 처리할 영역에 블록 표시를 하고 `#pragma omp parallel`이라고 해 놓기만 하면 된다. 이럴 경우, 코어에서 버틸 수 있을 만큼 많은 Thread를 만들어 병렬화를 수행한다. 

C 언어로 코딩한 예시는 다음과 같다. 
```cpp
#include <stdio.h>
#include <omp.h> // OpenMP 헤더파일

#define SIZE 100000000

int a[SIZE], b[SIZE], c[SIZE];

int main(int argc, char *argv[]) {
	int i;
	for (i = 0; i < SIZE; i++)
		a[i] = b[i] = i;
		
	#pragma omp parallel for -> 이 부분을 parallel하게 실행행
	for (i = 0; i < SIZE; i++) {
		c[i] = a[i] + b[i];
	}
	
	return 0;
}
```

### Grand Central Dispatch (GCD)
macOS, iOS 운영체제를 위해 Apple 社가 개발한 것이다. 
이것도 사용 방법이 간단한데, 병렬화를 시키고자 하는 코드 주위로 중괄호 블록을 만들고, 거기에 `^`를 붙이기만 하면 된다. 

디스패치 큐(Dispatch queue)란 작업을 실행할 Queue이며, 두 가지 종류가 있다. 
1. Serial Queue: 한 번에 하나의 작업만 실행 (순차적)
2. Concurrent Queue: 여러 작업을 동시에 실행 (병렬적)
	- 우선순위(Quality Of Service, QOS) 개념이 존재 -> 작업의 중요도를 시스템에 알려줘서 리소스 배분과 실행 순서에 영향을 줌
	- `QOS_CLASS_USER_INTERACTIVE`: 1순위로 실행, UI와 직접적인 연관성이 있음
		- UI 애니메이션, 터치 반응 등
	- `QOS_CLASS_USER_INITIATED`: 2순위로 실행, 사용자가 요청한 작업
		- 문서 열기, 검색 결과 표시 등
	- `QOS_CLASS_USER_UTILITY`: 3순위로 실행, 시간이 좀 걸려도 되는 작업
		- 다운로드, 데이터 동기화 등
	- `QOS_CLASS_USER_BACKGROUND`: 4순위로 실행, 사용자에게 보이지 않는 작업
		- 백업, 로그 정리 등

Apple이 개발한 Swift 언어에서는 다음의 예시처럼 사용된다. 
```swift
// 비동기 작업을 백그라운드에서 실행하고, 완료 후 메인 큐에서 UI 업데이트
DispatchQueue.global(qos: .background).async {
    // 백그라운드 작업
    let result = heavyComputation()

    DispatchQueue.main.async {
        // UI 업데이트
        self.label.text = "결과: \(result)"
    }
}
```

---
## 중요한 단어
1. Implicit Threading
2. Threading Pools
3. Fork & Join
4. OpenMP
5. Grand Central Dispatch (GCD)
