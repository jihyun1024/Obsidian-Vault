---
tags:
  - 수업_정리
title: Main Memory
---
## 학습 주제
1. Background
2. Contiguous Memory Allocation
3. Paging

---
## 연관 수업
[[운영체제_2주차_화요일]]
[[운영체제_2주차_목요일]]

---
## 강의 요약
여태까지 Synchronization, Deadlock, CPU Scheduling 등을 배웠다면, 이제부턴 운영체제 강의의 후반부에 해당하는 Memory에 대해 배우게 된다. 
### Background
2주차 때 배웠던 것처럼, 프로세스는 실행 중인 프로그램으로 메인 메모리에 로드되어 실행되고 있으며, 프로그램은 수동적인 개념으로 디스크 내부에 존재한다. 

**메모리**는 많은 바이트의 배열로 이루어지며, 각각의 바이트는 그에 해당하는 주소를 가지고 있다. 이 주소라는 개념은 [[LockBit 3.0 랜섬웨어 분석]], [[Ragnar Locker 랜섬웨어 분석]] 등 다른 공부를 하면서도 많이 나올 테니, 잘 배워 놓자. 

한편, CPU는 메모리로부터 명령어를 가져와서 프로세스를 실행하며, 이 말은 즉 CPU와 메모리는 서로 상호작용한다는 의미이다. 

이때, 각각의 프로세스가 어떤 명령어를 사용하는지 구분하기 위해 **Memory space**라는 개념을 사용한다. 기준이 되는 지점인 base register와 얼마까지 쓸 수 있는지를 명시한 limit register를 사용하며, 이는 각 프로세스가 쓸 수 있는 주소의 범위를 결정한다. 즉, 프로세스가 쓸 수 있는 주소의 범위를 결정함으로써 해당 범위 내부에 있는 명령어만을 사용하게 된다. 
![[Pasted image 20251118220240.png]]

이와 동시에 메모리 공간에 대한 Protection = 보호도 할 수 있어 CPU가 접근을 원할 때, 다음과 같이 base register보다 밑에 있거나, limit register보다 위에 있는 주소를 요청하면 옳지 않은 주소를 건드리고 있다는 의미이므로 error를 반환한다. ![[Pasted image 20251118220529.png]]

주소는 두 가지의 종류가 있는데, 0에서 시작한다 가정하고 지정하는 상대적인 주소인 **Logical Address**와 컴퓨터에서 지정해 주는 절대적인 주소인 **Physical Address**가 있다. 
이 주소들을 하나로 묶어서 맞춰 주는 작업이 필요한데, 이를 **Address Binding**이라고 한다. 

컴파일러는 코드 레벨의 symbolic address를 상대적인 주소인 relocatable address로 바꿔 주며, Linker나 Loader는 relocatable address를 절대적인 주소인 absolute address로 바꾼다. 
![[Pasted image 20251118221410.png]]
즉, relocatable address의 정식 명칭은 logical address이며, absolute address의 정식 명칭은 physical address가 되는 것이다. 

이런 것들을 관리하는 게 바로 **MMU(Memory Management Unit)** 라는 하드웨어이며, 이 디바이스는 CPU와 physical memory 사이에서 logical address를 physical address로 변환한다. 
![[Pasted image 20251118221725.png]]

사실, 모든 프로그램과 데이터를 굳이 physical memory에 올릴 필요는 없는데, 이를 전부 버티기에는 RAM의 용량이 많아봐야 64GB라서 버티지 못할 것이다. 이를 해결하기 위해 **Dynamic Loading**이라는 방식을 사용하는데, 이는 필요한 부분만 dynamic하게 메모리에 올려서 효율적으로 작업을 수행하며 메모리 관리도 할 수 있는 방식이다. 

### Contiguous Memory Allocation
Contiguous라는 단어는 '연속적인'이라는 의미로, Contiguous memory allocation은 메모리를 따로따로 올리지 않고, 메모리 공간에 연속적으로 올리는 방식이다.

보통 메모리는 OS를 위한 부분과 User program을 위한 부분으로 나누어지며, 메모리 할당은 User를 위한 부분에서 이루어진다. 

contiguous memory allocation은 각각의 프로세스가 메모리의 단일 섹션을 사용하는 방식으로, limit register를 넘지 않았는지만 검사하면 되어 간단하다. 하지만, 간단한 것이 흔히 그렇듯이 문제가 있는데, 바로 Fragmentation 문제이다. 

예를 들어, 다음 상황을 가정해 보자. ![[Pasted image 20251118222615.png]]
이 상황에서 process 8을 다시 할당하려 하면, 남는 곳이 있음에도 불구하고 process 8은 할당될 수 없다. 이 문제를 해결하기 위해 세 가지 방법이 사용된다.

- **First Fit**: 바로 위의 사진과 비슷한 방법
- **Best Fit**: 딱 맞게 할당하는 방식
- **Worst Fit**: 무지성 할당하는 방식

이 중에서 Worst Fit을 뺀 두 가지 방식을 비교해 보자. 
![[Pasted image 20251118222946.png]]
사진에 나와 있듯이, First Fit보다 Best Fit이 더 효율적으로 메모리를 사용했다는 것을 알 수 있다.

앞에서 언급했던 **Fragmentation**, 즉 파편화는 두 가지 상황이 있을 수 있다.

- externel fragmentation
	- 메모리의 총 공간은 충분하지만, 앞에서의 예시처럼 불연속적으로 할당되는 경우
	- 이 경우, 사용 가능한 공간은 연속적이지 않을 수 있음
	- 사이즈가 큰 프로세스가 할당될 경우, 조각조각 나눠서 할당됨
- internel fragmentation
	- 프로세스에 할당된 메모리 크기가 필요한 메모리 크기보다 큰 경우 = 남는 경우
	- 해당 경우에도 사용하지 않은 메모리가 낭비될 수 있음

따라서, 이를 위해 **Paging**이라는 기법을 활용한다. 

### Paging
Paging의 핵심 원리는 메모리가 할당될 때 굳이 연속적으로 할당되지 않아도 된다고 허용하는 것으로, 대부분의 OS는 paging 기법을 사용한다. 

다음 시간쯤에 배울 Segmentation과의 차이점은 paging은 균등하게 분할하는 반면, segmentation은 다양한 크기로 분할해 메모리를 할당한다. (segmentation은 딱히 중요하진 않다.)

이로 인해 contiguous memory allocation에서 발생하는 문제인 externel fragmentation과 프로세스를 적당히 재배치해 흩어져 있는 작은 빈 공간들을 하나의 큰 빈 공간으로 만드는 메모리 압축(compaction)으로 인한 많은 오버헤드를 해결할 수 있다. 
*(두 번째 문제점의 경우, 오버헤드는 프로세스를 재배치하는 과정에서 나타난다)*

그러나, paging을 위해 구현되어야 하는 게 있는데, 쪼개져서 할당되어 있기 때문에 어디에 어떤 프로세스에 대한 명령어가 있는지 알기 위한 테이블이 필요하다. 그 내용은 다음에 다룬다. 

---
## 중요한 단어
1. 메모리
2. Memory space
3. Logical/Physical Address
4. Address Binding
5. MMU(Memory Management Unit)
6. Dynamic Loading
7. Contiguous Memory Allocation
8. First/Best/Worst Fit
9. Fragmentation
10. Paging