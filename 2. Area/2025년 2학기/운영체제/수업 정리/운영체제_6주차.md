---
tags:
  - 수업_정리
---
## 학습 주제
1. SRTF Scheduling
2. RR Scheduling
3. Priority Scheduling
4. Multi Level Queue (MLQ) Scheduling
5. Multi Level Feedback Queue (MLFQ) Scheduling

---
## 연관 수업
[[운영체제_5주차_목요일]]

---
## 강의 요약
이번 시간에서는 저번 5주차 목요일에 다뤘던 FCFS, SJF Scheduling에 더해 다섯 개의 Scheduling 방법들을 추가로 알아보도록 할 것이다. 
### SRTF Scheduling
**SRTF Scheduling**은 Shortest Remaining Time First의 약자로, SJF(Shortest Job First) Scheduling의 Preemptive한 버전이다. 실행을 시키면서 해야 남은 시간(Remaining Time)이 존재하기 때문에 이름에서도 Preemptive하다는 것을 알 수 있다. 

![[Pasted image 20251014060026.png|500]]
만약 이 사진에서처럼 서로 다른 4개의 프로세스들이 서로 다른 시간에 도착한다 하자. 이 경우, 가장 먼저 온 $P_1$이 동작하고 있는 상태이다. 이후 1초에 $P_2$가 도착하는데, 이 경우 $P_1$의 남은 시간은 7초이고, $P_2$의 남은 시간은 4초이기 때문에 남은 시간이 더 적게 남은 $P_2$로 Context switch한다.

이렇게 $P_4$까지 전부 들어오고 나서 전부 종료된 뒤의 Gantt chart를 그려 보면 다음과 같다. 
![[Pasted image 20251014060349.png]]

각 프로세스에 대해 Waiting Time과 Turnaround Time을 계산해 보자. 

먼저 Turnaround Time의 경우, $(전체\ 실행\ 종료\ 시각) - (Arrival\ Time)$의 공식으로 계산된다. 
- $P_1$ : 17 - 0 = 17
- $P_2$ : 5 - 1 = 4
- $P_3$ : 26 - 2 = 24
- $P_4$ : 10 - 3 = 7
이는 Turnaround Time의 정의가 프로세스 하나를 전부 처리하는 데 들은 시간이기 때문이다. 

Waiting Time은 이를 이용해 계산할 수 있으며, $(Turnaround\ Time) - (Burst\ Time)$의 공식으로 계산된다. 왜냐하면 SRTF는 Preemptive하기 때문에 중단될 수 있어 전체 대기 시간은 모든 대기 구간의 합으로 계산해야 하기 때문이다. 
- $P_1$ : 17 - 8 = 9
- $P_2$ : 4 - 4 = 0
- $P_3$ : 24 - 9 = 15
- $P_4$ : 7 - 5 = 2

혹시나 Turnaround Time, Waiting Time 등의 개념을 모르겠다면 [[운영체제_5주차_목요일#Scheduling Criteria|5주차 목요일의 Scheduling Criteria]] 부분으로 다시 가서 복습해 보자. 

### RR Scheduling
**RR Scheduling**은 Round Robin의 약자로, 일종의 Preemptive한 FCFS인데, 거기에 **Time quantum**이란 개념을 곁들인 것이다. Time quantum이란, 시간을 일정 단위로 쪼개고 ready queue에 circular queue를 사용해 1개의 Time quantum마다 프로세스를 할당해 실행한다. 

여기에는 2가지의 경우가 있다. 
1. 프로세스의 Burst Time이 Time quantum보다 작을 경우
	1. 프로세스는 알아서 CPU를 반환한다. 
	2. 그 직후 ready queue에 있는 다른 프로세스가 수행된다. 
2. 프로세스의 Burst Time이 Time quantum보다 클 경우
	1. 타이머가 꺼지고 Context switch가 강제로 일어나 프로세스가 종료된다. 
	2. 이후 해당 프로세스는 ready queue의 끝에 저장되고, 다른 프로세스가 수행된다. 

예를 들어, $P_1, P_2, P_3$ 프로세스가 다음과 같이 들어오고, Time quantum이 4ms일 때, 
![[Pasted image 20251014063134.png]]
Gantt chart는 다음과 같이 그려진다. 

이 Gantt chart에서 Waiting Time은 다음과 같이 계산된다. 
- $P_1$ : $P_2$의 Waiting Time + ($P_3$의 Waiting Time $-$ $P_2$의 Waiting Time) = 4 + 3 = 7
- $P_2$ : 4
- $P_3$ : 7
이렇듯, 평균 Waiting Time이 다른 Scheduling 방법에 비해 상대적으로 길지만, 그럼에도 이걸 배우는 이유는 Time quantum 덕분에 하나의 긴 프로세스가 무한히 딜레이되어 실행되지 않는 사태가 일어나지 않기 때문이다. 

이런 장점을 보장해 주는 Time quantum의 길이는 너무 작지도 크지도 않게 잘 정해줘야 잦은 Context switch로 인한 오버헤드 없이 효율적으로 작업을 수행할 수 있다. 

### Priority Scheduling
**Priority Scheduling**은 기존의 스케줄링 방법들이 오로지 효율성에만 관심을 두었다면, 이 방법은 프로세스 간의 우선순위를 고려해 실행 순서를 결정한다. 만약 우선순위가 같은 것이 있다면 FCFS처럼 동작하며, SJF 또한 next CPU burst에 우선순위를 둔 하나의 Priority Scheduling이라 할 수 있다. 
이 강좌에서는 낮은 번호일수록 우선순위가 높다고 가정한다. 

![[Pasted image 20251014071033.png|400]]
이런 프로세스들이 들어왔다 가정했을 때, Gantt chart는 다음과 같이 그려진다. 
![[Pasted image 20251014071102.png]]

Priority Scheduling은 Preemptive와 Non-preemptive 둘 다 될 수 있고, **기아(Starvation) 현상**이 발생할 수 있다. 이는 우선순위가 낮은 프로세스들이 우선순위가 높은 프로세스에 밀려 실행되지 못하고 계속 대기하는 현상을 말한다. 따라서 이를 막기 위해 **Aging**이라는 방법을 사용한다. 

이는 시스템에서 오래 기다린 프로세스들의 우선 순위를 점진적으로 높여 실행되지 못하는 프로세스의 수를 최대한 줄이는 방법이다. 

또한, Priority Scheduling 방법과 RR Scheduling 두 개의 방법을 결합해 우선순위가 높은 것을 먼저 처리하면서 동시에 같은 우선순위에 대해선 Time quantum을 사용하는 방법 또한 있다. 
![[Pasted image 20251014071811.png]]

### Multi Level Queue (MLQ) Scheduling
**Multi Level Queue Scheduling**은 여러 개의 ready queue를 사용하는 방법으로, 이 방법을 사용하기 위해서는 다음과 같은 parameter가 필요하다. 

- ready queue의 개수
- 각 ready queue에 적용할 Scheduling algorithm
- ready queue 간에 적용할 Scheduling algorithm
- 각 queue에 들어갈 프로세스의 타입

이 방법 또한 위의 Priority Scheduling처럼 여러 방법과 결합해서 사용할 수 있다. 
예를 들어, 아래 사진처럼 Priority Scheduling과 결합해 사용하는 방법이 있다. 
![[Pasted image 20251014072339.png|350]]![[Pasted image 20251014072401.png|300]]
이 경우는 highest priority로 갈수록 사용자가 어떤 요청을 했을 때, 그에 대해 시스템이 빠르고 부드럽게 반응하는 정도인 반응성이 높다고 할 수 있다. 

### Multi Level Feedback Queue (MLFQ) Scheduling
 **Multi Level Feedback Queue Scheduling**은 위의 MLQ Scheduling의 장점인 반응성에 더해 공정성까지 확보하려는 알고리즘으로, 여러 개의 큐를 사용해 점점 낮은 우선순위 큐로 내려가 Priority Scheduling에서의 단점인 기아 현상을 완화할 수 있다. 
 
이 방법의 경우, 각 queue는 우선순위와 Time quantum을 전부 다르게 가진다. 
모든 프로세스는 최상위 큐에서 시작해 정해진 Time quantum 내에 완료하지 못하면 다음 순위 큐로 이동해 Batch process 등 CPU를 오래 쓰는 작업도 실행할 수 있다. 
![[Pasted image 20251014073307.png]]

이 사진에서 상위 큐에는 우선순위가 높은 작업들이 있으며, 하위 큐에는 우선순위가 낮은 작업들이 있지만 결국 Feedback에 의해 상위 큐는 빨리 끝나게 동적으로 조정되기 때문에 하위 큐 내의 작업들 또한 실행될 수 있다. 

---
## 중요한 단어
1. SRTF Scheduling
2. RR Scheduling
3. Time quantum
4. Priority Scheduling
5. Starvation & Aging
6. Multi Level Queue Scheduling
7. Multi Level Feedback Queue Scheduling
