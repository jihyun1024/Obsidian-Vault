---
tags:
  - 일일_노트
  - 수업_정리
---
## 학습 주제
1. Interprocess Communication
2. Producer-Consumer Problem
3. Shared Memory
4. Message Passing
5. Communications in Client-Server Systems

---
## 이전 수업
[[운영체제_2주차_목요일]]
[[운영체제_3주차_화요일]]

---
## 강의 요약
이번에는 프로세스 1, 2강에 이어 마지막인 프로세스 3강이다.

### Interprocess Communication
프로세스는 다른 프로세스들과 상호작용, 즉 데이터를 share하는지에 따라 independent한 process와 cooperating한 process로 분류할 수 있다. 이 중 우리가 다룰 것은 cooperating process로, 보통의 컴퓨터에서 cooperating process를 사용하는 이유는 다음과 같다. 
1. 프로세스 간 정보의 쉬운 공유
2. 컴퓨터 연산의 속도 증가
3. 모듈화의 용이함
4. 편리함

Cooperating process들은 IPC(InterProcess Communication) 메커니즘이 필요하며, 이는 데이터를 process들끼리 서로 주고받는 작업을 할 수 있도록 한다. 

IPC의 종류는 크게 Shared Memory, Message Passing 두 가지로 나눠진다.

### Producer-Consumer Problem
Cooperating process들은 Producer 프로세스가 정보를 생산하고 Consumer 프로세스가 정보를 소비하는 방식으로 이루어진다. 

더 자세하게 말하면, producer와 consumer 프로세스들이 메모리 공간을 공유할 때, 두 프로세스가 전부 제대로 동작하기 위해서 버퍼가 필요하며, producer는 버퍼를 채우고, consumer는 버퍼를 비우는 역할을 한다. 

이 때 버퍼의 종류는 두 종류가 있는데, **unbounded-buffer**와 **bounded-buffer**로, 
- unbounded-buffer: 버퍼의 크기에 제한 없이 동적할당으로 무한정 버퍼를 할당할 수 있다. 
	- Producer: 기다리지 않고 계속 데이터를 채울 수 있다. 
	- Consumer: 소비할 데이터가 없다면 기다린다.
- bounded-buffer: fix된 버퍼의 크기가 있다 가정하며, 
	- Producer: 버퍼의 모든 공간이 다 차면 기다린다.
	- Consumer: 소비할 데이터가 없다면 기다린다. 
실제 시스템에서는 bounded-buffer 모델을 더 많이 사용하고, 이는 프로그래밍 관점에서 Circular array(원형 배열)로 구현할 수 있다. 

```cpp
#define BUFFER_SIZE 10

typedef struct {
	...
} item;

item buffer[BUFFER_SIZE];
int in = 0;
int out = 0;
```
만약 `in == out`이라면, buffer는 빈 것이며, `(in + 1) % BUFFER_SIZE == out`이라면 buffer는 꽉 찬 것으로 간주한다.

```cpp
item next_produced;

while (true) {
	while (((in + 1) % BUFFER_SIZE) == out)
	 /* do nothing */
	 
	buffer[in] = next_produced;  // 실행할 것을 버퍼에 넣음
	in = (in + 1) % BUFFER_SIZE; // in을 1 증가
}
```
producer process의 경우, 이 코드의 흐름처럼 동작하며, 두 번째 while문은 `in`이 `out` 바로 전까지 온 상황으로, 버퍼가 꽉 찬 상태이기 때문에 더 이상 뭔가를 할 수 없다. 

```cpp
item next_consumed;

while (true) {
	while (in == out) 
		/* do nothing */
		
	next_consumed = buffer[out];   // 버퍼에서 실행할 것을 빼 옴
	out = (out + 1) % BUFFER_SIZE; // out을 1 증가
}
```
consumer process의 경우는 이 코드처럼 동작하며, 두 번째 while문은 `in`과 `out`이 만나는 상황으로, `out`이 1씩 늘어가다 `in`과 만나 버퍼가 비어있기 때문에 이 상태에서도 뭔가를 할 수 없다.

### Shared Memory
Shared Memory 기법은 메모리의 일정 부분을 프로세스들이 서로 공유하는 것으로, Shared Memory에 접근하고, 이를 다루는 코드 부분은 개발자들에 의해 명시적으로 있어야 한다. 

그 이유는 Shared Memory 부분은 OS에 내장되어 있지 않아 프로그램마다 따로따로 관리를 해줘야 하기 때문이다.

### Message Passing
IPC는 `send(message)`와 `receive(message)` 총 두 개의 연산을 제공하며, `message`의 길이는 OS에서 어떻게 지원하는지에 따라 fixed인지, variable인지가 다르다.

만약 프로세스 P, Q가 서로 통신하기 원한다면, P, Q는 서로 링크를 만들어야 하며, 이 링크를 통해 메시지를 서로 주고받을 수 있다.

이 과정에서 여러 질문들이 있다:
1. 어떻게 링크를 만들 수 있는지?
2. 링크 하나가 두 개 이상의 프로세스에 연결될 수 있는지?
3. 모든 communicating process들의 쌍 사이에 존재할 수 있는 링크는 총 몇 개일지?
4. 링크 하나의 용량이 얼마나 될지?
5. 링크를 통해 보낼 수 있는 메시지의 크기가 고정인지, 가변일지?
6. 링크가 단방향일지, 양방향일지?

논리적으로는, 다음 두 가지로 분류할 수 있다. 
#### Direct of Indirect
Direct communication 상에서는 각각의 프로세스가 통신하려면 반드시 명시적으로 송신자 또는 수신자의 이름을 써넣어야 한다. 

예: `send(P, message)`: P에게 메시지를 전송, `receive(Q, message)`: Q로부터 메시지를 수신

이러한 Direct communication link의 특징은 
- 링크들은 자동적으로 설정된다.
- 하나의 링크는 정확히 두 개의 communicating process 쌍에 대해서만 연결된다.
- 링크는 보통 양방향으로 설정된다. (단방향도 가능하긴 하다)

이를 코드로 살펴보면
```cpp
message next_produced;

while (true) {
	/* Produce an item in next_produced */
	
	send(next_produced);
}


message next_consumed;

while (true) {
	receive(next_consumed);
	
	/* consume the item in next_consumed */
}
```
으로, 송신 측은 item을 생성해 그걸 전송하고, 수신 측은 그걸 전송받은 뒤에 item을 사용한다.

반면, Indirect communication의 경우, 
메시지는 **mailbox(또는 port)** 라고 하는 것으로부터 전송된다. 이 때 mailbox는 추상적으로 객체라는 개념으로 볼 수 있다. 추가로, OS는 새로운 mailbox를 만들거나 mailbox를 통해 메시지를 송수신하거나 mailbox를 제거하는 기능을 지원한다.

이 때의 예시도 Direct일 때와 비슷하게`send(A,message)`: mailbox A로 message 전송, `receive(A,message)`: mailbox A로부터 message 수신으로 해석할 수 있다. 

이러한 Indirect communication link의 특징은 
- 링크들은 프로세스 쌍 사이에 설정되며, 이 프로세스 쌍에 있는 프로세스들은 공유된 mailbox를 가지고 있어야 설정된다. 
- 하나의 링크에 두 개 이상의 communicating process들을 연결할 수 있다.
- 링크는 단방향과 양방향 전부 가능하다. 

#### Synchronous or Asynchronous
위의 Mailbox sharing에서 P1, P2, P3가 있고, P1이 송신자, P2, P3가 수신자라 해 보자. 이 상황에서 P1이 보내는 메시지를 P2가 받을지, P3가 받을지 어떻게 알 수 있을까?

답은 최대 2개의 프로세스들에 대해서만 링크를 허용하거나, 단 하나의 프로세스만 수신 작업을 허용하거나, 시스템이 임의로 수신자롤 고르고, 시스템이 송신자에게 누가 수신자인지를 공지하는 방법이 있다. 

이 때 Blocking과 Non-blocking 방법이 있다.
- Blocking = **synchronous**
	- 송신자: message가 수신될 때까지는 송신자의 활동이 block된다. 
	- 수신자: message가 유효할 때까지는 수신자의 활동이 block된다. 
- Non-blocking = **asynchronous**
	- 송신자: 얼마든지 원하는 대로 message를 보낼 수 있다.
	- 수신지: 얼마든지 원하는 대로 message를 받을 수 있다. 
		- 이 때의 message는 Valid한 것이거나, Null이다. 

### Communications in Client-Server Systems
소켓은 포트 번호와 연결된 IP 주소로 식별할 수 있다. ![[Pasted image 20250919010902.png|500]]

소켓은 여러 종류가 있으며, 연결형 프로토콜인 TCP, 비연결형 프로토콜인 IP, 다수의 수신자가 있는 Multicast 등으로 구분할 수 있다. [[2주차_TCP&IP 전송계층|TCP&IP 전송계층]] 수업 요약을 참고하자.

---
## 중요한 단어
1. IPC(InterProcess Communication)
2. Cooperating process
3. Producer-Consumer Problem
4. Mailbox