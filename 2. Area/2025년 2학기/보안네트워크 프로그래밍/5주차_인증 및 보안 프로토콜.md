---
tags:
  - 수업_정리
  - C언어
  - 암호학
---
## 학습 주제
1. 비밀번호 기반 인증
2. 매체에 의한 인증 방식 분류
3. 비밀번호 기반 인증 구현
4. OpenSSL 암호화 프로그래밍

---
## 연관 수업
[[3주차_TCP&IP 클라이언트_서버 소켓 프로그래밍 (1)]]
[[4주차_TCP&IP 클라이언트_서버 소켓 프로그래밍 (2)]]

---
## 강의 요약
### 비밀번호 기반 인증
시스템에서 사용자를 인증하는 방법은 여러 가지가 있지만, 대표적인 방법으로는 IP와 Port 번호를 이용한 사용자 식별 및 인증이 널리 사용되고 있다. 

그러나 실제로 해 보면 알겠지만, IP 주소는 위치 또는 사용하는 네트워크에 따라 변동되고, 같은 IP를 여러 사용자들이 사용하기도 한다. 따라서 IP 주소는 현재 위치나 네트워크를 나타내는 값일 뿐, 사용자를 식별할 수는 없다. Port 번호 또한 매 연결 시 변경되는 것을 확인할 수 있다. ![[Pasted image 20251008184615.png]]

따라서, 이 방법으로는 사용자를 지속적으로 식별할 수 없다. 그래서 우리는 TCP를 기반으로 **ID와 비밀번호를 통해 사용자 식별 및 인증**을 구현할 예정이다.

비밀번호 기반 인증의 단계는 다음과 같다. 
1. 사용자 식별(User Identification): 접근하려 하는 유저가 누구인지 알아내는 단계
2. 사용자 인증(User Authentication): 유저가 정말 그 사람이 맞는지 인증하는 단계
3. 사용자 인가(User Authorization): 인증된 유저에게 권한을 부여하는 단계

보면 알겠지만, 사용자 식별 단계에서 ID가 사용되고 사용자 인증 단계에서 비밀번호가 사용된다.

### 매체에 의한 인증 방식 분류
그 전에 사용자 인증 방식의 분류 중 하나로, 시험에 많이 나오는 **매체에 의한 인증 방식**의 분류에 대해 알아볼 것이다. 

매체에 의한 인증 방식은 다음 네 가지로 나누어진다. 다른 시험들에서도 나오니 외워 두자. 

1. 지식 기반(what you know): 사용자가 알고 있는 정보에 기반 (예: ID, PW, PIN)
2. 소유 기반(what you have): 사용자가 가지고 있는 것에 기반 (예: 교통카드, 학생증)
3. 생체 기반(what you are): 사용자만이 가지는 고유한 특징 기반 (예: 홍채, 지문, 얼굴)
4. 행위 기반(what you do): 사용자가 하는 행동을 기반으로 인증 (예: 사인)

### 비밀번호 기반 인증 구현
그러면, 개념은 거의 배웠으니, 이제 비밀번호 기반 인증을 구현하는 프로그램을 작성해 보자. 

우리는 **배열기반 사용자 데이터베이스**를 이용해 인증 서버에 다수의 사용자를 위한 계정 목록을 저장할 수 있게 할 것이며, 인증은 클라이언트가 ID와 PW를 서버에 먼저 제시하면 서버는 데이터베이스에서 이를 탐색하고 이와 일치하는 ID와 PW가 있는지 판단함으로 수행할 것이다. 

사실 데이터베이스라는 게 거창한 게 아니라, User 수, ID와 PW의 최대 자릿수 등을 미리 지정하고 이를 2차원 배열로 구현해서 **구분자**를 통해 구분해 저장하면 되는 것이다. 

그러면 인증 서버에 해당하는 `TCPServer.c`를 먼저 구현해 보자. 
```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "Practical.h"

static const int MAXPENDING = 5; // 연결 요청을 대기할 수 있는 최대 수

// 간단한 사용자 데이터베이스 정의-----------------------------------
#define MAX_USER_NUMBER 200        // 최대 수용 가능한 사용자의 수
#define MAX_USER_ACCOUNT_LEN 20    // 사용자의 아이디와 비밀번호 최대 자릿수
  
// 현재 등록된 사용자의 아이디 목록
char list_user_id[MAX_USER_NUMBER][MAX_USER_ACCOUNT_LEN]; 
// 현재 등록된 사용자의 비밀번호 옥록
char list_user_pwd[MAX_USER_NUMBER][MAX_USER_ACCOUNT_LEN]; 
// 현재 등록된 사용자의 수
int registered_user_num; 
// ------------------------------------------------------------------

// 새로운 사용자 등록 (사용자의 아이디와 비밀번호를 사용자 데이터베이스에 추가)
int add_user_2_db(const char* id, const char* pwd) {
    // 현재 등록된 사용자의 수
    if (id == NULL || pwd == NULL) 
        DieWithUserMessage("add_user_2_db() failed", "invalid input id, pwd");

	// 데이터베이스가 꽉 찼을 때
    if (registered_user_num >= MAX_USER_NUMBER)
        DieWithUserMessage("add_user_2_db() failed", "user datebase is full");

    int len;
    len = strlen(id);
    if (len > MAX_USER_ACCOUNT_LEN - 1)
        DieWithUserMessage("add_user_2_db() failed", "invalid input id, pwd");
    strncpy(list_user_id[registered_user_num], id, len);
    list_user_id[registered_user_num][len] = '\0';
  
    len = strlen(pwd);
    if (len > MAX_USER_ACCOUNT_LEN - 1)
        DieWithUserMessage("add_user_2_db() failed", "invalid input id, pwd");

    strncpy(list_user_pwd[registered_user_num], pwd, len);
    list_user_pwd[registered_user_num][len] = '\0';

	// 이 함수를 한 번 실행할 때마다 등록한 사용자의 수 증가 
    registered_user_num++; 
    return registered_user_num;
}

// 사용자 데이터베이스 초기화 (5명의 사용자 등록)
void init_user_db() {
        // 초기화
        memset(list_user_id, 0, sizeof(list_user_id));
        memset(list_user_pwd, 0, sizeof(list_user_pwd));
        registered_user_num = 0;

        // 사용자 추가
        add_user_2_db("CryptoWorld", "1234");
        add_user_2_db("kmulSCM", "1233");
        add_user_2_db("dr.You", "1901");
        add_user_2_db("Python", "2025");
        add_user_2_db("student", "1111");
}

// 상수시간 문자열 동등 비교
// 반환: 같으면 1, 다르면 0
static unsigned char const_time_str_eq_fixed(const char* fixed, const char* var, size_t fixed_len) {
    size_t var_len = strnlen(var, fixed_len); // var 길이를 fixed_len(버퍼 크기)까지 제한하여 측정

    unsigned char diff = 0;
    for (size_t i = 0; i < fixed_len; i++) {
        unsigned char a = (unsigned char)fixed[i]; // 저장된 바이트
        unsigned char b = (unsigned char)(i < var_len ? var[i]: '\0'); // 입력 바이트 또는 NULL 패딩
        diff |= (a ^ b); // XOR로 다르면 1, 같으면 0이 나오도록 함
        if (diff != 0) break;
    }

    // 입력이 fixed_len 이상이면 길이 불일치 처리
    diff |= (unsigned char)(var_len >= fixed_len ? 1 : 0);
    return (unsigned char)(diff == 0);
}

// 입력된 ID와 Pwd에 매치되는 항목이 있는지 탐색
bool authenticate_user(const char* id, const char* pwd) {
    if (id == NULL || pwd == NULL) return false;
  
    int n = registered_user_num;
    if (n < 0) n = 0;
    if (n > MAX_USER_NUMBER) n = MAX_USER_NUMBER;

    for (int i = 0; i < MAX_USER_NUMBER; ++i) {
        unsigned char id_eq = const_time_str_eq_fixed(list_user_id[i], id, MAX_USER_ACCOUNT_LEN);
        unsigned char pwd_eq = const_time_str_eq_fixed(list_user_pwd[i], pwd, MAX_USER_ACCOUNT_LEN);
        if (id_eq & pwd_eq) return true;
    }

    return false;
}

// 클라이언트로부터 메시지를 수신, ID, PWD를 가져오는 함수
// 더블 포인터를 사용한다는 것을 잊지 말자. 
void recv_msg(int c_sock, char** p_id, char** p_pwd) {
    // 오류처리
    if (c_sock < 0 || p_id == NULL || p_pwd == NULL)
        DieWithUserMessage("recv_msg() failed", "invalid input parameters - socket descryptor, id, pwd");
        
    char buffer[BUFSIZE + 1];
    int numBytes;

    numBytes = recv(c_sock, buffer, BUFSIZE, 0); // 클라이언트로부터 메시지를 수신해 버퍼에 담음
    if (numBytes < 0)
        DieWithSystemMessage("recv() failed");
    else if (numBytes == 0)
        return;

    buffer[numBytes] = '\0'; // 문자열 종료

    // strtok 함수를 통해 첫 두 개의 단어를 파싱
    *p_id = strtok(buffer, ";"); // 버퍼로부터 첫 번째 단어, 즉 ID를 가져옴
    *p_pwd = strtok(NULL,";"); // 첫 번째 매개변수가 NULL일 경우, 그 다음 단어를 가져옴 (즉, 비밀번호)
    if (*p_id == NULL || *p_pwd == NULL)
        DieWithUserMessage("recv_msg() failed", "invalid input parameters - socket descryptor, id, pwd");
}
  
int main(int argc, char *argv[]) {
    char buffer[BUFSIZE];
    ssize_t len = 0, numBytesSent = 0;
  
    if (argc != 2) // 명령어 인자의 개수 확인
        DieWithUserMessage("Parameter(s)", "<Server Port>");

    in_port_t servPort = atoi(argv[1]); // 첫 번쨰 인자: 지역 포트

    // User 데이터베이스 초기화
    init_user_db();

    // 연결 요청을 처리하는 소켓 생성
    int servSock; // 서버 소켓 식별자
    if ((servSock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
        DieWithSystemMessage("socket() failed");

    // 지역 주소 구조체 생성
    struct sockaddr_in servAddr; // 지역 주소
    memset(&servAddr, 0, sizeof(servAddr)); // 0으로 구조체 초기화
    servAddr.sin_family = AF_INET; // IPv4 주소 패밀리
    servAddr.sin_addr.s_addr = htonl(INADDR_ANY); // 호스트의 어떤 IP로도 연결 요청 수락
    servAddr.sin_port = htons(servPort); // 지역 포트

    // 지역 주소에 바인드(bind)
    if (bind(servSock, (struct sockaddr *) &servAddr, sizeof(servAddr)) < 0)
        DieWithSystemMessage("bind() failed");

    // 소켓이 들어오는 요청을 처리할 수 있도록 설정 (listen)
    if (listen(servSock, MAXPENDING) < 0)
        DieWithSystemMessage("listen() failed");

    // main 함수 (무한 반복)
    for (;;) {
        struct sockaddr_in clntAddr; // 클라이언트 주소
        socklen_t clntAddrLen = sizeof(clntAddr); // 클라이언트 주소 구조체의 크기 설정
        char *id, *pwd;

        // 클라이언트의 연결을 기다림
        int clntSock = accept(servSock, (struct sockaddr *) &clntAddr, &clntAddrLen);
        if (clntSock < 0)
            DieWithSystemMessage("accept)_failed");

        printf("Connected to Client: ");
        PrintSocketAddress((struct sockaddr*)&clntAddr, stdout);

        // 클라이언트로부터 메시지를 수신 및 인증
        recv_msg(clntSock, &id, &pwd);
        if (authenticate_user(id, pwd)) {
            sprintf(buffer, "Welcome %s", id);
            printf("\nThe user (%s, %s) is authenticated\n", id, pwd);
            len = strlen(buffer);
        }
        else {
            strcpy(buffer, "Authentication failed. ~~~~");
            printf("\nThe user (%s, %s) is not found\n", id, pwd);
            len = strlen(buffer);
        }

        numBytesSent = send(clntSock, buffer, len, 0);
        if (numBytesSent < 0)
            DieWithSystemMessage("send() failed");
        else if (numBytesSent != len)
            DieWithUserMessage("send()", "sent unexpected number of bytes");

        close(clntSock);
    }
    close(servSock);
}
```

그 다음은 `TCPClient.c`를 구현해 보자. 
```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "Practical.h"

void send_msg(int sock, char* id, char* pwd) {
        if (sock < 0 || id == NULL || pwd == NULL)
                DieWithUserMessage("send_msg() failed", "invalid input parameters - socket descryptor, id, pwd");

        char buffer[BUFSIZE];
        int len;
        int numBytes;

        memset(buffer, 0, BUFSIZE);
        sprintf(buffer, "%s;%s", id, pwd); // 아이디와 패스워드를 세미콜론으로 구분하여 전송
        len = strlen(buffer);

        numBytes = send(sock, buffer, len, 0);
        if (numBytes < 0)
                DieWithSystemMessage("send() failed");
        else if (numBytes != len)
                DieWithUserMessage("send()", "sent unexpected number of bytes");
}

int main(int argc, char *argv[]) {
        if (argc < 5 || argc > 6) // 명령어 인자의 정확한 개수 확인
                DieWithUserMessage("Pararmeter(s)", "<Server Address> <User ID> <User Password> [<Server Port>]");

        char *servIP = argv[1]; // 서버 IP
        char *useID = argv[2];
        char *usePWD = argv[3];

        in_port_t servPort = (argc == 5) ? atoi(argv[4]) : 7; // 포트 지정, 없으면 기본 7로 고정

        // TCP 소켓 생성
        int sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (sock < 0)
                DieWithSystemMessage("socket() failed");

        // 서버 주소 구조체 생성
        struct sockaddr_in servAddr;
        memset(&servAddr, 0, sizeof(servAddr));
        servAddr.sin_family = AF_INET;

        // 문자열 IP -> 네트워크 주소 변환
        int rtnval = inet_pton(AF_INET, servIP, &servAddr.sin_addr.s_addr);
        if (rtnval == 0)
                DieWithUserMessage("inet_pton() failed", "invalid address string");
        else if (rtnval < 0)
                DieWithSystemMessage("inet_pton() failed");

        servAddr.sin_port = htons(servPort);

        // 서버 연결
        if (connect(sock, (struct sockaddr *) &servAddr, sizeof(servAddr)) < 0)
                DieWithSystemMessage("connect() failed");

        printf("Connected to Server: ");
        PrintSocketAddress((struct sockaddr *) &servAddr, stdout);


        // 서버에 ID와 PASSWORD를 전송
        printf("\nSending User Account to Server: %s/%s", useID, usePWD);
        send_msg(sock, useID, usePWD);

        unsigned int numBytes = 0;
        fputs("\nReceived: ", stdout);
        do {
                char buffer[BUFSIZE];
                numBytes = recv(sock, buffer, BUFSIZE-1, 0);
                if (numBytes < 0)
                        DieWithSystemMessage("recv() failed");
                else if  (numBytes == 0)
                        break;

                buffer[numBytes] = '\0';
                fputs(buffer, stdout);
        } while (1);
        
        close(sock);
}
```

### OpenSSL 암호화 프로그래밍
비밀번호를 통한 인증을 구현했으니, 이제 TCP 관련은 잠시 내려놓고, OpenSSL 암호화 라이브러리를 이용하여 해시 함수와 HMAC 함수를 다뤄 볼 예정이다. 

그 전에 **OpenSSL의 EVP 라이브러리**에 대해 알아야 한다. 

EVP 라이브러리란 OpenSSL에서 제공하는 고수준의 추상화 라이브러리로, 다양한 암호 알고리즘에 대한 인터페이스를 제공하여 **개발자가 특정 알고리즘을 직접 구현하지 않아도 효율적인 암호화와 복호화, 해시, MAC 등의 작업을 할 수 있도록 돕는 라이브러리**이다. 

EVP는 EnVeloP의 약자로, 봉투라는 이름 답게 해시, 대칭키 암호, 공개키 암호, MAC, 키 파생(키 도출) 등을 알고리즘에 독립적으로 다룰 수 있게 한다. 
즉, 코드가 특정 알고리즘에 의존되지 않도록 인터페이스를 추상화해서 만약 이 알고리즘이 맘에 안 든다면 코드 전체를 뜯어고칠 필요 없이 다른 알고리즘으로 쉽게 변경할 수 있도록 한다.

이 방법의 장점은 보안, 코드의 유지 및 보수, 호환성 면에서 좋으며, 가능한 한 EVP API를 사용하라 권장한다. 이는 FaS에서 배웠던 [[CNG (Cryptography Next Generation)]]와 비슷하다. 

핵심 구성요소는 다음과 같다: 

1. `EVP_MD`/`EVP_MD_CTX`: 메시지 다이제스트 = 해시
2. `EVP_CIPHER`/`EVP_CIPHER_CTX`: 대칭키 암호 - AEAD 포함
3. `EVP_PKEY`/`EVP_PKEY_CTX`: 공개키 암호 (암호화, 서명, 검증, 키교환)
4. `EVP_MAC`/`EVP_MAC_CTX`: OpenSSL 3.x부터 지원하며, HMAC, CMAC 등의 MAC 연산
5. `EVP_KDF`/`EVP_KDF_CTX`: PBKDF2, HKDF 등 키 파생
6. `OSSL_PARAM`: **알고리즘 옵션**(예: Digest 이름, Tag 길이 등)을 이름/값 쌍으로 전달

#### 예제 1 - 해시 함수
그러면 첫 번째로 해시 함수에 대해서 다뤄 보자. 

`EVP_MD`/`EVP_MD_CTX`에서 `EVP_MD`는 해시 알고리즘 객체(예: `EVP_sha256()`)를 의미하며, `EVP_MD_CTX`는 CTX, 즉 컨텍스트라는 이름에서 알 수 있듯 해시 연산을 위한 컨텍스트이다.

>여기서 말하는 컨텍스트(Context)란 OpenSSL에서 해시 함수를 사용할 때 필요한 상태 정보를 담고 있는 구조체로, 해시 연산의 중간 상태를 저장한다. 

해시 함수를 계산하는 방법에는 크게 두 가지가 있다. 

1. 한 번에 계산(convenience)
	1. `EVP_Digest(const void *data, size_t datalen, unsigned char* md, unsigned int* md_len, const EVP_MD* md_type, ENGINE *impl)`로 정의
	2. 입력을 전부 주고 한 번에 다이제스트를 받아오는 편의형 함수
	3. 계산할 크기가 크지 않을 때 사용
2. 증분 방식(incrememtal)
	1. 컨텍스트 생성: `EVP_MD_CTX_new()` ->`EVP_MD_CTX_free()` 으로 해제
	2. 초기화: `EVP_DigestInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl)` -> 알고리즘 지정
	3. 업데이트: `EVP_DigestUpdate(EVP_MD_CTX *ctx, const void *data, size_t cnt)`      -> 데이터의 일부를 반복적으로 공급하면서 업데이트
	4. 최종 다이제스트 출력: `EVP_DigestFinal_ex(EVP_MD_CTX *ctx, unsigned char *md, unsigned int *s)`

이 때 크기를 지정하는 상수는 최대 해시 바이트 길이를 배정하는 `EVP_MAX_MD_SIZE`와 특정 알고리즘의 출력 바이트 길이를 지정하는 `EVP_MD_size(const EVP_MD *md)`가 있다. 

예제를 프로그래밍해보면 다음과 같다. 
```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <openssl/evp.h>
#include <openssl/err.h>

/* 헥사 출력 보조함수 */
static void hexprint(const unsigned char* buf, size_t len) {
    for (size_t i = 0; i < len; ++i) printf("%02x", buf[i]);
    printf("\n");
}

/* 1) 단일 호출 (one-shot) 방식: 메모리 상의 버퍼 해시 */
void hash_one_shot(const unsigned char* data, size_t datalen) {
    unsigned char digest[EVP_MAX_MD_SIZE];
    unsigned int digest_len = 0;

    /* 편의형 단일 호출 -> 해시 대상이 많이 크지 않을 때*/
    if (!EVP_Digest(data, datalen, digest, &digest_len, EVP_sha256(), NULL)) {
        fprintf(stderr, "EVP_Digest failed\n");
        return;
    }

    printf("One-shot SHA-256: ");
    hexprint(digest, digest_len);
}

/* 2) 증분 방식(incremental): 스트림 또는 큰 파일에 유용함 */
int hash_stream_file(const char* filename) {
    FILE* f = fopen(filename, "rb");
    if (!f) {
        perror("fopen");
        return -1;
    }

    EVP_MD_CTX* mdctx = EVP_MD_CTX_new();
    if (!mdctx) {
        fprintf(stderr, "EVP_MD_CTX_new failed\n");
        fclose(f);
        return -1;
    }

    if (EVP_DigestInit_ex(mdctx, EVP_sha256(), NULL) != 1) {
        fprintf(stderr, "EVP_DigestInit_ex failed\n");
        EVP_MD_CTX_free(mdctx);
        fclose(f);
        return -1;
    }

    unsigned char buf[4096];
    size_t n;
    while ((n = fread(buf, 1, sizeof(buf), f)) > 0) {
        if (EVP_DigestUpdate(mdctx, buf, n) != 1) {
            fprintf(stderr, "EVP_DigestUpdate failed\n");
            EVP_MD_CTX_free(mdctx);
            fclose(f);
            return -1;
        }
    }
    if (ferror(f)) {
        perror("fread");
        EVP_MD_CTX_free(mdctx);
        fclose(f);
        return -1;
    }

    unsigned char digest[EVP_MAX_MD_SIZE];
    unsigned int digest_len = 0;
    if (EVP_DigestFinal_ex(mdctx, digest, &digest_len) != 1) {
        fprintf(stderr, "EVP_DigestFinal_ex failed\n");
        EVP_MD_CTX_free(mdctx);
        fclose(f);
        return -1;
    }

    printf("File SHA-256 (%s): ", filename);
    hexprint(digest, digest_len);

    EVP_MD_CTX_free(mdctx);
    fclose(f);
    return 0;
}

int main(int argc, char** argv) {
    ERR_load_crypto_strings();
    OpenSSL_add_all_algorithms();

    const char* msg = "Hello, OpenSSL EVP SHA-256!";
    hash_one_shot((const unsigned char*)msg, strlen(msg));

    if (argc >= 2)
        hash_stream_file(argv[1]);
    else
        printf("Usage: %s <file-to-hash>\n", argv[0]);

    /* 정리 */
    EVP_cleanup();
    ERR_free_strings();
    return 0;
}
```
이며, 이를 컴파일하고 실행하면 다음과 같은 결과가 나온다. 
이 때 컴파일은 `gcc -o mdtest mdtest.c -lcrypto -lssl`로 컴파일해야 한다. 

![[Pasted image 20251008210452.png]]

#### 예제 2 - HMAC 함수
두 번째로 HMAC 함수에 대해 다뤄 보자. 이것도 기본적인 메커니즘은 해시 함수와 같아 해시 함수의 동작만 잘 이해했어도 무난하게 따라올 수 있다. 

`EVP_MAC`은 OpenSSL 3 이상 버전에서 MAC(메시지 인증 코드)을 추상화한 알고리즘 핸들이며, 
`EVP_MAC_CTX`는 MAC 연산의 컨텍스트 객체로, `EVP_MAC_CTX_new()`로 만들고 `EVP_MAC_CTX_free()`로 해제한다. 

HMAC을 계산하는 방법도 해시와 마찬가지로 크게 두 가지가 있다. 

1. 한 번에 계산(convenience)
	1. `unsigned char *HMAC(const EVP_MD *evp_md, const void *key, int key_len, const unsigned char *d, size_t n, unsigned char *md, unsigned int *md_len)`
	2. 입력을 전부 주고 한 번에 HMAC을 계산하는 편의형 함수
	3. 계산할 크기가 크지 않을 때 사용
2. 증분 방식(incrememtal)
	1. 구현 핸들을 가져옴: `EVP_MAC_fetch(OSSL_LIB_CTX *libctx, const char *name, const char *propq)` -> 사용할 MAC 알고리즘 지정
	2. 컨텍스트 생성: `EVP_MAC_CTX_new(EVP_MAC *mac)` ->`EVP_MAC_CTX_free()` 으로 해제
	3. 초기화: `EVP_MAC_init(EVP_MAC_CTX *ctx, const unsigned char *key, size_t keylen, const OSSL_PARAM params[])`-> 키 적용 & 알고리즘 파라미터 설정
	4. 업데이트: `EVP_MAC_update(EVP_MAC_CTX *ctx, const unsigned char *data, size_t datalen)`-> 데이터의 일부를 반복적으로 공급하면서 업데이트
	5. 최종 태그 출력 및 실제 바이트 길이 반환: `EVP_MAC_final(EVP_MD_CTX *ctx, unsigned char *out, size_t *outlen, size_t outsize)`

예제를 프로그래밍해보면 다음과 같다. 
```cpp
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// 추가로 include해야 하는 헤더파일
#include <openssl/opensslv.h>
#include <openssl/hmac.h>
#include <openssl/evp.h>
#include <openssl/core_names.h>
#include <openssl/params.h>
#include <openssl/err.h>

static void hexprint(const unsigned char* p, size_t len) {
    for (size_t i = 0; i < len; ++i) printf("%02x", p[i]);
    printf("\n");
}

int hmac_one_shot_evp(const unsigned char* key, size_t keylen,
    const unsigned char* data, size_t datalen,
    unsigned char* out, size_t* outlen, size_t outsize)
{
    unsigned int ulen = 0;
    unsigned char* r = HMAC(EVP_sha256(), key, (int)keylen, data, datalen, out, &ulen);
    if (!r) return 0;
    *outlen = (size_t)ulen;
    (void)outsize;
    return 1;

#ifdef NEVER
    int ok = 0;
    EVP_MAC* mac = NULL;
    EVP_MAC_CTX* mctx = NULL;

    mac = EVP_MAC_fetch(NULL, "HMAC", NULL);
    if (!mac) goto done;

    mctx = EVP_MAC_CTX_new(mac);
    if (!mctx) goto done;

    /* set digest = "SHA256" */
    OSSL_PARAM params[2];
    params[0] = OSSL_PARAM_construct_utf8_string(OSSL_ALG_PARAM_DIGEST, (char*)"SHA256", 0);
    params[1] = OSSL_PARAM_construct_end();

    if (!EVP_MAC_init(mctx, key, keylen, params)) goto done;

    if (!EVP_MAC_update(mctx, data, datalen)) goto done;

    if (!EVP_MAC_final(mctx, out, outlen, outsize)) goto done;

    ok = 1;

done:
    if (mctx) EVP_MAC_CTX_free(mctx);
    if (mac) EVP_MAC_free(mac);
    return ok;
#endif
}

int hmac_stream_evp(const unsigned char* key, size_t keylen,
    const unsigned char** chunks, const size_t* chunk_lens, size_t n_chunks,
    unsigned char* out, size_t* outlen, size_t outsize)
{
    int ok = 0;
    EVP_MAC* mac = NULL;
    EVP_MAC_CTX* mctx = NULL;

    mac = EVP_MAC_fetch(NULL, "HMAC", NULL);
    if (!mac) goto done;

    mctx = EVP_MAC_CTX_new(mac);
    if (!mctx) goto done;

    OSSL_PARAM params[2];
    params[0] = OSSL_PARAM_construct_utf8_string(OSSL_ALG_PARAM_DIGEST, (char*)"SHA256", 0);
    params[1] = OSSL_PARAM_construct_end();

    if (!EVP_MAC_init(mctx, key, keylen, params)) goto done;

    for (size_t i = 0; i < n_chunks; ++i) {
        if (!EVP_MAC_update(mctx, chunks[i], chunk_lens[i])) goto done;
    }

    if (!EVP_MAC_final(mctx, out, outlen, outsize)) goto done;

    ok = 1;

done:
    if (mctx) EVP_MAC_CTX_free(mctx);
    if (mac) EVP_MAC_free(mac);
    return ok;
}

int main(void)
{
    ERR_load_crypto_strings();
    OpenSSL_add_all_algorithms();

    const unsigned char key[] = "demo_key_for_hmac_example_32bytes__";
    const unsigned char msg1[] = "Hello ";
    const unsigned char msg2[] = "OpenSSL!";

    unsigned char mac[EVP_MAX_MD_SIZE];
    size_t maclen = 0;

    if (!hmac_one_shot_evp(key, strlen((char*)key), msg1, strlen((char*)msg1), mac, &maclen, sizeof(mac))) {
        fprintf(stderr, "one-shot HMAC failed\n");
        return 1;
    }
    printf("one-shot HMAC-SHA256: "); hexprint(mac, maclen);

    const unsigned char* chunks[2] = { msg1, msg2 };
    const size_t chunk_lens[2] = { strlen((char*)msg1), strlen((char*)msg2) };

    if (!hmac_stream_evp(key, strlen((char*)key), chunks, chunk_lens, 2, mac, &maclen, sizeof(mac))) {
        fprintf(stderr, "streaming HMAC failed\n");
        return 1;
    }
    printf("stream HMAC-SHA256:    "); hexprint(mac, maclen);

    EVP_cleanup();
    ERR_free_strings();
    return 0;
}
```
이며, 이를 컴파일하고 실행하면 다음과 같은 결과가 나온다. 
이 때 컴파일은 `gcc -o hmactest hmactest.c -lcrypto -lssl`로 컴파일해야 한다. 
![[Pasted image 20251008212713.png]]

---
## 중요한 단어
1. 비밀번호 기반 인증 단계
2. 매체에 의한 인증 방식의 분류
3. 배열기반 사용자 데이터베이스
4. OpenSSL EVP 라이브러리